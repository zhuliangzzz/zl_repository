#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import platform
import re
import requests
import json
import math
import random
import filecmp
from pprint import pprint
from datetime import datetime
from collections import defaultdict, Mapping, MutableSequence
from operator import attrgetter
from shutil import copyfile, copytree, move
from forbid_produce import forbid_produce


reload(sys)
sys.setdefaultencoding('utf-8')

PRODUCT = os.environ.get('INCAM_PRODUCT', None)
if platform.system() == "Windows":
    scriptPath = "%s/sys/scripts" % os.environ.get('SCRIPTS_DIR', 'Z:/incam/genesis')
    sys.path.insert(0, "Z:/incam/genesis/sys/scripts/Package")
else:
    scriptPath = "%s/scripts" % os.environ.get('SCRIPTS_DIR', '/incam/server/site_data')
    sys.path.insert(0, "/incam/server/site_data/scripts/Package")
    
from collections_for2_7 import OrderedDict
import Oracle_DB
import MySQL_DB
import genCOM_26 as genCOM
from Gateway import Gateway
from PyQt4 import QtCore, QtGui
from PyQt4.QtGui import *
from PyQt4.QtCore import *
from messageBoxPro import msgBox
import window_panel as FormUi

from genFeatures import *
import TOPCAM_IKM

import gClasses
import numpy

try:    
    jobname = os.environ["JOB"]
    job = gClasses.Job(jobname)
    matrixinfo = job.matrix.getInfo()
    signalLayers = [lay for i, lay in enumerate(matrixinfo["gROWname"])
                    if matrixinfo["gROWcontext"][i] == "board"
                    and (matrixinfo["gROWlayer_type"][i] == "signal" or \
                         matrixinfo["gROWlayer_type"][i] == "power_ground")]
    from auto_calc_target_distance import get_target_distance
    from genesisPackages import innersignalLayers, get_profile_limits, get_sr_limits, \
         mai_drill_layers
    from get_erp_job_info import get_cu_weight, get_inplan_mrp_info, \
         get_StackupData, get_job_type
except Exception, e:
    print e
    pass

from mwClass_V2 import AboutDialog

def send_message_to_director(result, job_name):
    """发送审批结果界面 20221122 by lyh"""
    submitData = {
        'site': u'HDI板事业部',
        'job_name': job_name,
        'pass_tpye': 'CAM',
        'pass_level': 8,
        'assign_approve': '43982|44566|44024|84310|83288|68027',
        'pass_title': result,
    }
    Dialog = AboutDialog(submitData['pass_title'], cancel=True, appCheck=True, appData=submitData)
    Dialog.exec_()
    # endregion

    # --根据审批的结果返回值
    if Dialog.selBut in ['x', 'cancel']:
        return False
    if Dialog.selBut == 'ok':
        return True
    
    return False

# import passwd_dialog as PasswdUi
try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s


# --重写滚轮事件，以免识操作导致选项错误
class QComboBox(QComboBox):
    def wheelEvent(self, QWheelEvent):
        pass


class SplitFeature:
    """
    用于分割feature文件
    """

    def __init__(self):
        pass

    def parseFeatureInfo(self, infoList):
        """Internal - Parses output from the info command when it writes out features.  Uses the genFeatures.py
        module and parses the information from this command (-d FEATURES) into class objects."""
        mainDict = {}
        lineList = []
        arcList = []
        padList = []
        textList = []
        barList = []

        # setup searches
        pat_line = re.compile("^#L")
        pat_arc = re.compile("^#A")
        pat_pad = re.compile("^#P")
        pat_text = re.compile("^#T")
        pat_bar = re.compile("^B")
        for line in infoList:
            line = string.strip(line)
            s_res = pat_line.search(line)
            if (s_res):
                lineObj = Line(line)
                lineList.append(lineObj)
                continue

            s_res = pat_arc.search(line)
            if (s_res):
                arcObj = Arc(line)
                arcList.append(arcObj)
                continue

            s_res = pat_pad.search(line)
            if (s_res):
                padObj = Pad(line)
                padList.append(padObj)
                continue

            s_res = pat_text.search(line)
            if (s_res):
                textObj = Text(line)
                textList.append(textObj)
                continue

            s_res = pat_bar.search(line)
            if (s_res):
                barObj = Barcode(line)
                barList.append(barObj)
                continue

        mainDict['lines'] = lineList
        mainDict['arcs'] = arcList
        mainDict['pads'] = padList
        mainDict['text'] = textList
        mainDict['barcodes'] = barList

        return mainDict


# --查询用到的公用方法，放到公共类中
class PUBLIC(object):
    def __init__(self, job_name):
        self.JOB = job_name
        self.JOB_SQL = self.JOB.upper().split('-')[0] if '-' in self.JOB else self.JOB.upper()
        self.JOB_like = '%' + self.JOB_SQL + '%'
        try:            
            self.layer_number = int(self.JOB[4:6])
        except Exception, e:
            self.layer_number = len(signalLayers)

    def parse_stackup(self, query_result, lamination):
        """
        从查询结果解析叠构
        :return:
        :rtype:
        """
        layer_array_3pp = []  # 用于存储三张PP层别信息
        layer_array_2pp = []  # 用于存储两张PP层别信息
        layer_list = []
        assist_layer = []
        assist_side = []
        assist_ref = []
        JB_layer = []
        pp_sum = 0
        pre_layer = ''  # 起始的pre_layer应该为空字符串
        layer_REG = re.compile(r'^L\d+(-L\d+)?$')
        for stack_dict in query_result:
            layer = stack_dict['层别']
            Type = stack_dict['类别']
            pp_cnt = int(stack_dict['张数'])
            # --如果Type是铜箔或者基板
            # ----------------------------------------------------------------------------------------------------------
            if Type == 'TB' or Type == 'JB' and layer_REG.match(layer):
                pre_lyrs = pre_layer.split('-')
                cur_lyrs = layer.lower().split('-')
                if pp_sum >= 3:
                    # 铜箔前累加pp张数大于等于3张时，将夹三张pp的两张TB或JB层加入数组
                    for layer in pre_lyrs + cur_lyrs:
                        if layer not in layer_array_3pp:
                            layer_array_3pp.append(layer)
                if pp_sum >= 2:
                    # 铜箔前累加pp张数大于等于2张时，将夹2张pp的两张TB或JB层加入数组
                    for layer in pre_lyrs + cur_lyrs:
                        if layer not in layer_array_2pp:
                            layer_array_2pp.append(layer)
                layer_list.extend(pre_lyrs)
                layer_list.extend(cur_lyrs)
                # 出现铜箔或者基板后，将pp_sum_next张数归零
                pp_sum = 0
                # 出现铜箔或者基板后，将pre_layer重置为当前铜箔或基板层
                pre_layer = layer.lower()
                # --如果Type是基板，而且当前层有两层
                if Type == 'JB' and len(cur_lyrs) >= 2:
                    for layer_name in cur_lyrs:
                        layer_fz = layer_name + "-fz"
                        # --获取基板层别列表
                        if layer_name not in JB_layer:
                            JB_layer.append(layer_name)
                        # --获取辅助层别列表,四层以上才需要辅助层
                        if layer_name not in assist_layer and self.layer_number > 2:
                            for lam_des, from_lyr, to_lyr in lamination:
                                if layer_name == from_lyr:
                                    # --如果Type是基板，而且当前层有两层,而且其中一个层别是压合起始层,
                                    # --压合起始层一般不可能在一张JB上，如果在JB上，则表明这次压合需要辅助层
                                    layer_ref = "l" + str(int(from_lyr[1:]) + 2)
                                    assist_layer.append(layer_fz)
                                    assist_side.append('正')
                                    assist_ref.append(layer_ref)
                                    # --在基板层两个层别之间插入辅助层别L1-L2插入l1-fz
                                    layer_list.insert(-1, layer_fz)
                                elif layer_name == to_lyr:
                                    # --如果Type是基板，而且当前层有两层,而且其中一个层别是压合结束层,
                                    # --压合结束层一般不可能在一张JB上，如果在JB上，则表明这次压合需要辅助层
                                    layer_ref = "l" + str(int(to_lyr[1:]) - 2)
                                    assist_layer.append(layer_fz)
                                    assist_side.append('反')
                                    assist_ref.append(layer_ref)
                                    # --在基板层两个层别之间插入辅助层别L1-L2插入l1-fz
                                    layer_list.insert(-1, layer_fz)
            # --如果Type是PP
            # ----------------------------------------------------------------------------------------------------------
            if Type == 'PP':
                pp_sum += pp_cnt
        # --layer_list去重
        sort_list = []
        for layer in layer_list:
            if layer not in sort_list:
                sort_list.append(layer)
        info_dict = {
            'all_layer': sort_list,
            '3pp_layer': layer_array_3pp,
            '2pp_layer': layer_array_2pp,
            'assist_layer': assist_layer,
            'assist_side': assist_side,
            'assist_ref': assist_ref,
            'JB_layer': JB_layer,
        }
        return info_dict

    def chk_lamin_bar_dis(self, lamin_data):
        """
        用于检查每次压合靶位是否错开设计
        :return:
        """
        # print json.dumps(lamin_data,indent=2)
        warn_list = []
        for index, cur_lamin in enumerate(lamin_data):
            cur_x1, cur_x2, cur_y1, cur_y2 = cur_lamin['BAR4X1'], cur_lamin['BAR4X2'], cur_lamin['BAR4Y1'], cur_lamin[
                'BAR4Y2']
            if cur_x1 != cur_x2:
                warn_list.append('压合靶距X1：%s与X2:%s不相同' % (cur_x1, cur_x2))
            if cur_y2 - cur_y1 < 1:
                warn_list.append('压合靶距Y2：%s与Y1:%s差值小于1' % (cur_y2, cur_y1))

            if len(lamin_data) == 1:
                return True
            if index == 0:
                continue
            last_index = index - 1
            last_lamin = lamin_data[last_index]
            last_x1, last_x2, last_y1, last_y2 = last_lamin['BAR4X1'], last_lamin['BAR4X2'], last_lamin['BAR4Y1'], \
                                                 last_lamin['BAR4Y2']
            # === 2022.05.13 float 型的计算可能出现9.9998此类值，更改以下10->9.99。也可以使用Decimal()进行转化
            if last_x1 - cur_x1 == 0:
                if abs(last_y1 - cur_y1) < 9.99 or abs(last_y2 - cur_y2) < 9.99:
                    warn_list.append('压合靶距Y2：%s与Y1:%s对比前次压合\n'
                                     'Y2：%s与Y1:%s差值小于10' % (
                                         cur_y2, cur_y1, last_y2, last_y1))
            elif last_y1 - cur_y1 == 0:
                if abs(last_x1 - cur_x1) < 9.99 or abs(last_x2 - cur_x2) < 9.99:
                    warn_list.append('压合靶距X2：%s与X1:%s对比前次压合\n'
                                     'X2：%s与X1:%s差值小于10' % (
                                         cur_x2, cur_x1, last_x2, last_x1))
                    # sys.exit ()
            else:
                warn_list.append('当前压合靶距X2：%s X1:%s Y2:%s Y1:%s 对比前次压合\n'
                                 'X2：%s X1:%s Y2:%s Y1:%s 靶距规则不在已知范围内' % (
                                     cur_x2, cur_x1, cur_y2, cur_y1, last_x2, last_x1, last_y2, last_y1))
                # sys.exit ()
        if len(warn_list) != 0:
            msg_box = msgBox()
            msg_box.critical(self, '错误', '%s' % "|".join(warn_list), QMessageBox.Ok)
            return False
        else:
            return True


# --所有与ERP查询相关的全部写到ERP类中
class ERP(PUBLIC):
    def __init__(self, job_name):
        PUBLIC.__init__(self, job_name)

        # --连接ERP oracle数据库
        self.DB_O = Oracle_DB.ORACLE_INIT()
        # --servername的连接模式
        self.dbc_e = self.DB_O.DB_CONNECT(host='172.20.218.247', servername='topprod', port='1521',
                                          username='zygc', passwd='ZYGC@2019')
        if not self.dbc_e:
            # --sid连接模式
            self.DB_O = Oracle_DB.ORACLE_INIT(tnsName='sid')
            self.dbc_e = self.DB_O.DB_CONNECT(host='172.20.218.247', servername='topprod1', port='1521',
                                              username='zygc', passwd='ZYGC@2019')

        if not self.dbc_e:
            msg_box = msgBox()
            msg_box.critical(self, '错误', 'ERP无法连接，程序退出', QMessageBox.Ok)
            # return False
            sys.exit()

    def __del__(self):
        # --关闭数据库连接
        if self.dbc_e:
            self.DB_O.DB_CLOSE(self.dbc_e)


    def get_ERP_stackup(self):
        # 从ERP数据库中查出3张pp相关层别
        job_del = '%-B'
        query_sql = """
        SELECT
                TC_AAG00 as 料号,
                TC_AAG02 as 层别,
                TC_AAG09 as 材料类型,
                TC_AAG09 as 类别,
                TC_AAG16 as 品名规格,
                TC_AAG03 as 材料编码,
                TC_AAG05 as 张数,
                TC_AAG29,
                TC_AAG12,
                TC_AAG20 as 制作序号,
                TC_AAG26 as 压合板厚
        FROM
            TC_AAG_FILE
        WHERE
            TC_AAG09 <> 'GB'
            AND TC_AAG00 LIKE '%s'
            AND TC_AAG00 NOT LIKE '%s'
            ORDER BY TC_AAG12
        """ % (self.JOB_like, job_del)
        query_result = self.DB_O.SELECT_DIC(self.dbc_e, query_sql)
        layer_array = []
        layer_list = []
        layer_array_2pp = []
        JB_layer = []
        pp_sum = 0
        pre_layer = ''
        for row in query_result:
            layer = row['层别']
            type = row['材料类型']
            pp_cnt = row['张数']
            if type == 'TB' or type == 'JB':
                pre_lyrs = pre_layer.split('-')
                cur_lyrs = layer.lower().split('-')
                # 夹三张以上pp的层别放入数组
                if pp_sum >= 3:
                    # 铜箔前累加pp张数大于等于3张时，将夹三张pp的两张TB或JB层加入数组
                    layer_array = layer_array + pre_lyrs + cur_lyrs
                
                if pp_sum >= 2:
                    # 铜箔前累加pp张数大于等于2张时，将夹2张pp的两张TB或JB层加入数组
                    for layer in pre_lyrs + cur_lyrs:
                        if layer not in layer_array_2pp:
                            layer_array_2pp.append(layer)
                            
                layer_list = layer_list + pre_lyrs + cur_lyrs
                # 出现铜箔或者基板后，将pp_sum_next张数归零
                pp_sum = 0
                # 出现铜箔或者基板后，将pre_layer重置为当前铜箔或基板层
                pre_layer = layer.lower()
                # --如果Type是基板，而且当前层有两层
                if type == 'JB' and len(cur_lyrs) >= 2:
                    for layer_name in cur_lyrs:
                        # --获取基板层别列表
                        if layer_name not in JB_layer:
                            JB_layer.append(layer_name)
            if type == 'PP':
                # 累加pp张数
                pp_sum += pp_cnt

        # 去除重复数据,并保持层别排序
        sort_array_3 = []
        for i, layer in enumerate(layer_array):
            if layer not in sort_array_3:
                # if layer != "l1" and layer != "l" + str (int (self.JOB[4:6])):
                sort_array_3.append(layer)
        
        # 去除重复数据,并保持层别排序
        sort_list = []
        for i, layer in enumerate(layer_list):
            if layer not in sort_list:
                sort_list.append(layer)
        info_dict = {
            'all_layer': sort_list,
            '3pp_layer': sort_array_3,
            '2pp_layer': layer_array_2pp,
            'JB_layer': JB_layer
        }
        return info_dict


    def get_drill_layers(self):
        """
        从ERP中查询背钻、二钻、机械钻盲孔等需要创建的钻孔层
        :return:['L13-12镭射','L13层背钻',' 一次钻孔','L2-13埋孔','L1-2镭射','L2-3镭射','L2层背钻','L14-13镭射']
        :rtype:
        """
        sql = """
        SELECT 
        DISTINCT
            TC_AAF01 
        FROM
            TC_AAF_FILE 
        WHERE
            TC_AAF00 LIKE '%s'
        """ % self.JOB_like
        drill_layers = []
        query_result = self.DB_O.SELECT_DIC(self.dbc_e, sql)
        for info_dict in query_result:
            drill_layers.append(info_dict['TC_AAF01'])
        return drill_layers

    def get_drill_info(self):
        """
        从ERP中查询钻孔信息，主要目的看控深钻是否有PTH孔，来确定定位孔大小，有PTH，定位孔3.1mm。无PTH，定位孔2.95mm
        http://192.168.2.120:82/zentao/story-view-3265.html
        :return:
        :rtype:
        """
        sql = """
        SELECT
            TC_AAF00 料号部件,
            TC_AAF01 钻带名,
            TC_AAF03 刀序,
            TC_AAF04 刀径,
            TC_AAF06 数量,
            TC_AAF05 属性,
            TC_AAF09 备注,
            TC_AAF32 
        FROM
            TC_AAF_FILE 
        WHERE
            TC_AAF00 = '%s' 
            OR TC_AAF00 LIKE '%s-%%A' 
        ORDER BY
            TC_AAF01,
            TC_AAF03
        """ % (self.JOB_like, self.JOB_like)
        # === 2021.09.16 TODO 更改后续以下语句为所需 ===
        drill_layers = []
        query_result = self.DB_O.SELECT_DIC(self.dbc_e, sql)
        for info_dict in query_result:
            drill_layers.append(info_dict['TC_AAF01'])
        return drill_layers

    def judge_mini_LED(self):
        """
        从ERP获取三级产品类型，看结果是否为Micro LED、Mini LED
        :return:
        """
        sql = """
        SELECT
            ima01 AS JOBNAME,
            tc_abt03 AS LEDTYPE 
        FROM
            ima_file a
            JOIN tc_abt_file b ON ta_ima61 = b.tc_abt02
        WHERE
            ima01 = '%s' 
            AND tc_abt03 IN ( 'Micro LED', 'Mini LED' )
            """ % self.JOB_SQL

        query_result = self.DB_O.SELECT_DIC(self.dbc_e, sql)
        if len(query_result) > 0:
            return True
        else:
            return False

    def judge_phone_subplate(self):
        """
        从ERP获取三级产品类型，看结果是否为手机副板
        :return:
        """
        sql = """
        SELECT
            ima01 AS JOBNAME,
            tc_abt03 AS PROTYPE3 
        FROM
            ima_file a
            JOIN tc_abt_file b ON ta_ima61 = b.tc_abt02
        WHERE
            ima01 = '%s' 
            AND tc_abt03 IN ( '手机副板' )
            """ % self.JOB_SQL

        query_result = self.DB_O.SELECT_DIC(self.dbc_e, sql)
        if len(query_result) > 0:
            return True
        else:
            return False


# --所有与MySQL查询相关的全部写到Project类中
class Project(PUBLIC):
    def __init__(self, job_name, outer_BAR4X1, database="project_status"):
        PUBLIC.__init__(self, job_name)
        # --MySql,连接工程MySql数据库
        self.DB_M = MySQL_DB.MySQL()
        self.dbc_m = self.DB_M.MYSQL_CONNECT(hostName='192.168.2.19', database=database, prod=3306,
                                             username='root', passwd='k06931!')

        self.outer_BAR4X1 = outer_BAR4X1
        # self.job_name = job_name
        self.date_time = datetime.strftime(datetime.now(), "%Y-%m-%d %H:%M:%S")

    def __del__(self):
        '''
        程序结束时关闭数据库连接
        :return: None
        '''
        self.dbc_m.close()

    def get_fd_data(self, direct, panel_x=0, panel_y=0, sr_xmin_mm=0, sr_ymin_mm=0):
        """
        # 查询正式数据库中最新防呆数据

        :param direct:
        :param panel_x:
        :param panel_y:
        :param sr_xmin_mm:
        :param sr_ymin_mm:
        :return:
        """
        query_sql = ''
        sql_table = ''
        if direct == 'horizontal':
            # 水平方向防呆数据库查询
            query_sql = """
            SELECT  fd_times,
                    loop_times,
                    other_fd_dis,
                    right_fd_dis,
                    pin_fd_dis
            FROM hdi_hor_sym_fd_data
            WHERE  jobname='%s'
                    AND panel_x='%s'
                    AND panel_y='%s'
                    AND margin_x='%s'
                    AND margin_y='%s'
            ORDER BY loop_times,
                    fd_times
            """ % (self.JOB.lower(), panel_x, panel_y, sr_xmin_mm, sr_ymin_mm)
        else:
            # 垂直方向防呆数据库查询
            query_sql = """
            SELECT  fd_times,
                    loop_times,
                    other_fd_dis,
                    right_fd_dis
            FROM hdi_ver_sym_fd_data
            WHERE  jobname='%s'
                    AND panel_x='%s'
                    AND panel_y='%s'
                    AND margin_x='%s'
                    AND margin_y='%s'
            ORDER BY loop_times,
                    fd_times
            """ % (self.JOB.lower(), panel_x, panel_y, sr_xmin_mm, sr_ymin_mm)
        # --MySQL的SELECT_DIC方法有问题，此处用SQL_EXECUTE
        query_result = self.DB_M.SQL_EXECUTE(self.dbc_m, query_sql)
        if len(query_result):
            # --返回最后一条记录，也就是最新的数据
            return query_result[-1]
        else:
            # --查询不到结果时，返回空数组
            return []

    def write_base(self, direct, panel_x=0, panel_y=0, sr_xmin_mm=0, sr_ymin_mm=0):
        fd_times = 0
        loop_times = 0
        fd_width = 3
        pin_offset = 0
        values = []
        value_string = ''
        query_sql = ''
        fd_array = []
        date_time = datetime.strftime(datetime.now(), "%Y-%m-%d %H:%M:%S")

        # 查询是否有数据,若有数据：loop_times用数据库中最新的loop_times加1，否则用0;
        if direct == 'horizontal':
            # 水平方向防呆数据库查询
            query_sql = """
            select loop_times, fd_width, pin_fd_dis
            from hdi_hor_sym_fd_base
            where panel_x = '%s'
              and panel_y = '%s'
              and margin_x = '%s'
              and margin_y = '%s'
            order by loop_times""" % (panel_x, panel_y, sr_xmin_mm, sr_ymin_mm)
            # 水平方向防呆偏移数据列表         @fd_array = (-6..0,2..6);
            fd_array = range(-6, 1) + range(2, 7)
        else:
            # 垂直方向防呆数据库查询
            query_sql = """
            select loop_times, fd_width
            from hdi_ver_sym_fd_base
            where panel_x = '%s'
              and panel_y = '%s'
              and margin_x = '%s'
              and margin_y = '%s'
            order by loop_times""" % (panel_x, panel_y, sr_xmin_mm, sr_ymin_mm)
            # 垂直防呆偏移数据列表 @fd_array = (-6..0,2);
            fd_array = range(-6, 1) + [2]

        query_result = self.DB_M.SQL_EXECUTE(self.dbc_m, query_sql)
        if len(query_result) > 0:
            # @recs列表不为空时，代表数据库中已经存在数据,loop_tims需要自增1,开始新一轮循环
            loop_times = query_result[-1][0] + 1
            fd_width = query_result[-1][1]
            if direct == 'horizontal':
                pin_offset = int(query_result[-1][2]) + 1
                if sr_xmin_mm > 20:
                    # pin只有0-7共8个防呆位置，用完重置
                    if pin_offset > 7:
                        pin_offset = 0
                else:
                    if pin_offset > 4:
                        # 留边小于20mm时，pin只有0-2共3个防呆位置，用完重置
                        pin_offset = 0
        for offset in [0]:
            # 其它三个角偏移值(设为0的时候表示保持原位置不动)
            other_offset = offset
            for offset1 in fd_array:
                # 右上角防呆
                right_offset = offset1
                if direct == 'horizontal':
                    # 水平方向，只有一级防呆,right_fd_dis
                    # 防呆次数自增1
                    fd_times += 1
                    # 创建数组，用于生成字符串
                    value = [fd_times, loop_times, fd_width, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm, other_offset,
                             right_offset, pin_offset, date_time]
                    # 用逗号连接，生成字符串
                    value_string = ','.join([str(val) for val in value[0:-1]])
                    # 最后一个字段，日期两边必须加上单引号，否则无法插入
                    value_string = '(' + value_string + ",'" + str(value[-1]) + "')"
                    values.append(value_string)

                    # ping_offset须自增1，防止写入数据库中全是同一数据
                    pin_offset += 1
                    if sr_xmin_mm > 20:
                        if pin_offset > 7:
                            # pin只有0-7共8个防呆位置，用完重置
                            pin_offset = 0
                    else:
                        if pin_offset > 4:
                            # 留边小于20mm时，pin只有0-2共3个防呆位置，用完重置
                            pin_offset = 0
                else:
                    # 垂直方向，只有一级防呆,right_fd_dis
                    # 防呆次数自增1
                    fd_times += 1
                    # 创建数组，用于生成字符串
                    value = [fd_times, loop_times, fd_width, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm, other_offset,
                             right_offset, date_time]
                    # 用逗号连接，生成字符串
                    value_string = ','.join([str(val) for val in value[0:-1]])
                    # 最后一个字段，日期两边必须加上单引号，否则无法插入
                    value_string = '(' + value_string + ",'" + str(value[-1]) + "')"
                    values.append(value_string)
        # 用逗号连接外围数组
        values_str = ','.join(values)
        # 多条数据一起插入数据库语句
        insert_sql = ''
        if direct == 'horizontal':
            insert_sql = """
            insert into hdi_hor_sym_fd_base (fd_times,
                                 loop_times,
                                 fd_width,
                                 panel_x,
                                 panel_y,
                                 margin_x,
                                 margin_y,
                                 other_fd_dis,
                                 right_fd_dis,
                                 pin_fd_dis,
                                 create_date)
            VALUES %s""" % values_str
        else:
            insert_sql = """
            insert into hdi_ver_sym_fd_base (fd_times,
                                 loop_times,
                                 fd_width,
                                 panel_x,
                                 panel_y,
                                 margin_x,
                                 margin_y,
                                 other_fd_dis,
                                 right_fd_dis,
                                 create_date)
            VALUES %s""" % values_str

        # === 写入SQL语句
        self.DB_M.SQL_EXECUTE(self.dbc_m, insert_sql)

    def write_sigle_data(self, direct, fd_width, panel_x=0, panel_y=0, sr_xmin_mm=0, sr_ymin_mm=0, SR_xmax=0):
        loop_times = 0
        fd_times = 0
        other_fd_dis = 0
        right_fd_dis = -6
        pin_fd_dis = 0
        query_sql = ''
        fd_array = []
        fd_count = ''
        if direct == 'horizontal':
            # 查询hdi_hor_sym_data数据库是否有当前尺寸的数据,若有数据：取出loop_times,desc用来将最新数据放在第一行，方便取出
            # --------------------------------------------------------------------------------------------------------------
            query_sql = """
            select loop_times
            from hdi_hor_sym_fd_data
            where panel_x = '%s'
              and panel_y = '%s'
              and margin_x = '%s'
              and margin_y = '%s'
            order by loop_times desc""" % (panel_x, panel_y, sr_xmin_mm, sr_ymin_mm)
            # @fd_array = (-6..0,2..6);
            fd_array = range(-6, 1) + range(2, 7)
            fd_count = len(fd_array)
        else:
            # 查询hdi_ver_sym_data数据库是否有当前尺寸的数据,若有数据：取出loop_times,desc用来将最新数据放在第一行，方便取出
            # --------------------------------------------------------------------------------------------------------------
            query_sql = """
            select loop_times
            from hdi_ver_sym_fd_data
            where panel_x = '%s'
              and panel_y = '%s'
              and margin_x = '%s'
              and margin_y = '%s'
            order by loop_times desc""" % (panel_x, panel_y, sr_xmin_mm, sr_ymin_mm)
            # @fd_array = (-6..0,2);
            fd_array = range(-6, 1) + [2]
            fd_count = len(fd_array)

        query_result = self.DB_M.SQL_EXECUTE(self.dbc_m, query_sql)
        write_base_data = False
        if len(query_result) > 0:
            # @recs列表不为空时，代表数据库中已经存在数据,取出loop_times
            loop_times = query_result[0][0]
        else:
            write_base_data = True

        # 查询正式防呆数据库中当前loop_times最新的fd_times数据
        # ------------------------------------------------------------------------------------------------------------------
        sql_query = ''
        pre_query = ''
        if direct == 'horizontal':
            sql_query = """
            select fd_times, right_fd_dis
            from hdi_hor_sym_fd_data
            where loop_times = '%s'
              and ((panel_x = '%s'
              and panel_y = '%s'
              and margin_x = '%s'
              and margin_y = '%s') or
              (abs(panel_x - margin_x*2 - (%s - %s*2)) < 2 
              and abs(panel_y - margin_y*2 - (%s - %s*2)) < 2
              and jobname like '%s%%'))
            order by fd_times""" % (loop_times, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm,
                                    panel_x, sr_xmin_mm, panel_y, sr_ymin_mm, self.JOB.lower()[:11])
        else:
            sql_query = """
            select fd_times, right_fd_dis
            from hdi_ver_sym_fd_data
            where loop_times = '%s'
              and ((panel_x = '%s'
              and panel_y = '%s'
              and margin_x = '%s'
              and margin_y = '%s') or
              (abs(panel_x - margin_x*2 - (%s - %s*2)) < 2 
              and abs(panel_y - margin_y*2 - (%s - %s*2)) < 2
              and jobname like '%s%%'))
              order by fd_times""" % (loop_times, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm,
                                    panel_x, sr_xmin_mm, panel_y, sr_ymin_mm, self.JOB.lower()[:11])

        # 循环取出所有的数据，用来取出闲置的fd_times
        # ------------------------------------------------------------------------------------------------------------------
        query_result = self.DB_M.SQL_EXECUTE(self.dbc_m, sql_query)
        print 'c' * 40
        print json.dumps(query_result)
        print 'c' * 40
        recs = []
        for i in query_result:
            recs = i
        used_fd_data = [int(i[1]) for i in query_result]

        if len(recs) > 0:
            if direct == 'horizontal':
                # 水平方向，循环取出不与靶标重叠的防呆位置
                fd_times = self.get_opt_fd_times(direct, used_fd_data, panel_x=panel_x, SR_xmax=SR_xmax)
                print 'fd_times_' * 20
                print fd_times
            else:
                # 垂直方向，@recs列表不为空时，代表数据库中已经存在数据，取出fd_times
                fd_times = recs[0] + 1
        else:
            # 若data数据库中没有数据，fd_times从1开始
            fd_times = 1

        # 分两种情况处理，循环完结:fd_times>12:fd_times<=12
        # ------------------------------------------------------------------------------------------------------------------
        print "---------->", fd_count, fd_times
        if not write_base_data and fd_times <= fd_count and len(recs) > 0:
            pass
            # 如果防呆次数小于等于$fd_count次
            # do nothing
        else:
            # 此处loop_times须自增，因为1394次数据已经用完，要开始新一轮循环
            if len(recs) > 0 and fd_times > fd_count:
                loop_times += 1
            query_sql = ""
            if direct == 'horizontal':
                # 查询基础数据库hdi_hor_sym_fd_base,看是否已经存在循环所需数据
                query_sql = """
                select fd_times
                from hdi_hor_sym_fd_base
                where loop_times = '%s'
                  and panel_x = '%s'
                  and panel_y = '%s'
                  and margin_x = '%s'
                  and margin_y = '%s'
                order by fd_times desc""" % (loop_times, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm)
            else:
                # 查询基础数据库hdi_ver_sym_fd_base,看是否已经存在循环所需数据
                query_sql = """
                select fd_times
                from hdi_ver_sym_fd_base
                where loop_times = '%s'
                  and panel_x = '%s'
                  and panel_y = '%s'
                  and margin_x = '%s'
                  and margin_y = '%s'
                order by fd_times desc""" % (loop_times, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm)
            # 执行SQL操作
            recs = self.DB_M.SQL_EXECUTE(self.dbc_m, query_sql)

            if len(recs) == 0:
                # @recs列表为空时，代表当前loop_times的1394次循环数据还没有写入
                self.write_base(direct, panel_x=panel_x, panel_y=panel_y, sr_xmin_mm=sr_xmin_mm, sr_ymin_mm=sr_ymin_mm)

            if direct == 'horizontal':
                # 循环取出不与靶孔重叠的防呆位置,此处前一轮可能有闲置位置，也有可能闲置位置全都不合适，会重叠，
                # 所以开始新一轮循环，但是不会无限制循环，因为新一轮循环必定有一个合适的位置
                used_fd_data = []
                fd_times = self.get_opt_fd_times(direct, used_fd_data, panel_x=panel_x, SR_xmax=SR_xmax)
                print 'fd_times_' * 20
                print fd_times
            else:
                # 垂直方向直接开始新一轮循环
                fd_times = 1

        # 从基础数据库中取出当前fd_times的其它数据
        query_base = ""
        if direct == 'horizontal':
            query_base = """
            select loop_times, other_fd_dis, right_fd_dis, pin_fd_dis
            from hdi_hor_sym_fd_base
            where fd_times = '%s'
              and loop_times = '%s'
              and panel_x = '%s'
              and panel_y = '%s'
              and margin_x = '%s'
              and margin_y = '%s'""" % (fd_times, loop_times, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm)
        else:
            query_base = """
            select loop_times, other_fd_dis, right_fd_dis
            from hdi_ver_sym_fd_base
            where fd_times = '%s'
              and loop_times = '%s'
              and panel_x = '%s'
              and panel_y = '%s'
              and margin_x = '%s'
              and margin_y = '%s'""" % (fd_times, loop_times, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm)

        query_result = self.DB_M.SQL_EXECUTE(self.dbc_m, query_base)
        print 'x' * 40
        print json.dumps(query_result)
        print 'c' * 40
        loop_times = query_result[0][0]
        other_fd_dis = query_result[0][1]
        right_fd_dis = query_result[0][2]
        if direct == 'horizontal':
            pin_fd_dis = query_result[0][3]
            # 插入数据库
            self.insert_data_horizontal(fd_times, loop_times, fd_width, other_fd_dis, right_fd_dis, pin_fd_dis,
                                        panel_x=panel_x, panel_y=panel_y, sr_xmin_mm=sr_xmin_mm, sr_ymin_mm=sr_ymin_mm)
            return fd_times, loop_times, other_fd_dis, right_fd_dis, pin_fd_dis

        else:
            # 插入数据库
            self.insert_data_vertical(fd_times, loop_times, fd_width, other_fd_dis, right_fd_dis, panel_x=panel_x,
                                      panel_y=panel_y, sr_xmin_mm=sr_xmin_mm, sr_ymin_mm=sr_ymin_mm)
            return fd_times, loop_times, other_fd_dis, right_fd_dis        

    def get_opt_fd_times(self, direct, used_fd_data, panel_x=0, SR_xmax=0):
        """
        防呆位置要避开现有的symbol位置(目前主要是四靶)
        循环处置当前loop_times中空闲的防呆位置
        :param direct:
        :param used_fd_data: 传入的参数是一个数组引用
        :return:
        """
        fd_array = []
        fd_count = []

        # 根据传入的参数（横向或者纵向）设置相应的数据
        if direct == 'horizontal':
            # @fd_array = (-6..0,2..6);
            # $fd_count = 12;
            fd_array = range(-6, 1) + range(2, 7)
            fd_count = 12
        else:
            # @fd_array = (-6..0,2);
            fd_array = range(-6, 1) + [2]
            fd_count = 8
        fd_times = range(1, fd_count + 1)

        # 已知全部的防呆数据和已经使用的防呆数据，求出尚未使用的防呆数据
        idle_array = []
        idle_times = []
        return_value = 0
        for i, fd_data in enumerate(fd_array):
            fd_time = fd_times[i]
            if fd_data not in used_fd_data:
                idle_array.append(fd_data)
                idle_times.append(fd_time)
                if not return_value:
                    return_value = i + 1

        # print 'return_value_' * 10
        # print return_value
        # 方法二：利用hash特性求差集,缺点是数组是无序的
        # my %tmp;
        # @tmp{@fd_array}=();
        # delete @tmp{@used_array};
        # @idle_array = keys %tmp;

        # 右上角外层防呆symbol需与四靶错开,获取四靶坐标，李家兴20200327增加
        # === ccd 改为动态添加，不在此处考虑靶孔 V1.10修改
        # TODO === 左下角pin_donut 需与4靶X错开
        # outer_bar4x1 = self.outer_BAR4X1
        # if outer_bar4x1:
        #     hdi_tag_sx2 = panel_x * 0.5 - outer_bar4x1 * 0.5
        #     hdi_tag_sx3 = hdi_tag_sx2 + outer_bar4x1
        #     orig_xmaxfd = SR_xmax - 43.64 - 6 - 3
        #     out_ccd_xmaxfd = 0
        #     for i, fd_data in enumerate (idle_array):
        #         fd_time = idle_times[i]
        #         # print fd_time
        #         # print idle_array
        #         out_ccd_xmaxfd = orig_xmaxfd + fd_data * 3
        #         if out_ccd_xmaxfd > hdi_tag_sx3:
        #             if out_ccd_xmaxfd - hdi_tag_sx3 > 4.3:
        #                 # 当与四靶坐标相差小4.3mm时，symbol之间可以完全错开，返回当前防呆数据
        #                 return fd_time
        #         else:
        #             if hdi_tag_sx3 - out_ccd_xmaxfd > 12.9:
        #                 # 当与四靶坐标相差小12.9mm时，symbol之间可以完全错开(包括防焊对位sym)，返回当前防呆数据
        #                 return fd_time
        # V2.01 2022.01.03 当无中间防呆数据时，使用最大值返回
        if return_value == 0:
            return fd_count + 1
        # 此分支主要应对Inplan系统数据库中没有压合数据时，返回@idle_array的第一个索引，即前面循环中取出的$return_value
        # 可参考料号 ha7708pn016a1
        return return_value

    def insert_data_horizontal(self, fd_times, loop_times, fd_width, other_fd_dis, right_fd_dis, pin_fd_dis, panel_x=0,
                               panel_y=0, sr_xmin_mm=0, sr_ymin_mm=0):
        # 向水平防呆数据库插入数据
        print  """('%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s') """ % (
            fd_times, loop_times, fd_width, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm, other_fd_dis, right_fd_dis,
            pin_fd_dis, self.JOB.lower(), self.date_time)
        insert_sql = """
        insert into hdi_hor_sym_fd_data (fd_times,
                                 loop_times,
                                 fd_width,
                                 panel_x,
                                 panel_y,
                                 margin_x,
                                 margin_y,
                                 other_fd_dis,
                                 right_fd_dis,
                                 pin_fd_dis,
                                 jobname,
                                 create_date)
        VALUES ('%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s')
        """ % (fd_times, loop_times, fd_width, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm, other_fd_dis, right_fd_dis,
               pin_fd_dis, self.JOB.lower(), self.date_time)
        query_result = self.DB_M.SQL_EXECUTE(self.dbc_m, insert_sql)

    def insert_data_vertical(self, fd_times, loop_times, fd_width, other_fd_dis, right_fd_dis, panel_x=0, panel_y=0,
                             sr_xmin_mm=0, sr_ymin_mm=0):
        # 向垂直防呆数据库插入数据
        insert_sql = """
        insert into hdi_ver_sym_fd_data (fd_times,
                                 loop_times,
                                 fd_width,
                                 panel_x,
                                 panel_y,
                                 margin_x,
                                 margin_y,
                                 other_fd_dis,
                                 right_fd_dis,
                                 jobname,
                                 create_date)
        VALUES ('%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s',
                '%s')
        """ % (fd_times, loop_times, fd_width, panel_x, panel_y, sr_xmin_mm, sr_ymin_mm, other_fd_dis, right_fd_dis,
               self.JOB.lower(), self.date_time)
        query_result = self.DB_M.SQL_EXECUTE(self.dbc_m, insert_sql)
        
    def getLaminData(self, jobname):
        """
        获取压合信息
        从mysql数据库获取 压合靶距信息 20230511 by lyh
        :return:
        """
        #sql = """
        #SELECT
            #a.item_name AS job_name,
            #d.mrp_name AS mrpName,
            #e.process_num_ AS process_num,
            #b.pnl_size_x / 1000 AS pnlXInch,
            #b.pnl_size_Y / 1000 AS pnlYInch,
            #e.pressed_pnl_x_ / 1000 AS pnlroutx,
            #e.pressed_pnl_y_ / 1000 AS pnlrouty,
            #round( e.target_x1_ / 39.37, 4 ) bar4x1,
            #round( e.target_y1_ / 39.37, 4 ) bar4y1,
            #round( e.target_x2_ / 39.37, 4 ) bar4x2,
            #round( e.target_y2_ / 39.37, 4 ) bar4y2,
            #round( e.target_backup_x_ / 39.37, 4 ) bar3x,
            #round( e.target_backup_y_ / 39.37, 4 ) bar3y,
            #(case when  e.film_bg_ not like '%%,%%' then 
                        #'L'|| TO_CHAR(TO_NUMBER(substr(REGEXP_SUBSTR( d.mrp_name, '[^-]+', 1,2 ),2,2), '99')) else 
                        #REGEXP_SUBSTR( e.film_bg_, '[^,]+', 1, 1 ) end) fromLay,	
            #(case when  e.film_bg_ not like '%%,%%' then 
            #'L'|| TO_CHAR(TO_NUMBER(substr(REGEXP_SUBSTR( d.mrp_name, '[^-]+', 1,2 ),4,2), '99')) else 
            #REGEXP_SUBSTR( e.film_bg_, '[^,]+', 1, 2 ) end) toLay,
            #ROUND( e.PRESSED_THICKNESS_ / 39.37, 2 ) AS yhThick,
            #ROUND( e.PRESSED_THICKNESS_TOL_PLUS_ / 39.37, 2 ) AS yhThkPlus,
            #ROUND( e.PRESSED_THICKNESS_TOL_MINUS_ / 39.37, 2 ) AS yhThkDown,
            #e.LASER_BURN_TARGET_ V5laser,
            #round( e.OUTER_TARGET_Y1_ / 39.37, 4 ) sig4y1,
            #round( e.OUTER_TARGET_Y2_ / 39.37, 4 ) sig4y2,
            #round( e.OUTER_TARGET_X1_ / 39.37, 4 ) sig4x1,
            #round( e.OUTER_TARGET_X2_ / 39.37, 4 ) sig4x2  
        #FROM
            #vgt_hdi.items a
            #INNER JOIN vgt_hdi.job b ON a.item_id = b.item_id 
            #AND a.last_checked_in_rev = b.revision_id
            #INNER JOIN vgt_hdi.public_items c ON a.root_id = c.root_id
            #INNER JOIN vgt_hdi.process d ON c.item_id = d.item_id 
            #AND c.revision_id = d.revision_id
            #INNER JOIN vgt_hdi.process_da e ON d.item_id = e.item_id 
            #AND d.revision_id = e.revision_id 
        #WHERE
            #a.item_name = '%s'
            #AND d.proc_type = 1 
            #AND d.proc_subtype IN ( 28, 29 ) 
        #ORDER BY
            #e.process_num_""" % self.JOB_SQL

        sql = """select JOB_NAME,MRPNAME,PROCESS_NUM,
        PNLXINCH,PNLYINCH,PNLROUTX,PNLROUTY,
        BAR4X1,BAR4Y1,BAR4X2,BAR4Y2,BAR3X,
        BAR3Y,FROMLAY,TOLAY,YHTHICK,YHTHKPLUS,
        YHTHKDOWN,V5LASER,SIG4Y1,SIG4Y2,SIG4X1,SIG4X2,TARGET_DESIGNREGION
        from hdi_engineering.incam_process_info_temp where job_name = '{0}'"""
        process_data = self.DB_M.SELECT_DIC(self.dbc_m, sql.format(jobname))

        return process_data
    
    def getInplanBKbar(self, jobname, user_dir=None):
        """
        获取inplan的背钻信息
        :return:
        """
        bkbar_data = defaultdict(dict)
        #sql = """
        #SELECT
            #a.job_name,
            #a.MRP_NAME,
            #b.program_name as ODB_DRILL_NAME,
            #b.DRILL_LAYER_,
            #decode( b.drill_technology, 0, 'Mechanical', 1, 'Controll Depth', 5, 'Countersink', 6, 'Counterbore', 7, 'Backdrill' ) AS 钻带类型,
            #round( a.PROCESS_LEVEL_ - 1 ) AS 压合次数,
            #b.start_index AS 起始层,
            #b.end_index AS 结束层,
            #round( b.TARGET_X1_ / 39.37, 4 ) AS TARGET_X1,
            #round( b.TARGET_Y1_ / 39.37, 4 ) AS TARGET_Y1,
            #round( b.TARGET_X2_ / 39.37, 4 ) AS TARGET_X2,
            #round( b.TARGET_Y2_ / 39.37, 4 ) AS TARGET_Y2 
        #FROM
            #vgt_hdi.RPT_JOB_PROCESS_LIST a,
            #vgt_hdi.RPT_DRILL_PROGRAM_LIST b 
        #WHERE
            #a.root_id = b.root_id 
            #AND a.MRP_NAME = b.PARENT_PROCESS_ 
            #AND b.drill_technology IN ( 1, 5, 6, 7 ) 
            #AND a.job_name = '%s'
            #""" % self.JOB_SQL
        #query_result = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        sql = """select JOB_NAME,
        MRP_NAME,
        ODB_DRILL_NAME,
        DRILL_LAYER_,
        DRILL_TYPE,
        PROCESS_LEVEL,
        start_index,
        end_index,
        TARGET_X1,
        TARGET_Y1,
        TARGET_X2,
        TARGET_Y2,
        ID
        from hdi_engineering.incam_drillprogram_info_temp where job_name = '{0}'"""
        query_result = self.DB_M.SELECT_DIC(self.dbc_m, sql.format(jobname))
        
        #储存此值到user夹子下 以备后续上传使用20240222 by lyh
        if user_dir:            
            target_info_file = os.path.join(user_dir, 'drill_bk_target_info.json')
            with open(target_info_file, 'w') as file_obj:
                json.dump(query_result, file_obj)                 
        
        diff_arraylist_target_xy = []
        for info_dict in query_result:
            if info_dict['TARGET_X1'] == 0 and info_dict['TARGET_Y1'] == 0 and info_dict['TARGET_X2'] == 0 and info_dict['TARGET_Y2'] == 0:
                # === 2023.02.15 背钻层靶距均为0认为不需要跑出靶孔 job:SD1012GH078B1
                continue
    
            cur_start_lay = info_dict['start_index']
            X1 = info_dict['TARGET_X1']
            Y1 = info_dict['TARGET_Y1']
            X2 = info_dict['TARGET_X2']
            Y2 = info_dict['TARGET_Y2']
            if cur_start_lay in bkbar_data:                
                bkbar_data[cur_start_lay]['end_nums'].append(info_dict['end_index'])
                bkbar_data[cur_start_lay]['drill_type'].append(info_dict['DRILL_TYPE'])
                bkbar_data[cur_start_lay]['mysql_id'].append(str(info_dict['ID']))
                if (X1, Y1, X2, Y2) not in diff_arraylist_target_xy:
                    bkbar_data[cur_start_lay]['drl_names'].append(info_dict['ODB_DRILL_NAME'])
                    bkbar_data[cur_start_lay]['TARGET_X1'].append(info_dict['TARGET_X1'])
                    bkbar_data[cur_start_lay]['TARGET_Y1'].append(info_dict['TARGET_Y1'])
                    bkbar_data[cur_start_lay]['TARGET_X2'].append(info_dict['TARGET_X2'])
                    bkbar_data[cur_start_lay]['TARGET_Y2'].append(info_dict['TARGET_Y2'])
                    
            else:
                bkbar_data[cur_start_lay] = dict(drl_names=[info_dict['ODB_DRILL_NAME']],
                                                 start_num=info_dict['start_index'],
                                                 end_nums=[info_dict['end_index']],
                                                 drill_type=[info_dict['DRILL_TYPE']],
                                                 TARGET_X1=[info_dict['TARGET_X1']],
                                                 TARGET_Y1=[info_dict['TARGET_Y1']],
                                                 TARGET_X2=[info_dict['TARGET_X2']],
                                                 TARGET_Y2=[info_dict['TARGET_Y2']],
                                                 cur_yh_num=info_dict['PROCESS_LEVEL'],
                                                 mrp_name=info_dict['MRP_NAME'],
                                                 erp_drill_name=info_dict['DRILL_LAYER_'],
                                                 mysql_id=[str(info_dict['ID'])]
                                                 )                
                diff_arraylist_target_xy.append((X1, Y1, X2, Y2))
                
        bkbar_array = [bkbar_data[i] for i in bkbar_data]
        return bkbar_array


# --所有与InPlan查询相关的全部写到InPlan类中
class InPlan(PUBLIC):
    def __init__(self, job_name):
        PUBLIC.__init__(self, job_name)

        # --Oracle相关参数定义
        self.DB_O = Oracle_DB.ORACLE_INIT()
        self.dbc_h = self.DB_O.DB_CONNECT(host='172.20.218.193', servername='inmind.fls', port='1521',
                                          username='GETDATA', passwd='InplanAdmin')
        # self.lamination,self.lam_rout = self.get_lamination_info()
        if not self.dbc_h:
            msg_box = msgBox()
            msg_box.critical(self, '错误', 'InPlan无法连接，程序退出', QMessageBox.Ok)
            sys.exit()

    def __del__(self):
        # --关闭数据库连接
        if self.dbc_h:
            self.DB_O.DB_CLOSE(self.dbc_h)

    def get_Job_Data(self):
        """
        :return: job_data
        """
        sql = """
        SELECT
            a.item_name 料号名,
            d.customer_name 客户名,
            c.customer_job_name_ 客户品名,
            h.value 工厂,
            i.value 订单类型,
            j.value 出货方式,
            round( c.delivery_width_ / 39.37, 3 ) 出货尺寸宽,
            round( c.delivery_length_ / 39.37, 3 ) 出货尺寸长,
            round( f.customer_thickness / 39.37, 3 ) 成品板厚,
            k.value 表面处理,
            l.value 阻焊次数,
            m.value 阻焊面别,
            (
            SELECT
                enu.value 
            FROM
                vgt_hdi.items sm
                INNER JOIN vgt_hdi.mask_layer sm2 ON sm.item_id = sm2.item_id 
                AND sm.last_checked_in_rev = sm2.revision_id
                INNER JOIN vgt_hdi.mask_layer_da sm3 ON sm2.item_id = sm3.item_id 
                AND sm2.revision_id = sm3.revision_id
                INNER JOIN vgt_hdi.enum_values enu ON sm3.sm_color_ = enu.enum 
            WHERE
                sm.root_id = a.root_id 
                AND sm2.mask_type = 0 
                AND enu.enum_type = 214 
                AND enu.value IS NOT NULL 
                AND ROWNUM = 1 
            ) 阻焊颜色,
            n.value 字符次数,
            o.value 字符面别,
            (
            SELECT
                enu.value 
            FROM
                vgt_hdi.items ss
                INNER JOIN vgt_hdi.mask_layer ss2 ON ss.item_id = ss2.item_id 
                AND ss.last_checked_in_rev = ss2.revision_id
                INNER JOIN vgt_hdi.mask_layer_da ss3 ON ss2.item_id = ss3.item_id 
                AND ss2.revision_id = ss3.revision_id
                INNER JOIN vgt_hdi.enum_values enu ON ss3.ss_color_ = enu.enum 
            WHERE
                ss.root_id = a.root_id 
                AND ss2.mask_type = 2 
                AND enu.enum_type = 1025 
                AND enu.value IS NOT NULL 
                AND ROWNUM = 1 
            ) 字符颜色,
            decode( c.has_qr_code_, 0, '无', 1, '有' ) 是否有雷雕,
            round( g.pcb_size_x / 39.37, 3 ) PCS_X,
            round( g.pcb_size_y / 39.37, 3 ) PSC_Y,
            round( c.set_size_x_ / 39.37, 3 ) SET_X,
            round( c.set_size_y_ / 39.37, 3 ) SET_Y,
            b.num_arrays PNL中的SET数,
            c.pcs_per_set_ SET中的PCS数,
            p.value 周期面别,
            q.value 周期格式,
            r.value 成型方式,
            s.value UL面别,
            (CASE WHEN c.UL_FINAL_ IS NULL
                THEN t.VALUE              
                ELSE c.UL_FINAL_
                END) UL标记,
            c.es_elic_ 是否ELIC,
            decode( c.sm_plug_type_, 0, 'no', 1, 'no', 2, 'yes', 3, 'yes' ) 是否阻焊塞,
            (
            SELECT
                decode( proda.resin_plug_type_, 0, 'no', 1, 'no', 2, 'yes' ) 
            FROM
                vgt_hdi.public_items pb
                INNER JOIN vgt_hdi.process pro ON pb.item_id = pro.item_id 
                AND pb.revision_id = pro.revision_id
                INNER JOIN vgt_hdi.process_da proda ON pro.item_id = proda.item_id 
                AND pro.revision_id = proda.revision_id 
            WHERE
                pb.root_id = a.root_id 
                AND pro.proc_subtype = 29 
            ) 是否树脂塞,
            c.PNL_CUT_DIRECTION_X_ X经纬,
		    c.PNL_CUT_DIRECTION_Y_ Y经纬,
		    c.IS_VCUT_ 是否Vcut,
		    c.ES_OVERALL_VCUT_ 大板Vcut,
                    c.ES_ELIC_ 是否任意互连ELIC
        FROM
            vgt_hdi.items a
            INNER JOIN vgt_hdi.job b ON a.item_id = b.item_id 
            AND a.last_checked_in_rev = b.revision_id
            INNER JOIN vgt_hdi.job_da c ON b.item_id = c.item_id 
            AND b.revision_id = c.revision_id
            INNER JOIN vgt_hdi.customer d ON b.customer_id = d.cust_id
            INNER JOIN vgt_hdi.items e ON a.root_id = e.root_id
            INNER JOIN vgt_hdi.stackup f ON e.item_id = f.item_id 
            AND e.last_checked_in_rev = f.revision_id
            INNER JOIN vgt_hdi.part g ON b.item_id = g.item_id 
            AND b.revision_id = g.revision_id
            INNER JOIN vgt_hdi.enum_values h ON c.site_ = h.enum
            INNER JOIN vgt_hdi.enum_values i ON c.order_type_ = i.enum
            INNER JOIN vgt_hdi.enum_values j ON c.delivery_unit_ = j.enum
            INNER JOIN vgt_hdi.enum_values k ON c.surface_finish_ = k.enum
            INNER JOIN vgt_hdi.enum_values l ON c.sm_print_times_ = l.enum
            INNER JOIN vgt_hdi.enum_values m ON c.sm_side_ = m.enum
            INNER JOIN vgt_hdi.enum_values n ON c.ss_print_times_ = n.enum
            INNER JOIN vgt_hdi.enum_values o ON c.ss_side_ = o.enum
            INNER JOIN vgt_hdi.enum_values p ON c.dc_side_ = p.enum
            INNER JOIN vgt_hdi.enum_values q ON c.dc_type_ = q.enum
            INNER JOIN vgt_hdi.enum_values r ON c.rout_process_ = r.enum
            INNER JOIN vgt_hdi.enum_values s ON c.ul_side_ = s.enum
            INNER JOIN vgt_hdi.enum_values t ON c.ul_mark_ = t.enum 
        WHERE
            a.item_name = '%s'
            AND h.enum_type = 1057 
            AND i.enum_type = 1007 
            AND j.enum_type = 1029 
            AND k.enum_type = 1000 
            AND l.enum_type = 1114 
            AND m.enum_type = 1015 
            AND n.enum_type = 1113 
            AND o.enum_type = 1038 
            AND p.enum_type = 1022 
            AND q.enum_type = 1001 
            AND r.enum_type = 1045 
            AND s.enum_type = 1020 
            AND t.enum_type = 1019
        """ % self.JOB_SQL
        job_data = self.DB_O.SELECT_DIC(self.dbc_h, sql)[0]
        return job_data

    def GetInpalFlow(self):
        """
        得到inplan全部工站
        :return:
        """
        sql = """
        SELECT
            S_DESCRIPTION 
        FROM
            vgt_hdi.RPT_JOB_TRAV_SECT_LIST t 
        WHERE
            t.job_name = '%s' """ % self.JOB_SQL
        query_result = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        result_arr=[]
        for q in query_result:
            result_arr.append(q["S_DESCRIPTION"])


        return result_arr


    def getAllProcessInfo(self):
        """
        从InPlan中获取数据：所有压合processinfo信息，与getLaminData及getStackupData有相同之处
        :return:
        """

        sql = """
        SELECT
            a.item_name 料号,
            c.item_name 部件类型,
            e.film_bg_	曝光底片,
            e.process_num_	压合级别,
            d.MRP_NAME 子部件名,
            e.PRESS_PROGRAM_ 压合板类型,
            e.FILM_PF_ 辅助菲林,
            e.Plating_Type_ 蚀刻类型,
            -- 1代表一次铜，2代表二次铜 0代表NONE
            e.df_width_ / 1000 干膜尺寸,
            -- 树脂塞孔 0,'Unknown',1,'不塞孔',2,'树脂塞孔'
            decode( e.resin_plug_type_, 0, 'Unknown', 1, 'no', 2, 'yes' ) 树脂塞孔 
        FROM
            -- vgt_hdi.items a
            -- INNER JOIN vgt_hdi.job b ON a.item_id = b.item_id 
            -- AND a.last_checked_in_rev = b.revision_id
            -- INNER JOIN vgt_hdi.items c ON a.root_id = c.root_id
            -- INNER JOIN vgt_hdi.process d ON c.item_id = d.item_id 
            -- AND c.last_checked_in_rev = d.revision_id
            -- INNER JOIN vgt_hdi.process_da e ON d.item_id = e.item_id 
            -- AND d.revision_id = e.revision_id --where d.proc_type=1 and a.item_name = 'H00006RD035A1'
            vgt_hdi.items a
            INNER JOIN vgt_hdi.job b ON a.item_id = b.item_id 
            AND a.last_checked_in_rev = b.revision_id 
            INNER JOIN vgt_hdi.public_items c ON a.root_id = c.root_id
            INNER JOIN vgt_hdi.process d ON c.item_id = d.item_id 
            AND c.revision_id = d.revision_id
            INNER JOIN vgt_hdi.process_da e ON d.item_id = e.item_id 
            AND d.revision_id = e.revision_id 
        WHERE
            d.proc_type = 1 
            AND a.item_name = '%s' 
        ORDER BY
            e.process_num_ DESC
        """ % self.JOB_SQL
        process_data = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        return process_data

    def getLaminData(self):
        """
        获取压合信息
        2021.12.16 增加线路四靶X数据
        :return:
        """
        sql = """
        SELECT
            a.item_name AS job_name,
            d.mrp_name AS mrpName,
            e.process_num_ AS process_num,
            b.pnl_size_x / 1000 AS pnlXInch,
            b.pnl_size_Y / 1000 AS pnlYInch,
            e.pressed_pnl_x_ / 1000 AS pnlroutx,
            e.pressed_pnl_y_ / 1000 AS pnlrouty,
            round( e.target_x1_ / 39.37, 4 ) bar4x1,
            round( e.target_y1_ / 39.37, 4 ) bar4y1,
            round( e.target_x2_ / 39.37, 4 ) bar4x2,
            round( e.target_y2_ / 39.37, 4 ) bar4y2,
            round( e.target_backup_x_ / 39.37, 4 ) bar3x,
            round( e.target_backup_y_ / 39.37, 4 ) bar3y,
            (case when  e.film_bg_ not like '%%,%%' then 
			'L'|| TO_CHAR(TO_NUMBER(substr(REGEXP_SUBSTR( d.mrp_name, '[^-]+', 1,2 ),2,2), '99')) else 
			REGEXP_SUBSTR( e.film_bg_, '[^,]+', 1, 1 ) end) fromLay,	
            (case when  e.film_bg_ not like '%%,%%' then 
            'L'|| TO_CHAR(TO_NUMBER(substr(REGEXP_SUBSTR( d.mrp_name, '[^-]+', 1,2 ),4,2), '99')) else 
            REGEXP_SUBSTR( e.film_bg_, '[^,]+', 1, 2 ) end) toLay,
            ROUND( e.PRESSED_THICKNESS_ / 39.37, 2 ) AS yhThick,
            ROUND( e.PRESSED_THICKNESS_TOL_PLUS_ / 39.37, 2 ) AS yhThkPlus,
            ROUND( e.PRESSED_THICKNESS_TOL_MINUS_ / 39.37, 2 ) AS yhThkDown,
            e.LASER_BURN_TARGET_ V5laser,
            round( e.OUTER_TARGET_Y1_ / 39.37, 4 ) sig4y1,
            round( e.OUTER_TARGET_Y2_ / 39.37, 4 ) sig4y2,
            round( e.OUTER_TARGET_X1_ / 39.37, 4 ) sig4x1,
            round( e.OUTER_TARGET_X2_ / 39.37, 4 ) sig4x2  
        FROM
            vgt_hdi.items a
            INNER JOIN vgt_hdi.job b ON a.item_id = b.item_id 
            AND a.last_checked_in_rev = b.revision_id
            INNER JOIN vgt_hdi.public_items c ON a.root_id = c.root_id
            INNER JOIN vgt_hdi.process d ON c.item_id = d.item_id 
            AND c.revision_id = d.revision_id
            INNER JOIN vgt_hdi.process_da e ON d.item_id = e.item_id 
            AND d.revision_id = e.revision_id 
        WHERE
            a.item_name = '%s'
            AND d.proc_type = 1 
            AND d.proc_subtype IN ( 28, 29 ) 
        ORDER BY
            e.process_num_""" % self.JOB_SQL
        process_data = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        return process_data

    def get_Layer_Info(self):
        """
        樊课提供新sql 20240722 -ynh
        """
        sql = """
         select JOB_NAME
             ,LOWER(LAYER_NAME) AS LAYER_NAME
             ,LAYER_POSITION
             ,LAYER_INDEX
            ,LAYER_ORIENTATION
            ,round(required_cu_weight / 28.3495, 2)  AS CU_WEIGHT
            ,finish_cu_thk_ AS FINISH_THICKNESS
            ,cal_cu_thk_ AS cal_cu_thk
        from vgt_hdi.rpt_copper_layer_list
        where job_name ='%s'
        ORDER BY
            LAYER_INDEX """ % self.JOB_SQL

        process_data = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        return process_data

    # def get_Layer_Info(self):
    #     sql = """
    #     SELECT
    #         a.item_name AS JOB_NAME,
    #         LOWER(c.item_name) AS LAYER_NAME,
    #         d.layer_position,
    #         d.layer_index,
    #         d.LAYER_ORIENTATION,
    #         round( d.required_cu_weight / 28.3495, 2 )  AS CU_WEIGHT,
    #         e.finish_cu_thk_ AS FINISH_THICKNESS,
    #         e.cal_cu_thk_ AS cal_cu_thk
    #         --e.LW_ORG_ 原稿线宽,
    #         --e.LS_ORG_ 原稿线距,
    #         --e.LW_FINISH_ 成品线宽,
    #         --e.ls_finish_ 成品线距
    #     FROM
    #         vgt_hdi.items a,
    #         vgt_hdi.job b,
    #         vgt_hdi.items c,
    #         vgt_hdi.copper_layer d,
    #         vgt_hdi.copper_layer_da e
    #     WHERE
    #         a.item_id = b.item_id
    #         AND a.last_checked_in_rev = b.revision_id
    #         AND a.root_id = c.root_id
    #         AND c.item_id = d.item_id
    #         AND c.last_checked_in_rev = d.revision_id
    #         AND d.item_id = e.item_id
    #         AND d.revision_id = e.revision_id
    #         AND a.item_name = '%s'
    #     ORDER BY
    #         d.layer_index""" % self.JOB_SQL
    #     process_data = self.DB_O.SELECT_DIC(self.dbc_h, sql)
    #     return process_data
    
    def get_stackup_pp_foil_info(self):
        sql = """select j.proc_mrp_name,j.segment_type_t,
	j.pressed_thickness,j.cust_req_thickness_,
        j.stackup_seg_index
	from VGT_HDI.rpt_job_process_stk_seg_list j 
	where j.job_name = upper('{0}')
	and j.proc_mrp_name is not null
	and j.pressed_thickness is not null
	order by stackup_seg_index"""
        stackup_data = self.DB_O.SELECT_DIC(self.dbc_h, sql.format(self.JOB_SQL))
        return stackup_data        

    def get_StackupData(self):
        sql = """
        SELECT
            a.item_name AS JOB_NAME,
            c.item_name AS PRESS_NAME,
            e.film_bg_,
            e.process_num_,
            d.MRP_NAME,
            e.PRESS_PROGRAM_,
            e.FILM_PF_,
            e.Plating_Type_,
        -- 1代表一次铜，2代表二次铜 0代表NONE
            e.df_width_ / 1000 AS DF_WIDTH,
        -- 树脂塞孔 0,'Unknown',1,'不塞孔',2,'树脂塞孔'
            e.resin_plug_type_ 
        FROM
            vgt_hdi.items a
            INNER JOIN vgt_hdi.job b ON a.item_id = b.item_id 
            AND a.last_checked_in_rev = b.revision_id 
            INNER JOIN vgt_hdi.public_items c ON a.root_id = c.root_id
            INNER JOIN vgt_hdi.process d ON c.item_id = d.item_id 
            
            AND c.revision_id = d.revision_id
            INNER JOIN vgt_hdi.process_da e ON d.item_id = e.item_id 
            AND d.revision_id = e.revision_id 
        WHERE
            d.proc_type = 1 
            AND a.item_name = '%s' 
            AND	c.item_name NOT LIKE '%%光板%%'
        ORDER BY
            e.process_num_ DESC""" % self.JOB_SQL
        process_data = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        # pprint (process_data)
        stack_data = {}
        for i in range(len(process_data)):
            cur_lamin_num = int(process_data[i]['PROCESS_NUM_']) - 1
            cur_gm_size_inch = process_data[i]['DF_WIDTH']
            top_bot_lay = process_data[i]['FILM_BG_'].lower().split(',')
            stackProcess = process_data[i]['PRESS_NAME'].split('-')
            get_two_layer = stackProcess[1]
            get_two_layer = re.sub(r"^(\s+)|(\s+)$", "", get_two_layer)
            twice_top_bot_lay = get_two_layer.split('/')
            layerMode = ''
            materialType = ''

            if stackProcess[0] == "Final Assembly ":
                layerMode = 'out'
                materialType = 'cu'
            elif stackProcess[0] == "Sub Assembly ":
                layerMode = 'sec'
                materialType = 'cu'
            elif stackProcess[0] == "Inner Layers Core ":
                layerMode = 'inn'
                materialType = 'core'
            elif stackProcess[0] == "Buried Via ":
                layerMode = 'sec'
                materialType = 'core'
            elif stackProcess[0] == "Blind Via ":
                layerMode = 'sec'
                materialType = 'core'

            # 2020.05.11 如果有core+core结构，则@top_bot_lay就不会有两个值
            # S55806GI139A3	Final Assembly - 1/6	L1,L6
            # S55806GI139A3	Inner Layers Core - 3/4	L3,L4
            # S55806GI139A3	Inner Layers Core - 5/6	L5
            # S55806GI139A3	Inner Layers Core - 1/2	L2
            # 增加判断条件，@top_bot_lay的内的个数不为2

            if len(top_bot_lay) != 2:
                get_top_lay = 'l' + twice_top_bot_lay[0]
                get_bot_lay = 'l' + twice_top_bot_lay[1]
                if top_bot_lay[0] == get_top_lay:
                    stack_data[top_bot_lay[0]] = dict(layerSide='top', layerMode=layerMode, materialType=materialType,
                                                      lamin_num=cur_lamin_num, gm_inch=cur_gm_size_inch)
                elif top_bot_lay[0] == get_bot_lay:
                    stack_data[top_bot_lay[0]] = dict(layerSide='bot', layerMode=layerMode, materialType=materialType,
                                                      lamin_num=cur_lamin_num, gm_inch=cur_gm_size_inch)
            else:
                stack_data[top_bot_lay[0].split("-")[0]] = dict(layerSide='top', layerMode=layerMode, materialType=materialType,
                                                  lamin_num=cur_lamin_num, gm_inch=cur_gm_size_inch)
                stack_data[top_bot_lay[1].split("-")[0]] = dict(layerSide='bot', layerMode=layerMode, materialType=materialType,
                                                  lamin_num=cur_lamin_num, gm_inch=cur_gm_size_inch)
        # pprint (stack_data)
        return stack_data

    def judge_led_board(self):
        """
        判断是否为LED板
        :return:
        """
        sql = """
        SELECT
                i.ITEM_NAME AS JobName,
                job.es_led_board_,
                JOB.JOB_PRODUCT_LEVEL3_
        FROM
                VGT_hdi.PUBLIC_ITEMS i,
                VGT_hdi.JOB_DA job
        WHERE
                i.ITEM_NAME = '%s'
                AND i.item_id = job.item_id
                AND i.revision_id = job.revision_id""" % self.JOB_SQL
        process_data = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        if len(process_data) > 0:
            if process_data[0]['ES_LED_BOARD_'] == 1 :                 
                return True
            #elif "LED" in str(process_data[0]['JOB_PRODUCT_LEVEL3_']).upper():
                #if process_data[0]['JOB_PRODUCT_LEVEL3_'] not in ('LED照明(如应急、工业、矿山等）','LED-连接板', 'LED COB封装'):
                    #return True
                #return False
            else:
                return False
        else:
            return False

    def get_Cu_thickness(self, ozKey='None', func='getIndex'):
        """
        获取铜厚信息
        :param ozKey:传入的从Inplan获取的铜厚信息（保留了两位小数）
        :param func:默认功能为获取铜厚信息
        :return:根据条件返回
        """
        index = -1
        ozDes = 'None'
        ozList = ['1/3OZ', 'HOZ', '1OZ', '1.5OZ', '2OZ', '2.5OZ', '3OZ', '3.5OZ', '4OZ', '4.5OZ', '5OZ']
        ozDic = {
            '0.32': '1/3OZ', '0.33': '1/3OZ', '0.34': '1/3OZ',
            '0.49': 'HOZ', '0.50': 'HOZ', '0.51': 'HOZ',
            '0.99': '1OZ', '1.00': '1OZ', '1.01': '1OZ',
            '1.49': '1.5OZ', '1.50': '1.5OZ', '1.51': '1.5OZ',
            '1.99': '2OZ', '2.00': '2OZ', '2.01': '2OZ',
            '2.49': '2.5OZ', '2.50': '2.5OZ', '2.51': '2.5OZ',
            '2.99': '3OZ', '3.00': '3OZ', '3.01': '3OZ',
            '3.49': '3.5OZ', '3.50': '3.5OZ', '3.51': '3.5OZ',
            '3.99': '4OZ', '4.00': '4OZ', '4.01': '4OZ',
            '4.49': '4.5OZ', '4.50': '4.5OZ', '4.51': '4.5OZ',
            '4.99': '5OZ', '5.00': '5OZ', '5.01': '5OZ'
        }
        if func == 'getIndex':
            ozDes = ozDic.get(ozKey, 'None')
            if ozDes in ozList:
                index = ozList.index(ozDes)
            # --返回获取的index（有可能为默认值：-1）
            return index
        elif func == 'getList':
            # --增加一个空选项
            ozList.append('None')
            # --返回列表
            return ozList
        elif func == 'getDes':
            ozDes = ozDic.get(ozKey, 'None')
            # --返回获取的铜厚对应的说明（有可能为默认值：None）
            return ozDes

    def combine_LAYER_INFO(self, source_array1, source_dict1):
        """
        source_array1 用的self.sqlDict source_dict1 用的stackup
        :param source_array1:
        :param source_dict1:
        :return:
        """
        dest_array = []
        for i in source_array1:
            if i['LAYER_NAME'] in source_dict1:
                # === 合并dict ===
                tmpdict = dict(i, **source_dict1[i['LAYER_NAME']])
                dest_array.append(tmpdict)
            else:
                tmpdict = i
                dest_array.append(tmpdict)

        return dest_array

    def get_start_end(self):
        """
        获取所有钻孔的起始和结束层
        d.drill_technology IN ( 0, 1, 5, 6, 7 )
        :return:
        :rtype:
        """
        DataHash = defaultdict(dict)
        sql = """
         SELECT
            a.item_name AS 料号名,
            c.item_name AS 钻带名,
            decode(
            d.drill_technology,
            0,
            'Mechanical',
            1,
            'Controll Depth',
            2,
            'Laser',
            5,
            'Countersink',
            6,
            'Counterbore',
            7,
            'Backdrill' 
            ) AS 钻带类型,
    -- 		decode( e.DRILL_PROGRAM_QUADRANT_, 0, 'Unknown', 1, '第一象限', 2, '第四象限' ) AS 钻带象限,
            d.start_index AS 起始层,
            d.end_index AS 结束层 
    FROM
            VGT_HDI.items a INNER join VGT_HDI.job b ON a.item_id = b.item_id 
            AND a.last_checked_in_rev = b.revision_id INNER join VGT_HDI.public_items c ON a.root_id = c.root_id INNER join VGT_HDI.drill_program d ON c.item_id = d.item_id 
            AND c.revision_id = d.revision_id INNER join VGT_HDI.drill_program_da e ON d.item_id = e.item_id 
            AND d.revision_id = e.revision_id 
    WHERE
            d.drill_technology IN ( 0, 2 ) 
             AND a.item_name = '%s'
    ORDER BY
            c.item_name
        """ % self.JOB_SQL
        query_result = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        for info_dict in query_result:
            drl_name = info_dict['钻带名']
            drl_type = info_dict['钻带类型']
            # drl_quad = info_dict['钻带象限']
            drl_start = info_dict['起始层']
            drl_end = info_dict['结束层']
            drl_dict = {
                'drl_type': drl_type,
                # 'drl_quad' : drl_quad,
                'drl_start': drl_start,
                'drl_end': drl_end,
            }
            DataHash[drl_name] = drl_dict
        return DataHash

    def get_InPlan_stackup(self):
        """
        获取层别列表及三张PP的数据
        :return:
        """
        # job_del = '%-del'
        sql = """
            SELECT
                a.job_name as 料号,
                a.PRINT_NUM_ as 工序,
                a.LAYER_NAME_ as 层别,
                decode( BOM_MAT_TYPE_, 1, 'TB', 2, 'JB', 3, 'PP' ) as 类型,
                A.MATERIAL_COUNT_ AS 张数
            FROM
                VGT_HDI.Rpt_Job_Bom_Component_List a
            WHERE
                a.job_name = '%s'
                AND a.BOM_MAT_TYPE_ IN ( 1, 2, 3 )
                AND a.COMPONENT_TYPE = 0
                AND A.MATERIAL_COUNT_ <> 0
            ORDER BY
                a.PRINT_NUM_
        """ % self.JOB_SQL
        query_result = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        layer_array = []
        layer_array_2pp = []
        layer_list = []
        JB_layer = []
        pp_sum = 0
        pre_layer = ''

        for row in query_result:
            layer = row['层别']
            type = row['类型']
            pp_cnt = row['张数']
            if type == 'TB' or type == 'JB':
                pre_lyrs = pre_layer.split('-')
                cur_lyrs = layer.lower().split('-')
                # 夹三张以上pp的层别放入数组
                if pp_sum >= 3:
                    # 铜箔前累加pp张数大于等于3张时，将夹三张pp的两张TB或JB层加入数组
                    layer_array = layer_array + pre_lyrs + cur_lyrs
                if pp_sum >= 2:
                    # 铜箔前累加pp张数大于等于2张时，将夹2张pp的两张TB或JB层加入数组
                    for layer in pre_lyrs + cur_lyrs:
                        if layer not in layer_array_2pp:
                            layer_array_2pp.append(layer)
                            
                layer_list = layer_list + pre_lyrs + cur_lyrs
                # 出现铜箔或者基板后，将pp_sum_next张数归零
                pp_sum = 0
                # 出现铜箔或者基板后，将pre_layer重置为当前铜箔或基板层
                pre_layer = layer.lower()
                # --如果Type是基板，而且当前层有两层
                if type == 'JB' and len(cur_lyrs) >= 2:
                    for layer_name in cur_lyrs:
                        # --获取基板层别列表
                        if layer_name not in JB_layer:
                            JB_layer.append(layer_name)
            if type == 'PP':
                # 累加pp张数
                pp_sum += pp_cnt

        # 去除重复数据,并保持层别排序
        sort_array = []
        for i, layer in enumerate(layer_array):
            if layer not in sort_array:
                # if layer != "l1" and layer != "l" + str (int (self.JOB[4:6])):
                sort_array.append(layer)
        # 去除重复数据,并保持层别排序
        sort_list = []
        for i, layer in enumerate(layer_list):
            if layer not in sort_list:
                sort_list.append(layer)
        info_dict = {
            'all_layer': sort_list,
            '3pp_layer': sort_array,
            '2pp_layer': layer_array_2pp,
            'JB_layer': JB_layer
        }
        return info_dict

    def getInplanBKbar(self):
        """
        获取inplan的背钻信息
        :return:
        """
        bkbar_data = defaultdict(dict)
        sql = """
        SELECT
            a.job_name,
            a.MRP_NAME,
            b.program_name as ODB_DRILL_NAME,
            b.DRILL_LAYER_,
            decode( b.drill_technology, 0, 'Mechanical', 1, 'Controll Depth', 5, 'Countersink', 6, 'Counterbore', 7, 'Backdrill' ) AS 钻带类型,
            round( a.PROCESS_LEVEL_ - 1 ) AS 压合次数,
            b.start_index AS 起始层,
            b.end_index AS 结束层,
            round( b.TARGET_X1_ / 39.37, 4 ) AS TARGET_X1,
            round( b.TARGET_Y1_ / 39.37, 4 ) AS TARGET_Y1,
            round( b.TARGET_X2_ / 39.37, 4 ) AS TARGET_X2,
            round( b.TARGET_Y2_ / 39.37, 4 ) AS TARGET_Y2 
        FROM
            vgt_hdi.RPT_JOB_PROCESS_LIST a,
            vgt_hdi.RPT_DRILL_PROGRAM_LIST b 
        WHERE
            a.root_id = b.root_id 
            AND a.MRP_NAME = b.PARENT_PROCESS_ 
            AND b.drill_technology IN ( 1, 5, 6, 7 ) 
            AND a.job_name = '%s'
            """ % self.JOB_SQL
        query_result = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        
        diff_arraylist_target_xy = []
        for info_dict in query_result:
            if info_dict['TARGET_X1'] == 0 and info_dict['TARGET_Y1'] == 0 and info_dict['TARGET_X2'] == 0 and info_dict['TARGET_Y2'] == 0:
                # === 2023.02.15 背钻层靶距均为0认为不需要跑出靶孔 job:SD1012GH078B1
                continue

            cur_start_lay = info_dict['起始层']
            X1 = info_dict['TARGET_X1']
            Y1 = info_dict['TARGET_Y1']
            X2 = info_dict['TARGET_X2']
            Y2 = info_dict['TARGET_Y2']
            if cur_start_lay in bkbar_data:                
                bkbar_data[cur_start_lay]['end_nums'].append(info_dict['结束层'])
                bkbar_data[cur_start_lay]['drill_type'].append(info_dict['钻带类型'])                
                if (X1, Y1, X2, Y2) not in diff_arraylist_target_xy:
                    bkbar_data[cur_start_lay]['drl_names'].append(info_dict['ODB_DRILL_NAME'])
                    bkbar_data[cur_start_lay]['TARGET_X1'].append(info_dict['TARGET_X1'])
                    bkbar_data[cur_start_lay]['TARGET_Y1'].append(info_dict['TARGET_Y1'])
                    bkbar_data[cur_start_lay]['TARGET_X2'].append(info_dict['TARGET_X2'])
                    bkbar_data[cur_start_lay]['TARGET_Y2'].append(info_dict['TARGET_Y2'])
                    
            else:
                bkbar_data[cur_start_lay] = dict(drl_names=[info_dict['ODB_DRILL_NAME']],
                                                 start_num=info_dict['起始层'],
                                                 end_nums=[info_dict['结束层']],
                                                 drill_type=[info_dict['钻带类型']],
                                                 TARGET_X1=[info_dict['TARGET_X1']],
                                                 TARGET_Y1=[info_dict['TARGET_Y1']],
                                                 TARGET_X2=[info_dict['TARGET_X2']],
                                                 TARGET_Y2=[info_dict['TARGET_Y2']],
                                                 cur_yh_num=info_dict['压合次数'],
                                                 mrp_name=info_dict['MRP_NAME'],
                                                 erp_drill_name=info_dict['DRILL_LAYER_']
                                                 )                
                diff_arraylist_target_xy.append((X1, Y1, X2, Y2))
                
        bkbar_array = [bkbar_data[i] for i in bkbar_data]
        return bkbar_array

    def get_inplan_drill_info(self):
        """
        获取inplan的钻孔信息，包含钻带名(与ERP相同的钻带名），T刀序，孔属性，孔在ERP上的备注
        :return:
        """
        sql = """
        SELECT
            item_for_job.item_name,
            dp_da.DRILL_LAYER_,
        CASE 
            when drill_hole_da.bit_name_ is not null THEN drill_hole_da.bit_name_ else drill_hole.name END name,
            TYPE_ENUM.value TYPE,
            drill_hole.length,
        CASE
            WHEN TYPE_ENUM.value LIKE '%%N%%' THEN
                'N' ELSE 'Y' 
            END PLATING_TYPE,
            drill_hole.ACTUAL_DRILL_SIZE,
            DRILL_TYPE_enum.value DRILL_TYPE_, 
            drill_hole_da.ERP_FINISH_size_ 
        FROM
            VGT_HDI.all_items all_items,
            VGT_HDI.items item_for_job,
            VGT_HDI.items item_for_dp,
            VGT_HDI.DRILL_HOLE drill_hole,
            VGT_HDI.DRILL_HOLE_DA drill_hole_da,
            VGT_HDI.drill_program_da dp_da,
            VGT_HDI.field_enum_translate DRILL_TYPE_ENUM,
            VGT_HDI.field_enum_translate TYPE_ENUM 
        WHERE
            item_for_job.item_name = '%s'
            AND all_items.item_type = 5 
            AND all_items.root_id = item_for_job.root_id 
            AND item_for_job.item_type = 2 
            AND item_for_dp.item_type = 5 
            AND item_for_dp.root_id = item_for_job.root_id 
            AND dp_da.item_id = item_for_dp.item_id 
            AND dp_da.revision_id = all_items.revision_id 
            AND drill_hole.item_id = all_items.item_id 
            AND drill_hole.revision_id = all_items.revision_id 
            AND drill_hole_da.item_id = all_items.item_id 
            AND drill_hole_da.revision_id = all_items.revision_id 
            AND drill_hole.sequential_index = drill_hole_da.sequential_index 
            AND DRILL_TYPE_ENUM.intname = 'DRILL_HOLE' 
            AND DRILL_TYPE_ENUM.fldname = 'DRILL_TYPE_' 
            AND DRILL_TYPE_ENUM.enum = drill_hole_da.DRILL_TYPE_ 
            AND TYPE_ENUM.intname = 'DRILL_HOLE' 
            AND TYPE_ENUM.fldname = 'TYPE' 
            AND TYPE_ENUM.enum = drill_hole.TYPE
            """ % self.JOB_SQL
        query_result = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        return query_result

    def get_inplan_wz_times(self):
        sql = """
            SELECT
                ( b.op_index_ * 10 + a.traveler_ordering_index ) num,
                a.operation_code,
                a.description,
                a.work_center_code,
                c.DESCRIPTION process_description,
                c.VALUE_AS_STRING 
            FROM
                VGT_HDI.rpt_job_trav_sect_list a
                INNER JOIN VGT_HDI.rpt_trav_sect_info b ON a.job_name = '%s'
                and a.work_center_code in ('文字','文字（二）','文字（三）') and  a.description in ('文字喷印','文字印刷')
                AND b.item_id = a.item_id 
                AND b.revision_id = a.revision_id 
                AND a.traveler_ordering_index = b.traveler_ordering_index 
                AND b.mrp_step_item_id = a.mrp_step_item_id 
                AND b.mrp_step_revision_id = a.mrp_step_revision_id LEFT OUTER
                JOIN VGT_HDI.rpt_attr_trav_sect_info c ON c.item_id = a.item_id 
                AND c.revision_id = a.revision_id 
                AND a.traveler_ordering_index = c.section_sequential_index 
            ORDER BY
                num""" % self.JOB_SQL
        query_result = self.DB_O.SELECT_DIC (self.dbc_h, sql)
        # print query_result
        wz_dict = {}
        first_silk_process = None
        twice_silk_process = None
        third_silk_process = None
        silk_layers = []
        for i in query_result:
            work_center_code = i['WORK_CENTER_CODE']
            description = i['DESCRIPTION']
            
            if i["PROCESS_DESCRIPTION"] is not None and "使用曝光资料" in i["PROCESS_DESCRIPTION"]:
                if i["VALUE_AS_STRING"] is not None:                    
                    silk_layers.append(i["VALUE_AS_STRING"])
                
            if work_center_code == '文字（二）':
                if twice_silk_process:
                    if description != twice_silk_process:
                        return False
                else:
                    twice_silk_process = description
            elif work_center_code == '文字（三）':
                if third_silk_process:
                    if description != third_silk_process:
                        return False
                else:
                    third_silk_process = description
            elif work_center_code == '文字':
                if first_silk_process:
                    if description != first_silk_process:
                        return False
                else:
                    first_silk_process = description
        # === 排除仅有"文字"-->"后烤" 但无喷印网印的情况 eg.C67604EI026C2
        if len(query_result) > 0 and first_silk_process is None:
            first_silk_process = twice_silk_process
            twice_silk_process = None
            if third_silk_process is not None and twice_silk_process is None:
                twice_silk_process = third_silk_process
                third_silk_process = None
        return first_silk_process, twice_silk_process, third_silk_process, silk_layers

    def extract_inplan_drill_layers(self, all_drill_dict):
        """
        提取inplan 钻孔层是否包含PTH孔
        :param all_drill_dict:
        :return:
        """
        drill_layers = []
        each_drill_dict = {}
        drill_pth_yn_list = []
        for line in all_drill_dict:
            if line['DRILL_LAYER_'] not in drill_layers:
                drill_layers.append(line['DRILL_LAYER_'])
                each_drill_dict[line['DRILL_LAYER_']] = [line['PLATING_TYPE']]
            else:
                each_drill_dict[line['DRILL_LAYER_']].append(line['PLATING_TYPE'])

        for drill_layer in each_drill_dict.keys():
            if 'Y' in each_drill_dict[drill_layer]:
                value = 'Y'
            else:
                value = 'N'
            drill_pth_yn_list.append((drill_layer, value))

        return drill_layers, drill_pth_yn_list

    def get_split_drills(self, all_drill_dict):
        """
        取切片孔大小
        :param all_drill_dict:
        :return:
        """
        split_drills = []
        for line in all_drill_dict:
            if line['DRILL_LAYER_'] == '一次钻孔' and line['ERP_FINISH_SIZE_'] == '切片孔':
                drill_size = str(float(line["ACTUAL_DRILL_SIZE"]) * 0.0254)
                split_drills.append(float(line['ACTUAL_DRILL_SIZE']) * 0.0254)

        # --返回数据字典
        holeList = list(set(split_drills))
        holeList.sort()
        split_via, split_pth = 'Null', 'Null'
        split_pin = 3.175
        if len(holeList) == 3:
            split_via, split_pth, split_pin = holeList
        elif len(holeList) == 2:
            split_via, split_pin = holeList
            if split_pin == 3.175:
                split_pth = split_via
            else:
                split_pth = split_pin
        elif len(holeList) == 1:
            # --如果查询结果只有一行，代表可能只有via孔或只有pth孔
            hole_size = holeList[0]
            split_pth = hole_size
            split_via = hole_size
        return split_via, split_pth
    
    def get_bd_hole_condition(self, all_drill_dict):        
        """
        获取背钻孔是否有3.175的定位孔 20221123 V2.14
        """
        for line in all_drill_dict:
            if "背钻" in line['DRILL_LAYER_']: # and line['ERP_FINISH_SIZE_'] == '定位孔':
                drill_size = float(line["ACTUAL_DRILL_SIZE"]) * 0.0254
                if drill_size == 3.175:
                    return True
                
        return False
    
    def check_xianwei_hole_condition(self, all_drill_dict):
        """
        检测限位孔和料号孔是否为同一把刀
        http://192.168.2.120:82/zentao/story-view-5187.html
        """
        #20230324 by lyh 工艺取消合刀
        return "NO"
    
        xianwei_t = None
        jobname_t = None
        for line in all_drill_dict:
            if "限位孔" in line['ERP_FINISH_SIZE_'] or "料号孔" in line['ERP_FINISH_SIZE_']:
                drill_size = float(line["ACTUAL_DRILL_SIZE"]) * 0.0254
                if drill_size - 450 < 0.1:
                    if "限位孔" in line['ERP_FINISH_SIZE_']:                        
                        xianwei_t = line["NAME"]
                    else:
                        jobname_t = line["NAME"]
        
        if xianwei_t and jobname_t:
            if xianwei_t == jobname_t:
                return "YES"
                
        return "NO"
    
    def get_laser_config(self):
        """
        取镭射层镭射参数及镭射介质厚度
        :return:
        """
        sql = """
    SELECT
        a.item_name,
        e.item_name as INPLAN_LAYER_NAME,
        d.laser_drl_parameter_ as LASER_PARM,
        c.start_index as START_INDEX,
        c.end_index AS END_INDEX,
        ROUND( c.DRILL_DEPTH, 2 ) - 0.2 AS DRILL_DEPTH 
    FROM
        vgt_hdi.Items A,
        VGT_HDI.JOB b,
        VGT_HDI.DRILL_PROGRAM c,
        vgt_hdi.drill_program_da d,
        vgt_hdi.public_items e 
    WHERE
        a.item_id = b.item_id 
        AND a.last_checked_in_rev = b.revision_id 
        AND a.root_id = e.root_id 
        AND e.item_id = c.item_id 
        AND e.revision_id = c.revision_id 
        AND c.item_id = d.item_id 
        AND c.revision_id = d.revision_id 
        and a.item_name = '%s'
        AND c.drill_technology = 2""" % self.JOB_SQL

        query_result = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        laser_data = []
        for info_dict in query_result:
            cur_layer_name = 's%s-%s' % (info_dict['START_INDEX'], info_dict['END_INDEX'])
            laser_data.append(dict(layer_name=cur_layer_name,
                                   laser_parm=info_dict['LASER_PARM'],
                                   laser_depth_mil=info_dict['DRILL_DEPTH']))
        return laser_data

    def get_board_split(self):
        """
        从InPlan数据中获取该料号的分割次数
        :return:'6分割|4分割|2分割|Unknown|无需分割'
        """
        sql = """
        SELECT
            i.ITEM_NAME AS JobName,
            p.value
        FROM
            VGT_hdi.PUBLIC_ITEMS i,
            VGT_hdi.JOB_DA job,
                VGT_HDI.field_enum_translate p   
        where  
            i.ITEM_NAME = '%s'
            AND i.item_id = job.item_id
            AND i.revision_id = job.revision_id
                and p.fldname = 'PNL_PARCELLATION_METHOD_'
                and p.enum=job.PNL_PARCELLATION_METHOD_
                and p.intname = 'JOB'""" % self.JOB_SQL
        query_result = self.DB_O.SELECT_DIC(self.dbc_h, sql)
        get_result = query_result[0]['VALUE']
        return get_result

    def get_inplan_all_flow(self):
        """
        从inplan获取当前料号的所有流程
        :return:
        """
        # -- Gary 2022.01.20 钉钉提供，流程且带工具名 空为(Null)
        #sql = """SELECT
            #( b.op_index_ * 10 + a.traveler_ordering_index ) num,
            #a.operation_code,
            #a.description,
            #a.work_center_code,
            #c.DESCRIPTION,
            #c.VALUE_AS_STRING,
            #nts.note_string
            #FROM
            #VGT_HDI.rpt_job_trav_sect_list a
            #left JOIN VGT_HDI.note_trav_sect nts
            #ON a.item_id = nts.item_id
            #and a.revision_id = nts.revision_id
            #and a.sequential_index = nts.section_sequential_index
            #INNER JOIN VGT_HDI.rpt_trav_sect_info b ON a.job_name = UPPER('%s')
            #AND b.item_id = a.item_id 
            #AND b.revision_id = a.revision_id 
            #AND a.traveler_ordering_index = b.traveler_ordering_index 
            #AND b.mrp_step_item_id = a.mrp_step_item_id 
            #AND b.mrp_step_revision_id = a.mrp_step_revision_id LEFT OUTER
            #JOIN VGT_HDI.rpt_attr_trav_sect_info c ON c.item_id = a.item_id 
            #AND c.revision_id = a.revision_id 
            #AND a.traveler_ordering_index = c.section_sequential_index 
            #ORDER BY
            #num
            #""" % self.JOB_SQL
        sql = u"""
        SELECT 
        RJTSL.JOB_NAME,
        RJTSL.DESCRIPTION as RJT_DESCRIPTION,
        RJTSL.ORDER_NUM,
        RJTSL.TRAVELER_ORDERING_INDEX,
        RJTSL.work_center_code,
        ats.description,
        ats.value_as_string,
        nts.note_string,
        RJTSL.SITE_NAME                            
        FROM VGT_HDI.RPT_JOB_TRAV_SECT_LIST RJTSL
        left JOIN VGT_HDI.note_trav_sect nts
        ON RJTSL.item_id = nts.item_id
        and RJTSL.revision_id = nts.revision_id
        and RJTSL.sequential_index = nts.section_sequential_index
        left JOIN VGT_HDI.attr_trav_sect ats
        ON RJTSL.item_id = ats.item_id
        and RJTSL.revision_id = ats.revision_id
        and RJTSL.sequential_index = ats.section_sequential_index
        WHERE RJTSL.JOB_NAME = UPPER('{0}')
        ORDER BY RJTSL.ORDER_NUM, RJTSL.TRAVELER_ORDERING_INDEX
        """
        query_result = self.DB_O.SELECT_DIC(self.dbc_h, sql.format(self.JOB_SQL))
        return query_result


class UI_info(object):
    # --描述符类，主要用来从UI界面取值或者向UI界面设置值
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        """
        通过描述符获取值
        :param instance:描述符实例
        :type instance:
        :param cls:描述符托管类
        :type cls:
        :return:
        :rtype:
        """
        # print "描述符获取类变量"
        if instance is None:
            # --如果是通过类名来调用，直接返回描述符本身
            return self
        else:
            # --如果是通过实例调用
            obj = instance.findChild(QWidget, self.name)
            # print "描述符实例字典中没有值，直接从界面取值"
            if isinstance(obj, QtGui.QComboBox):
                curText = obj.currentText().toUtf8()
                return str(curText)
            elif isinstance(obj, QtGui.QCheckBox):
                return obj.isChecked()
            elif isinstance(obj, QtGui.QRadioButton):
                return obj.isChecked()
            else:
                curText = obj.text().toUtf8()
                try:
                    if isinstance(curText, bool):
                        # --bool值也可以float,False=0.0,True=1.0,所以不能直接转float，避免造成误解
                        curText = bool(curText)
                    else:
                        # --如果LineEdit中的是float,直接返回float,省去后面转换的麻烦
                        curText = float(curText)
                    return curText
                except ValueError:
                    return str(curText)

    def __set__(self, instance, value):
        """
        通过描述符设值
        :param instance:描述符实例
        :type instance:
        :param value:值
        :type value:
        :return:
        :rtype:
        """
        # print "描述符设置类变量"
        obj = instance.findChild(QWidget, self.name)
        if isinstance(obj, QtGui.QComboBox):
            AllItems = [obj.itemText(i) for i in range(obj.count())]
            index = AllItems.index(value)
            obj.setCurrentIndex(index)
        elif isinstance(obj, QtGui.QCheckBox):
            obj.setChecked(value)
        elif isinstance(obj, QtGui.QRadioButton):
            obj.setChecked(value)
        else:
            if isinstance(value, float) or isinstance(value, int):
                # --如果是浮点数，要转成str,否则会报错
                value = str(value)
            obj.setText(value)


class MainWindow(QtGui.QWidget):
    # --定义描述符,从UI中获取对应的参数,按照UI界面从左到右，从上到下
    # --单只名称：
    array_step = UI_info('array_step')
    # --单只尺寸X：
    array_x_size = UI_info('array_x_size')
    # --拼板尺寸X：
    panel_x = UI_info('panel_x')
    # --锣边后尺寸X：
    rout_x = UI_info('rout_x')
    # --板厚：
    board_thick = UI_info('board_thick')
    # --单只尺寸Y：
    array_y_size = UI_info('array_y_size')
    # --拼板尺寸Y：
    panel_y = UI_info('panel_y')
    # --锣边后尺寸Y：
    rout_y = UI_info('rout_y')
    # --切片via：
    split_via = UI_info('split_via')
    # --切片PTH：
    split_pth = UI_info('split_pth')
    # --角检测孔：
    dry_hole = UI_info('dry_hole')
    # --拼板名称：
    panel_step = UI_info('panel')
    # --选择工厂
    sh_site = UI_info('sh_site')
    # --添加周期
    cycle_in_silk = UI_info('cycle_in_silk')
    cycle_in_sm = UI_info('cycle_in_sm')
    cycle_in_signal = UI_info('cycle_in_signal')
    # --是否金手指：
    sel_jsz_no = UI_info('sel_jsz_no')
    sel_jsz_yes = UI_info('sel_jsz_yes')
    # --是否化金板：
    add_hj_panel_no = UI_info('add_hj_panel_no')
    add_hj_panel_yes = UI_info('add_hj_panel_yes')
    # --手指选化：
    sel_finger_no = UI_info('sel_finger_no')
    sel_finger_yes = UI_info('sel_finger_yes')
    # --板内手指方向：
    g_direction = UI_info('g_direction')
    # --外层CCD：
    sel_out_ccd_no = UI_info('sel_out_ccd_no')
    sel_out_ccd_yes = UI_info('sel_out_ccd_yes')
    # --大板V-CUT：
    sel_vut_no = UI_info('sel_vut_no')
    sel_vut_yes = UI_info('sel_vut_yes')
    # --LED板：
    add_eagle_panel_no = UI_info('add_eagle_panel_no')
    add_eagle_panel_yes = UI_info('add_eagle_panel_yes')
    # --一厂化金保留铜皮：
    sel_mid_rout_short = UI_info('sel_mid_rout_short')
    sel_mid_rout_long = UI_info('sel_mid_rout_long')
    # --镭雕制程：
    add_ld_symbol_no = UI_info('add_ld_symbol_no')
    add_ld_symbol_yes = UI_info('add_ld_symbol_yes')
    # # --二次文字：
    # twice_wz_panel_no = UI_info ('twice_wz_panel_no')
    # twice_wz_panel_yes = UI_info ('twice_wz_panel_yes')
    # # --二次防焊：
    # twice_fh_panel_no = UI_info ('twice_fh_panel_no')
    # twice_fh_panel_yes = UI_info ('twice_fh_panel_yes')
    # --服务器板&RVC模块：
    select_server_no = UI_info('select_server_no')
    select_server_yes = UI_info('select_server_yes')
    # --机械钻ccd：
    select_ccd_no = UI_info('select_ccd_no')
    select_ccd_yes = UI_info('select_ccd_yes')
    # --socket运行：
    sel_socket_no = UI_info('sel_socket_no')
    sel_socket_yes = UI_info('sel_socket_yes')
    # --纬向：
    wei_xiang = UI_info('wei_xiang')
    # --文字颜色：
    select_color_silk = UI_info('select_color_silk')
    # ==文字次数：
    select_silk_times = UI_info('select_silk_times')
    # ==防焊次数：
    select_solder_times = UI_info('select_solder_times')
    # --铆钉x
    mao_pin_x = UI_info('mao_pin_x')
    # --铆钉y
    mao_pin_y = UI_info('mao_pin_y')
    # --选择PE3000进制0.5inch或者0.25inch
    ape3000_base = UI_info('ape3000_base')
    # --设置程序版本信息
    appVersion = UI_info('appVersion')
    # --设置一次铜二次铜流程
    flow_content = UI_info('flow_content')
    
    #--设置pin_lam模式
    pin_lam = UI_info('pin_lam_mode')

    def __init__(self, parent=None, debug=False):
        QtGui.QWidget.__init__(self, parent)
        self.JOB = os.environ.get('JOB', None)
        # print self.JOB,'xxxxxxxxxxxxxxxxxx'
        self.debug = debug
        # 接口定义
        if debug:
            # 通过genesis gateway命令连结pid进行会话,不用在genesis环境下运行，直接用gateway的方式，可在pycharm环境下直接debug
            self.GEN = Gateway()
            self.GEN.genesis_connect()
            # 方法genesis_connect通过查询log-genesis文件获取的料号名
            self.JOB = self.GEN.job_name
            self.pid = self.GEN.pid
        else:
            self.GEN = genCOM.GEN_COM()
            self.pid = os.getpid()
        self.STEP = os.environ.get('STEP', None)
        self.mysql_job = self.JOB.upper()
        self.cut_job = self.JOB.upper()[:13]  # --截取前十三位料号名
        try:
            calc_target = get_target_distance(self.JOB, self.STEP)
            res = calc_target.start_calc()
            if res:
                msg_box = msgBox()
                msg_box.critical(self, '警告', res, QMessageBox.Ok)
                sys.exit()                
        except Exception, e:
            msg_box = msgBox()
            msg_box.critical(self, '警告', "自动计算靶距异常，请反馈程序工程师处理：{0}".format(e), QMessageBox.Ok)
            sys.exit()
            
        # if not self.STEP:
        #     msg_box = msgBox()
        #     msg_box.critical(self, '警告', '请打开step再运行脚本！', QMessageBox.Ok)
        self.IKM = TOPCAM_IKM.IKM()

        # --定义料号user文件夹路径
        if platform.system() == "Windows":
            self.userDir = "%s/fw/jobs/%s/user" % (os.environ.get('GENESIS_DIR', 'D:/genesis'), self.JOB)
        else:
            self.userDir = os.environ.get('JOB_USER_DIR', None)
            if not PRODUCT and not self.userDir:
                # --Linux环境下网络版genesis没有定义INCAM_PRODUCT环境变量
                self.userDir = "%s/fw/jobs/%s/user" % (os.environ.get('GENESIS_DIR', '/genesis'), self.JOB)

        # --Oracle相关参数定义
        # self.DB_O = Oracle_DB.ORACLE_INIT ()
        # self.dbc_o = self.DB_O.DB_CONNECT (host='192.168.2.18', servername='inmind.fls', port='1521',
        #                                    username='GETDATA', passwd='InplanAdmin')
        # --定义QTableWidget窗口需要用到字典
        self.comBox = {}
        self.comBox_side = {}
        self.item_polarity = {}
        self.item_fillType = {}
        self.item_lamin_num = {}
        self.item_gmSize = {}
        self.hdi_contain_tag_layer = []
        # === 通孔与背钻孔合并，无通孔设计 ===
        self.drlcombine = '否'
        # --定义一个字典，收集所有变量，可以通过socket传递
        self.drl = 'drl'  # === TODO 后续仅存在cdc及cds时可用于替换 ===
        self.parm = dict()
        try:            
            self.layer_number = int(self.JOB[4:6])
        except Exception, e:
            self.layer_number = len(signalLayers)
        # --初始化窗口
        self.ui = FormUi.Ui_Form()
        self.ui.setupUi(self)
        self.InPlan = InPlan(self.JOB)
        self.ERP = ERP(self.JOB)

        self.layerDic = self.InPlan.get_Layer_Info()
        # === V2.09 增加，InPlan中料号不存在的预警 ===
        if not self.layerDic:
            msg_box = msgBox()
            msg_box.critical(self, '警告',  u'HDI InPlan无料号%s数据, 程序退出！' % self.JOB, QMessageBox.Ok)
            sys.exit()

        self.stackDic = self.InPlan.get_StackupData()
        self.sqlDic = self.InPlan.combine_LAYER_INFO(self.layerDic, self.stackDic)

        # === 压合次数信息 ===
        # self.lamin_data = self.InPlan.getLaminData()
        # 20230511 通过后台自动计算靶距的mysql数据来获取压合次数信息 by lyh
        lamin_data_Project = Project(self.JOB, None, database="hdi_engineering")
        self.lamin_data = lamin_data_Project.getLaminData(self.JOB.split("-")[0])
        
        self.PUBLIC = PUBLIC(self.JOB)
        chk_bar_dis = self.PUBLIC.chk_lamin_bar_dis(self.lamin_data)
        if not chk_bar_dis:
            self.ui.applyButton.setDisabled(True)
            self.ui.applyButton.setStyleSheet(_fromUtf8("background-color: rgb(41, 53, 73);"))
            self.ui.applyButton.setToolTip(_fromUtf8("跑板边按钮无法使用时，为检查项目未通过"))

        self.yh_num = max([int(i['PROCESS_NUM']) for i in self.lamin_data]) - 1
        # === 标靶防呆需要用到与四靶的距离判断问题，如果有相接需要避开标靶位置 ===
        outer_BAR4X1 = [int(i['BAR4X1']) for i in self.lamin_data if int(i['PROCESS_NUM']) == int(self.yh_num) + 1][0]
        self.Project = Project(self.JOB, outer_BAR4X1)
        self.addLamin_Ui()
        # --设定界面参数
        self.job_data = self.InPlan.get_Job_Data()
        self.allProcessInfo = self.InPlan.getAllProcessInfo()
        self.set_UI_by_SQL()
        # --删除drl、fa、lp、2nd等step,因为下面要取gSR_LIMITS
        self.GEN.OPEN_STEP('panel', job=self.JOB)
        self.sr_popup_del_step()
        # --从料号获取信息并设置界面参数
        self.set_UI_by_JOB()

        # --添加动态子部件 === 位置后移由于需使用panel_x panel_y
        self.addPart_Ui()

        # # --通过DO_INFO从料号中取值
        self.get_JOB_info()
        # # --定义信号和槽函数
        self.slot_func()
        self.ui.topLabel.setText(u'胜宏科技HDI Panel板边 @ %s' % self.JOB)
        # --暂时禁用ape3000
        self.ui.ape3000_base.setEnabled(False)
        self.testButton_clicked = False
        self.ui.panelizationButton.hide()
        # self.ui.testButton.hide ()
        self.ui.sel_socket_no.setEnabled(False)
        self.ui.sel_socket_yes.setEnabled(False)
        # === 隐藏socket模式 V1.06
        self.ui.sel_socket_no.hide()
        self.ui.sel_socket_yes.hide()
        self.ui.label_sel_socket.hide()
        # === 一厂化金保留铜皮  V1.06
        self.ui.label_sel_mid_rout.hide()
        self.ui.sel_mid_rout_short.hide()
        self.ui.sel_mid_rout_long.hide()
        
        # 因为现在更新不需要选择金手指方向，是按照开料尺寸 故隐藏此选项
        # 20230221 工艺要求恢复手指选择
        #self.ui.g_direction.hide()
        #self.ui.label_g_direction.hide()

        self.set_ui_enable(status=False)

        # self.ui.select_parm_box.setEnabled(False)

    def __del__(self):
        # --恢复config参数
        # self.reset_genesis_config(value=1)
        # --关闭gateway连接
        if self.debug:
            self.GEN.disconnect()

    def set_ui_enable(self, status=False):
        # === 拼版参数
        self.ui.array_parm_box.setEnabled(status)
        # === 纬向
        self.ui.wei_xiang.setEnabled(status)
        # === 镭雕
        self.ui.add_ld_symbol_no.setEnabled(status)
        self.ui.add_ld_symbol_yes.setEnabled(status)
        # === 大板Vcut
        self.ui.sel_vut_no.setEnabled(status)
        self.ui.sel_vut_yes.setEnabled(status)
        # === 文字颜色
        self.ui.select_color_silk.setEnabled(status)
        # === LED
        self.ui.add_eagle_panel_no.setEnabled(status)
        self.ui.add_eagle_panel_yes.setEnabled(status)
        # === 工厂 （关联一铜二铜）
        self.ui.sh_site.setEnabled(status)
        # === 添加周期
        self.ui.cycle_in_silk.setEnabled(status)
        self.ui.cycle_in_sm.setEnabled(status)
        self.ui.cycle_in_signal.setEnabled(status)

    def table_comboBox(self, obj, index, styleSheet, rowNum=None, colNum=None, choices=None):
        """
        在tableWidget中加入comboBox控件
        :return:
        :rtype:
        """
        # --控件选项列表
        obj.addItems(choices)
        obj.setCurrentIndex(index)
        obj.setStyleSheet(styleSheet)
        # --控件添加的位置
        self.ui.tableWidget.setCellWidget(rowNum, colNum, obj)

    def table_Item(self, obj, text, rowNum=None, colNum=None, foreColor='black', brush_bg=None):
        """
        在tableWidget中加入普通的item控件
        :param obj: 控件引用
        :param text: 控件上的文本
        :param rowNum: 传入需要放置的行号
        :param colNum: 传入需要放置的列号
        :param foreColor: 传入前景颜色
        :param brush_bg: 传入背景画刷
        :return:
        """
        # --设置tabWidgetItem控件不可编辑
        obj.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
        # --位置
        self.ui.tableWidget.setItem(rowNum, colNum, obj)
        # --设置文字居中
        obj.setTextAlignment(QtCore.Qt.AlignHCenter | QtCore.Qt.AlignVCenter | QtCore.Qt.AlignCenter)
        # --写入文本信息
        obj.setText(text)
        if brush_bg:
            # --如果传入的参数有指定背景刷，则设定背景
            obj.setBackground(brush_bg)
        # --根据传入的颜色设置样式（前景色）
        brush = QtGui.QBrush(QtGui.QColor(foreColor))
        brush.setStyle(QtCore.Qt.NoBrush)
        obj.setForeground(brush)

    def addPart_Ui(self):
        """
        在原框架基础上继续加载窗体
        :return:None
        """
        # --加载动态层列表
        sqlDic = self.sqlDic

        # --当从InPlan中未获取到参数时
        if len(sqlDic) == 0:
            botName = int(self.JOB[4:6]) + 1
            for lay_num in range(1, botName):
                sqlDic.append({'LAYER_NAME': 'l' + str(lay_num), 'FINISH_THICKNESS': 0, 'LAYER_INDEX': lay_num - 1,
                               'CU_WEIGHT': 0, 'LAYER_ORIENTATION': 1})
            msg_box = msgBox()
            msg_box.critical(self, '警告', 'Inplan数据库中没有料号:%s的铜厚正反数据，无法确定铺铜形态！' % self.JOB, QMessageBox.Ok)
            sys.exit()
        # pprint (sqlDic)

        # --获取comBox的下拉列表信息
        boxList = self.InPlan.get_Cu_thickness(func='getList')

        # --重新定义行
        self.ui.tableWidget.setRowCount(len(sqlDic))
        # --样式（背景色）
        brush_bg = QtGui.QBrush(QtGui.QColor(253, 199, 77))
        brush_bg.setStyle(QtCore.Qt.SolidPattern)

        # --循环所有层并加入行
        for rowDir in sqlDic:
            # --获取数组序号
            rowNum = sqlDic.index(rowDir)
            # --获取层名
            layName = rowDir['LAYER_NAME']
            layName = layName.lower()
            # --获取铜厚
            cuOz = ('%.2f' % rowDir['CU_WEIGHT'] * 1)
            oz_des = self.InPlan.get_Cu_thickness(ozKey=cuOz, func='getDes')
            # print (rowNum, cuOz)
            # --层别列：
            item = QtGui.QTableWidgetItem()
            self.table_Item(item, layName, rowNum=rowNum, colNum=0, brush_bg=brush_bg)
            # --铜厚列 ：循环对应铜厚
            self.copper_thick_UI(rowNum, cuOz, boxList)
            # --加载层别正反区
            self.side_UI(rowNum)
            # --加载极性区
            self.polarity_UI(rowNum)
            # --加载板边铺铜区
            self.fill_UI(oz_des, rowNum, foreColor='black')
            # === 加载归属压合级别
            self.layer_lamin_UI(rowNum)
            # === 干膜尺寸
            self.layer_gm_UI(rowNum)

    def deal_assist_layer(self, all_etch_layer):
        """
        通过process的字典和压合层别的字典确认压合的具体方式,获取辅助菲林层别，添加至所有蚀刻层
        :return:
        """
        assist_layer = []
        assist_side = []
        assist_ref = []

        for item in self.allProcessInfo:
            if item['辅助菲林']:
                assist_layer.append(item['辅助菲林'].lower())
                cur_assist_num = item['辅助菲林'].lower().strip('l').split("-")[0]
                cur_sig_layer = 'l' + cur_assist_num
                cur_assist_side = self.stackDic[cur_sig_layer]['layerSide']
                assist_side.append(cur_assist_side)
                eindex = all_etch_layer.index(cur_sig_layer)
                cur_material = [i['materialType'] for i in self.sqlDic if i['LAYER_NAME'] == cur_sig_layer][0]
                # === V2.00 判断辅助菲林是辅助core还是cu，core的话参考层向下两层，cu向下一层，反面同理 ===
                cal_value = 2
                if cur_material == 'cu':
                    cal_value = 1
                if cur_assist_side == 'top':
                    ref_num = int(cur_assist_num) + cal_value
                    all_etch_layer.insert(eindex + 1, item['辅助菲林'].lower())
                elif cur_assist_side == 'bot':
                    ref_num = int(cur_assist_num) - cal_value
                    all_etch_layer.insert(eindex, item['辅助菲林'].lower())
                else:
                    return False

                assist_ref.append('l' + str(ref_num))
        return assist_layer, assist_side, assist_ref, all_etch_layer

    def updateOtherData(self):
        """
        当改变铜厚列时，自动更新板边铺铜栏位信息
        :return:None
        """
        # --TODO 从获取信息的发送者获取对应的信息
        selText = str(self.sender().currentText())
        selObj = int(self.sender().objectName())

        print ("当前更改的内容为：%s 选择的对象序号：%s" % (selText, selObj))
        # --获取原始的铜厚
        org_cuOz = ('%.2f' % self.sqlDic[selObj]['CU_WEIGHT'] * 1)
        org_ozDes = self.InPlan.get_Cu_thickness(ozKey=org_cuOz, func='getDes')
        # --更新对应的补偿值
        if selText == org_ozDes:
            self.fill_UI(selText, selObj, foreColor='black')
        else:
            self.fill_UI(selText, selObj, foreColor='red')

    def copper_thick_UI(self, rowNum, cuOz, boxList):
        """
        tableWidget铜厚列
        :param rowNum:传入需要放置的行号
        :param rowNum:传入铜厚数据
        :param rowNum:传入铜厚列comboBox选项
        :return:
        :rtype:
        """
        boxIndex = self.InPlan.get_Cu_thickness(ozKey=cuOz)
        self.comBox[rowNum] = QComboBox(self)
        # --这个obj的名称为integer,在后续updateOtherData波函数会用到，不要随意更改
        self.comBox[rowNum].setObjectName("%s" % rowNum)
        # --当无法获取对应的铜厚信息时，默认最后一个列表
        if boxIndex == -1:
            boxIndex = len(boxList) - 1
            # --设置添加的控件的边界及前景色样式
            styleSheet = 'QComboBox{font:10pt;background-color: rgb(253, 199, 77);margin:3px;border: 1px solid gray;' \
                         'border-radius: 3px;padding: 1px 2px 1px 2px;color: red}'
        else:
            # --设置添加的控件的边界样式
            styleSheet = 'QComboBox{font:10pt;background-color: rgb(253, 199, 77);margin:3px;border: 1px solid gray;' \
                         'border-radius: 3px;padding: 1px 2px 1px 2px}'
        self.table_comboBox(self.comBox[rowNum], boxIndex, styleSheet, rowNum=rowNum, colNum=1, choices=boxList)
        # --控件的信号
        self.connect(self.comBox[rowNum], QtCore.SIGNAL("currentIndexChanged(int)"), self.updateOtherData)

    def side_UI(self, rowNum):
        """
        层别正反
        :param rowNum:传入需要放置的行号
        :return: None
        """
        sideList = [u'正', u'反']
        side = self.sqlDic[rowNum]['LAYER_ORIENTATION']
        if side == 1:
            side = u'正'
        else:
            side = u'反'
        sideIndex = sideList.index(side)
        self.comBox_side[rowNum] = QComboBox(self)
        styleSheet = 'QComboBox{font:10pt;background-color: rgb(253, 199, 77);margin:3px;border: 1px solid gray;' \
                     'border-radius: 3px;padding: 1px 2px 1px 2px}'
        self.table_comboBox(self.comBox_side[rowNum], sideIndex, styleSheet, rowNum=rowNum, colNum=2, choices=sideList)

    def polarity_UI(self, rowNum):
        """
        层别正反
        :param rowNum:传入需要放置的行号
        :return: None
        """
        # region TODO 层别极性列：
        self.item_polarity[rowNum] = QtGui.QTableWidgetItem()
        self.table_Item(self.item_polarity[rowNum], 'positive', rowNum=rowNum, colNum=3, foreColor='black')

    def fill_UI(self, oz_des, rowNum, foreColor='black'):
        """
        板边铺铜方式列
        :param oz_des:传入的铜厚
        :param rowNum:传入需要放置的行号
        :param forColor:传入显示的颜色（未作更改默认为黑色，有更新过为红色）
        :return: None
        """
        cusNo = self.JOB[1:4]
        if rowNum == 0 or rowNum == self.layer_number - 1 or self.layer_number == 0:
            fillType = u'铜皮'
        else:
            if oz_des in ['1/3OZ', 'HOZ', '1OZ', '1.5OZ']:
                fillType = u'梯形'
                # TODO 暂不上线 21.5x24.5 http://192.168.2.120:82/zentao/story-view-3360.html
                if float(self.panel_x) < 546.1 and float(self.panel_y) < 622.3:
                    fillType = u'蜂窝'
            else:
                if cusNo in ('940', '968'):
                    # --需求http://192.168.2.120:82/zentao/story-view-2418.html要求铺梯形铜
                    fillType = u'梯形'
                else:
                    fillType = u'蜂窝'
        self.item_fillType[rowNum] = QtGui.QTableWidgetItem()
        self.table_Item(self.item_fillType[rowNum], fillType, rowNum=rowNum, colNum=4, foreColor=foreColor)

    def slot_func(self):
        """
        集中定义信号和槽函数
        :return: None
        """
        # --定义执行按钮的信号、槽连接
        self.connect(self.ui.applyButton, QtCore.SIGNAL("clicked()"), self.clickApply)
        # === 取消排版，测试板边 ===
        # self.connect(self.ui.panelizationButton, QtCore.SIGNAL("clicked()"), self.array_panel)
        # self.connect(self.ui.testButton, QtCore.SIGNAL("clicked()"), self.test_panel)
        self.connect(self.ui.unlockUIButton, QtCore.SIGNAL("clicked()"), self.unlock_panel_ui)
        self.connect(self.ui.sel_finger_no, QtCore.SIGNAL("clicked()"), self.On_sel_finger_no)
        self.connect(self.ui.sel_finger_yes, QtCore.SIGNAL("clicked()"), self.On_sel_finger_yes)
        self.ui.sh_site.currentIndexChanged.connect(self.On_sh_site)
        # self.ui.ape3000_base.currentIndexChanged.connect(self.On_ape3000_base)
        # --安装事件过滤器，达到禁用QComboBox滚轮事件的目的
        self.ui.sh_site.installEventFilter(self)
        self.ui.g_direction.installEventFilter(self)
        self.ui.wei_xiang.installEventFilter(self)
        self.ui.select_color_silk.installEventFilter(self)
        self.ui.ape3000_base.installEventFilter(self)

    def eventFilter(self, watched, event):
        """
        事件过滤器
        :param watched:
        :type watched:
        :param event:
        :type event:
        :return:
        :rtype:
        """
        if watched == self.ui.sh_site:
            if event.type() == QEvent.Wheel:
                # --拦截事件，不再发送到原来的控件,返回True,继续返回原控件返回False
                return True
        if watched == self.ui.g_direction:
            if event.type() == QEvent.Wheel:
                # --拦截事件，不再发送到原来的控件,返回True,继续返回原控件返回False
                return True
        if watched == self.ui.wei_xiang:
            if event.type() == QEvent.Wheel:
                # --拦截事件，不再发送到原来的控件,返回True,继续返回原控件返回False
                return True
        if watched == self.ui.select_color_silk:
            if event.type() == QEvent.Wheel:
                # --拦截事件，不再发送到原来的控件,返回True,继续返回原控件返回False
                return True
        if watched == self.ui.ape3000_base:
            if event.type() == QEvent.Wheel:
                # --拦截事件，不再发送到原来的控件,返回True,继续返回原控件返回False
                return True
        # --基它未拦截事件仍然返回原控件
        return False

    def On_sel_finger_no(self):
        """
        手指选化选择no时
        :return:
        :rtype:
        """
        # --设置手指方向QComboBox不可选择
        self.ui.g_direction.setEnabled(False)
        # --隐藏手指方向QComboBox
        # self.ui.g_direction.setVisible(False)

    def On_sel_finger_yes(self):
        """
        手指选化选择no时
        :return:
        :rtype:
        """
        # --显示手指方向QComboBox
        # self.ui.g_direction.setVisible(True)
        # --设置手指方向QComboBox可以选择
        self.ui.g_direction.setEnabled(True)

    def On_sh_site(self):
        """
        选择厂别时触发此函数
        :return:
        :rtype:
        """
        if self.InPlan.get_flow_type() == '二次铜':
            self.flow_content = u'二次铜(正片)'
        else:
            self.flow_content = u'一次铜(负片)'

    def layer_lamin_UI(self, rowNum):
        """
        层别归属的压合级别
        :param rowNum:传入需要放置的行号
        :return: None
        """
        self.item_lamin_num[rowNum] = QtGui.QTableWidgetItem()
        self.table_Item(self.item_lamin_num[rowNum], str(self.sqlDic[rowNum]['lamin_num']), rowNum=rowNum, colNum=5,
                        foreColor='black')

    def layer_gm_UI(self, rowNum):
        """
        干膜尺寸显示
        :param rowNum:传入需要放置的行号
        :return: None
        """
        self.item_gmSize[rowNum] = QtGui.QTableWidgetItem()
        self.table_Item(self.item_gmSize[rowNum], str(self.sqlDic[rowNum]['gm_inch']), rowNum=rowNum, colNum=6,
                        foreColor='black')

    def tableLamin_Item(self, obj, text, rowNum=None, colNum=None, foreColor='black', brush_bg=None):
        """
        在tableWidget中加入普通的item控件
        :param obj: 控件引用
        :param text: 控件上的文本
        :param rowNum: 传入需要放置的行号
        :param colNum: 传入需要放置的列号
        :param foreColor: 传入前景颜色
        :param brush_bg: 传入背景画刷
        :return:
        """
        # --设置tabWidgetItem控件不可编辑
        obj.setFlags(QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled)
        # --位置
        self.ui.tableWidget_lamin.setItem(rowNum, colNum, obj)
        # --设置文字居中
        obj.setTextAlignment(QtCore.Qt.AlignHCenter | QtCore.Qt.AlignVCenter | QtCore.Qt.AlignCenter)
        # --写入文本信息
        obj.setText(text)
        if brush_bg:
            # --如果传入的参数有指定背景刷，则设定背景
            obj.setBackground(brush_bg)
        # --根据传入的颜色设置样式（前景色）
        brush = QtGui.QBrush(QtGui.QColor(foreColor))
        brush.setStyle(QtCore.Qt.NoBrush)
        obj.setForeground(brush)

    def addLamin_Ui(self):
        """
        在原框架基础上继续加载窗体
        :return:None
        """
        # --加载动态层列表
        lamin_data = self.lamin_data
        self.ui.lamin_parm_box.setTitle(u"压合次数：%s" % self.yh_num)
        # --当从InPlan中未获取到参数时
        if len(lamin_data) == 0:
            msg_box = msgBox()
            msg_box.critical(self, '警告', 'Inplan数据库中没有料号:%s的压合信息！' % self.JOB, QMessageBox.Ok)
            sys.exit()
        pprint(lamin_data)
        width_list = (60, 48, 48, 55, 55, 60, 56, 56, 56, 56, 56, 56, 56)
        for i in range(len(width_list)):
            self.ui.tableWidget_lamin.setColumnWidth(i, width_list[i])
        # --获取comBox的下拉列表信息
        boxList = self.InPlan.get_Cu_thickness(func='getList')

        # --重新定义行
        self.ui.tableWidget_lamin.setRowCount(len(lamin_data))
        # --样式（背景色）
        brush_bg = QtGui.QBrush(QtGui.QColor(137, 200, 255))
        brush_bg.setStyle(QtCore.Qt.SolidPattern)

        # --循环所有层并加入行
        for rowDir in lamin_data:
            # --获取数组序号
            rowNum = lamin_data.index(rowDir)
            # === 获取压合级别
            cur_lamin_num = str(int(rowDir['PROCESS_NUM']) - 1)
            # # --获取铜厚
            # cuOz = ('%.2f' % rowDir['CU_WEIGHT'] * 1)
            # oz_des = self.InPlan.get_Cu_thickness (ozKey=cuOz, func='getDes')
            # # print (rowNum, cuOz)
            # === 压合序号列：
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, cur_lamin_num, rowNum=rowNum, colNum=0, brush_bg=brush_bg, foreColor='white')
            # === 压合层别开始列 可能存在无起始层的情况
            if rowDir['FROMLAY']:
                item = QtGui.QTableWidgetItem()
                self.tableLamin_Item(item, rowDir['FROMLAY'].lower(), rowNum=rowNum, colNum=1)
            # === 压合层别结束列
            if rowDir['TOLAY']:
                item = QtGui.QTableWidgetItem()
                self.tableLamin_Item(item, rowDir['TOLAY'].lower(), rowNum=rowNum, colNum=2)
            # === 压合锣边尺寸X ===
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, '%.3f' % rowDir['PNLROUTX'], rowNum=rowNum, colNum=3)
            # === 压合锣边尺寸Y ===
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, '%.3f' % rowDir['PNLROUTY'], rowNum=rowNum, colNum=4)
            # === 烧靶 ===
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, str(rowDir['V5LASER']), rowNum=rowNum, colNum=5)
            # === 4靶坐标 ===
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, str(rowDir['BAR4X1']), rowNum=rowNum, colNum=6)
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, str(rowDir['BAR4X2']), rowNum=rowNum, colNum=7)
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, str(rowDir['BAR4Y1']), rowNum=rowNum, colNum=8)
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, str(rowDir['BAR4Y2']), rowNum=rowNum, colNum=9)
            # === 箭靶X，箭靶Y ===
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, str(rowDir['BAR3X']), rowNum=rowNum, colNum=10)
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, str(rowDir['BAR3Y']), rowNum=rowNum, colNum=11)
            # === 线路靶Y1，线路靶Y2 ===
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, str(rowDir['SIG4Y1']), rowNum=rowNum, colNum=12)
            item = QtGui.QTableWidgetItem()
            self.tableLamin_Item(item, str(rowDir['SIG4Y2']), rowNum=rowNum, colNum=13)

    def clickApply(self):
        """
        点击跑板边按钮的事件方法
        :return:
        """
        # --设定鼠标光标为busy状态
        self.setCursor(Qt.WaitCursor)
        # --检测panel板边和set边阻抗条放置是否距profile小于20mm TODO 取消
        coupon_ret = self.checkCouponStep()
        # --检查界面参数
        param_ret = self.check_parameter()
        # --检查InPlan数据库取值
        sql_ret = self.checkSQL()
        # === 检查钻孔层和ERP是否相同 ===
        hole_ret = self.checkDrlName()
        # --检查参数后再关闭主界面
        if coupon_ret and sql_ret and param_ret and hole_ret:
            # --关闭主界面前从UI界面取值
            self.get_UI_info()
            self.close()
            # --通过SQL查询取值,关闭界面后再查询，查询比较耗时，提升客户体验
            self.get_SQL_info()
            self.define_variables()
            self.write_file()
            self.run()
        else:
            # --还原光标为normal状态
            self.setCursor(Qt.ArrowCursor)

    def run(self):
        """
        在genesis或incam中具体执行添加symbol的函数
        :return:
        :rtype:
        """
        socket_mode = self.parm['socket_mode']
        json_string = json.dumps(self.parm, ensure_ascii=False, indent=4, separators=(', ', ': '), sort_keys=True)
        panel = Panel(job_name=self.JOB, step_name='panel', json_data=json_string, socket_mode=socket_mode,
                      debug=False)
        try:
            panel.run()
        except SystemExit:
            # --循环收集到的提示或警告信息统一释放
            msg_array = panel.msg_array
            msgInfo = ''
            if len(msg_array) > 0:
                msgInfo = u'<table border="1"><font size="3" color="#003DB2"><tr><th>类型</th><th>内容</th></tr>'
            for msg_dict in msg_array:
                if msg_dict['type'] == 'information':
                    msg_box = msgBox()
                    msg_box.information(self, msg_dict['windowTitle'], msg_dict['content'], QMessageBox.Ok)
                    msgInfo += u'<tr><td bgcolor=%s><font color="#FFFFFF">%s</td><td>%s</td></tr>' % (
                        'green', u'提示', msg_dict['content'])

                elif msg_dict['type'] == 'critical':
                    msg_box = msgBox()
                    msg_box.critical(self, msg_dict['windowTitle'], msg_dict['content'], QMessageBox.Ok)
                    # msgInfo += u'<br>%s' % msg_dict['content']
                    msgInfo += u'<tr><td bgcolor=%s><font color="#FFFFFF">%s</td><td><font color="red">%s</td></tr>' % (
                        'red', u'警告', msg_dict['content'])

                elif msg_dict['type'] == 'warning':
                    msg_box = msgBox()
                    msg_box.warning(self, msg_dict['windowTitle'], msg_dict['content'], QMessageBox.Ok)
                    # msgInfo += u'<br>%s' % msg_dict['content']
                    msgInfo += u'<tr><td bgcolor=%s><font color="#FFFFFF">%s</td><td><font color="red">%s</td></tr>' % (
                        'red', u'警告', msg_dict['content'])

            if msgInfo:
                # === 加入时间日期，方便知晓运行时间 ===
                date_time = datetime.strftime(datetime.now(), "%Y-%m-%d %H:%M:%S")
                msgInfo += u'</table><br><br>%s 以上警告信息，请注意检查！！！' % date_time
                # --包装html红色信息
                self.IKM.update_flow_report(panel.processID, jobid=panel.jobID, report=msgInfo)

    def get_SQL_info(self):
        """
        从数据库中查询数据,并存入字典，这部分数据与UI界面没有关系，查询需要耗时，故分开写入函数
        :return:
        :rtype:
        """
        # TODO 暂时不用家兴那部分，大部分是多层板内容
        fill_all = []  # --包括辅助层别
        # --fill_all要在fill_array中加入辅助层别
        # ----------------------------------------------------------------------------------------------------------
        fill_array = self.fill_array
        # print json.dumps(self.sqlDic)
        # all_etch_layer = self.parm['all_etch_layer']
        all_etch_layer = [str(i) for i in self.parm['all_etch_layer'] if i]        
        assist_layer = self.parm['assist_layer']
        assist_ref = self.parm['assist_ref']
        assist_side = self.parm['assist_side']
        for layer in all_etch_layer:
            for lyrDict in fill_array:
                layer_name = lyrDict['layer_name']
                layer_side = lyrDict['layer_side']
                layer_pol = lyrDict['layer_pol']
                panel_fill = lyrDict['panel_fill']
                copper_thick = lyrDict['copper_thick']
                lamin_num = lyrDict['lamin_num']
                gm_size = lyrDict['gm_size']
                temp_mode = [i['layerMode'] for i in self.sqlDic if i['LAYER_NAME'] == layer]
                layer_mode = temp_mode[0] if temp_mode else None
                if layer == layer_name:
                    # --正式层别
                    layerDict = {
                        'layer_name': layer_name,
                        'layer_side': layer_side,
                        'layer_pol': layer_pol,
                        'panel_fill': panel_fill,
                        'copper_thick': copper_thick,
                        'lamin_num': lamin_num,
                        'gm_size': gm_size,
                        'layer_mode': layer_mode
                    }
                    fill_all.append(layerDict)
                elif layer in assist_layer:
                    # --辅助层别
                    index = assist_layer.index(layer)
                    lyr_ref = assist_ref[index]
                    lyr_side = assist_side[index]
                    if lyr_side == 'top':
                        layer_side = '正'
                    elif lyr_side == 'bot':
                        layer_side = '反'
                    if lyr_ref == layer_name:
                        layerDict = {
                            # --层别名替换为辅助层，铜皮用辅助层专用铜皮,其它属性用参考层的
                            # == TODO 辅助层的铜厚不准确，实际是否应使用对应外层的铜厚？
                            'layer_name': layer,
                            'layer_side': layer_side,
                            'layer_pol': layer_pol,
                            'panel_fill': '辅助',
                            'copper_thick': copper_thick,
                            'lamin_num': lamin_num,
                            'gm_size': gm_size,
                            'layer_mode': 'fz'
                        }
                        fill_all.append(layerDict)
        self.parm['fill_array'] = fill_all
        
        # 是否跑pin_lam
        self.parm['pan_lam'] = '否'
        self.parm['all_flows'] = str(self.InPlan.GetInpalFlow())
        self.parm['short_top_et'] = True
        self.parm['short_bot_et'] = True
        self.parm['fusion_mode'] = '电磁热溶'
        self.parm['short_mao_yes'] = '否'
        if self.pin_lam:
            self.parm['pan_lam'] = '是'
    
        # inplan_bd_info = self.InPlan.getInplanBKbar()
        # 20230524 通过后台自动计算背钻靶距的mysql数据来获取背钻信息 by lyh
        lamin_data_Project = Project(self.JOB, None, database="hdi_engineering")
        inplan_bd_info = lamin_data_Project.getInplanBKbar(self.JOB.split("-")[0], self.userDir)  
        
        print json.dumps(inplan_bd_info,indent=2)
        # === TODO 判断外层背钻孔靶距是否与通孔靶距相同，如相同，认为通孔及背钻为同一钻带 ===
        finishBar = [(i['BAR4X1'], i['BAR4X2'], i['BAR4Y1'], i['BAR4Y2']) for i in self.lamin_data if
                     int(i['PROCESS_NUM']) - 1 == self.yh_num][0]

        for index, bkline in enumerate(inplan_bd_info):
            # print tmpi
            start_layer = 'l%s' % bkline['start_num']
            get_side = [i['layer_side'] for i in self.parm['fill_array'] if i['layer_name'] == start_layer][0]
            side_word = ''
            if get_side == '正':
                side_word = 'c'
            elif get_side == '反':
                side_word = 's'
            print side_word
            inplan_bd_info[index]['side_word'] = side_word
            cur_bd_type = bkline['drill_type'][0]
            # === 增加是否背钻和通孔的靶孔位置相同的判断
            for j, info in enumerate(bkline['TARGET_X1']):
                # 多次循环下 匹配到的即退出循环20221220 by lyh                
                if abs(bkline['TARGET_X1'][j] - finishBar[0]) < 1 and abs(bkline['TARGET_X2'][j] - finishBar[1]) < 1 \
                        and abs(bkline['TARGET_Y1'][j] - finishBar[2]) < 1 and abs(bkline['TARGET_Y2'][j] - finishBar[3]) < 1:
                    if cur_bd_type == "Controll Depth":
                        start_word = 'cd'
                    elif cur_bd_type == 'Backdrill':
                        start_word = 'bd'
                    elif cur_bd_type == 'Countersink':
                        start_word = 'cs'
                    elif cur_bd_type == 'Counterbore':
                        start_word = 'cb'
    
                    self.drl = "%s%s" % (start_word, side_word)
                    break
                

        # exit(0)
        self.parm['bd_info'] = inplan_bd_info
        self.parm['drl'] = self.drl

        # print json.dumps(self.allProcessInfo,indent = 2)
        burry_sz_dict = []
        for item in self.allProcessInfo:
            if item['树脂塞孔'] == 'yes' and int(item['压合级别'] - 1) != self.yh_num:
                if ',' in item['曝光底片']:
                    start_layer, end_layer = item['曝光底片'].split(',')
                    start_num = start_layer[1:]
                    end_num = end_layer[1:]
                else:
                    # 'QC2208PM006A2-10308' --> ['QC2208PM006A2', '10308'] -- > 3,8
                    tmp_item = item['子部件名'].split('-')[1]
                    start_num = int(tmp_item[1:3])
                    end_num = int(tmp_item[3:])
                sz_layer = 'sz%s-%s.lp' % (start_num, end_num)
                dq_layer = 'sz%s-%s...dq' % (start_num, end_num)
                mach_drill = 'b%s-%s' % (start_num, end_num)
                if mach_drill not in self.parm['drill_array']:
                    mach_drill = 'm%s-%s' % (start_num, end_num)

                if mach_drill not in self.parm['drill_array']:
                    # === TODO 考虑此项判断提前，需提示无对应钻带，或对应钻待设计与inplan不符
                    pass
                sz_dict = dict(mach_drill=mach_drill,
                               sz_layer=sz_layer,
                               dq_layer=dq_layer,
                               cur_yh_num=int(item['压合级别'] - 1))
                burry_sz_dict.append(sz_dict)
        # 蚀刻引线是否为碱性蚀刻
        self.parm['figer_dp_positive'] = 'no'
        inplan_all_flow = self.InPlan.get_inplan_all_flow()
        # print inplan_all_flow
        for d in inplan_all_flow:
            if (d['RJT_DESCRIPTION'] == u'碱性蚀刻') and (
                    d['WORK_CENTER_CODE'] and u'金手指去导线' in d['WORK_CENTER_CODE'].decode("utf8")):
                self.parm['figer_dp_positive'] = 'yes'

        # === 增加五代靶添加信息 2021.07.23 ===
        self.parm['v5list_o'] = []
        self.parm['v5laser'] = '否'
        for i in self.lamin_data:
            if i['V5LASER'] == 1:
                self.parm['v5list_o'].append(i['FROMLAY'].lower())
                self.parm['v5list_o'].append(i['TOLAY'].lower())
        if len(self.parm['v5list_o']) > 0:
            self.parm['v5laser'] = '是'

        self.parm['burry_sz_dict'] = burry_sz_dict
        # --从ERP中获取需要主动创建的钻孔层 === 提前并变更于在inplan获取
        # create_drill_layers = self.ERP.get_drill_layers()
        # self.parm['create_drill_layers'] = create_drill_layers
        # --从Project_status工程mysql数据库中查询防呆数据
        # ----------------------------------------------------------------------------------------------------------
        panel_x = self.parm['panel_x']
        panel_y = self.parm['panel_y']
        sr_xmin = self.get_05mm_result(self.parm['sr_xmin'])
        sr_ymin = self.get_05mm_result(self.parm['sr_ymin'])
        SR_xmax = self.parm['sr_xmax']
        fd_times_h = 0
        fd_times_v = 0
        loop_times_h = 0
        loop_times_v = 0
        fd_width = 3
        right_fd_h = 0
        other_fd_h = 0
        pin_fd_h = 0
        right_fd_v = 0
        other_fd_v = 0
        # 如果单个方向防呆8次，那么fd_ends取值为6,从序号-6开始
        fd_ends = 6
        # date_time = strftime ("%Y-%m-%d %H:%M:%S", localtime)

        # 从数据库中获取水平方向防呆数据
        fd_data = self.Project.get_fd_data('horizontal', panel_x=round(panel_x, 3), panel_y=round(panel_y, 3), sr_xmin_mm=sr_xmin,
                                           sr_ymin_mm=sr_ymin)
        if len(fd_data) > 0:
            (fd_times_h, loop_times_h, other_fd_h, right_fd_h, pin_fd_h) = [int(value) for value in fd_data]
        else:
            fd_data = self.Project.write_sigle_data('horizontal', fd_width=fd_width, panel_x=round(panel_x, 3), panel_y=round(panel_y, 3),
                                                    sr_xmin_mm=sr_xmin, sr_ymin_mm=sr_ymin, SR_xmax=SR_xmax)
            (fd_times_h, loop_times_h, other_fd_h, right_fd_h, pin_fd_h) = [int(value) for value in fd_data]

        # 从数据库中获取垂直方向防呆数据
        fd_data = self.Project.get_fd_data('vertical', panel_x=round(panel_x, 3), panel_y=round(panel_y, 3), sr_xmin_mm=sr_xmin,
                                           sr_ymin_mm=sr_ymin)
        if len(fd_data) > 0:
            (fd_times_v, loop_times_v, other_fd_v, right_fd_v) = [int(value) for value in fd_data]
        else:
            fd_data = self.Project.write_sigle_data('vertical', fd_width=fd_width, panel_x=round(panel_x, 3), panel_y=round(panel_y, 3),
                                                    sr_xmin_mm=sr_xmin, sr_ymin_mm=sr_ymin, SR_xmax=SR_xmax)

            # 如果正式数据库中当前尺寸，没有当前料号的防呆数据,将单一结果插入数据库
            (fd_times_v, loop_times_v, other_fd_v, right_fd_v) = [int(value) for value in fd_data]

        self.fd_width = 3
        self.parm['fd_width'] = self.fd_width
        self.parm['fd_times_h'] = fd_times_h
        self.parm['loop_times_h'] = loop_times_h

        self.parm['fd_times_v'] = fd_times_v
        self.parm['loop_times_v'] = loop_times_v

        # 每个位置偏移3mm
        self.parm['other_fd_h'] = self.parm['fd_width'] * other_fd_h
        self.parm['right_fd_h'] = self.parm['fd_width'] * right_fd_h
        self.parm['pin_fd_h'] = self.parm['fd_width'] * pin_fd_h
        self.parm['other_fd_v'] = self.parm['fd_width'] * other_fd_v
        self.parm['right_fd_v'] = self.parm['fd_width'] * right_fd_v

    def get_05mm_result(self, input):
        int_pos = int(input / 0.5);
        dec_pos = input / 0.5 - int_pos
        if dec_pos >= 0.5:
            output = int_pos * 0.5 + 0.5
        else:
            output = int_pos * 0.5
        if output.is_integer():
            output = int(output)
        return output

    def get_UI_info(self):
        '''
        从window界面TabWidget控件中获取所有参数
        :return:
        '''
        # 界面关闭前，参数不再变化，统一从界面获取参数并存入字典
        self.parm['split_via'] = self.split_via
        self.parm['split_pth'] = self.split_pth
        self.parm['dry_hole'] = self.dry_hole
        self.parm['rout_x'] = self.rout_x
        self.parm['rout_y'] = self.rout_y
        self.parm['cycle_in_silk'] = self.cycle_in_silk
        self.parm['cycle_in_sm'] = self.cycle_in_sm
        self.parm['cycle_in_signal'] = self.cycle_in_signal
        self.parm['board_thick'] = self.board_thick
        self.parm['sh_site'] = self.sh_site
        # --经向纬向选择
        self.parm['wei_xiang'] = self.wei_xiang
        if self.flow_content == '二次铜(正片)':
            self.parm['flow_content'] = '二次铜'
        elif self.flow_content == '一次铜(负片)':
            self.parm['flow_content'] = '一次铜'
        else:
            self.parm['flow_content'] = self.flow_content
        self.parm['silk_top_color'] = self.select_color_silk
        self.parm['silk_bot_color'] = self.select_color_silk
        self.parm['select_color_silk'] = self.select_color_silk
        self.parm['array_step'] = self.array_step
        self.parm['array_x_size'] = self.array_x_size
        self.parm['array_y_size'] = self.array_y_size
        self.parm['panel_x'] = self.panel_x
        self.parm['panel_y'] = self.panel_y
        self.parm['mao_pin_x'] = self.mao_pin_x
        self.parm['mao_pin_y'] = self.mao_pin_y
        self.parm['ape3000_base'] = self.ape3000_base
        # --是否金手指
        if self.sel_jsz_yes:
            self.parm['sel_jsz'] = u'是'
        else:
            self.parm['sel_jsz'] = u'否'
        # --是否化金板
        if self.add_hj_panel_yes:
            self.parm['add_hj_panel'] = u'是'
        else:
            self.parm['add_hj_panel'] = u'否'
        # --是否手指选化
        if self.sel_finger_yes:
            self.parm['sel_finger'] = u'是'
        else:
            self.parm['sel_finger'] = u'否'
        # --板内手指方向
        self.parm['g_direction'] = self.g_direction
        # --是否镭雕制程
        if self.add_ld_symbol_yes:
            self.parm['add_ld_symbol'] = u'是'
        else:
            self.parm['add_ld_symbol'] = u'否'
        # # --外层ccd，一般都是，此变量后面也用不到，胜华才会有非ccd流程
        # if self.sel_out_ccd_yes:
        #     self.parm['sel_out_ccd'] = u'是'
        # else:
        #     self.parm['sel_out_ccd'] = u'否'
        # --大板vcut
        if self.sel_vut_yes:
            self.parm['sel_vut'] = u'是'
        else:
            self.parm['sel_vut'] = u'否'
        # --是否LED板
        if self.add_eagle_panel_yes:
            self.parm['add_eagle_panel'] = u'是'
        else:
            self.parm['add_eagle_panel'] = u'否'
        # --是否二次文字
        if self.select_silk_times == "二次" or self.select_silk_times == "三次":
            self.parm['twice_wz_panel'] = u'是'
        else:
            self.parm['twice_wz_panel'] = u'否'
        # --是否二次防焊
        if self.select_solder_times == "二次" or self.select_solder_times == "三次":
            self.parm['twice_fh_panel'] = u'是'
        else:
            self.parm['twice_fh_panel'] = u'否'
        # # --是否勾选服务器模块
        # if self.select_server_yes:
        #     self.parm['select_server_value'] = u'是'
        # else:
        #     self.parm['select_server_value'] = u'否'
        # # --是否勾选机械钻ccd
        # if self.select_ccd_yes:
        #     self.parm['select_ccd_value'] = u'是'
        # else:
        #     self.parm['select_ccd_value'] = u'否'
        # --是否socket方式运行
        if self.sel_socket_yes:
            self.parm['socket_mode'] = u'是'
        else:
            self.parm['socket_mode'] = u'否'

        # --从界面获取不包括辅助层的fill_array
        # ----------------------------------------------------------------------------------------------------------
        fill_array = []  # --不包括辅助层别
        layer_items = (self.ui.tableWidget.item(row, 0) for row in range(self.ui.tableWidget.rowCount()))
        for layer_item in layer_items:
            # --获取选中的行信息，行号，列号
            lyrText = str(layer_item.text())
            lyrRow = layer_item.row()
            lyrCol = layer_item.column()

            # --获取此行的铜厚信息
            lyrOz = str(self.comBox[lyrRow].currentText())
            # --获取此行的层别正反信息
            lyrSide = str(self.comBox_side[lyrRow].currentText())
            # --获取此行的层别极性信息
            lyrPolar = str(self.item_polarity[lyrRow].text())
            # --获取此行的层别极性信息
            lyrFill = str(self.item_fillType[lyrRow].text())
            # === 当前层别所属的压合级别
            lyr_lamin_num = str(self.item_lamin_num[lyrRow].text())
            # === 当前层别所属的干膜尺寸
            lyr_gm_size = str(self.item_gmSize[lyrRow].text())

            # --汇总当前层的参数
            lyrDict = {
                'layer_name': lyrText,
                'layer_side': lyrSide,
                'layer_pol': lyrPolar,
                'panel_fill': lyrFill,
                'copper_thick': lyrOz,
                'lamin_num': lyr_lamin_num,
                'gm_size': lyr_gm_size
            }
            fill_array.append(lyrDict)
        self.fill_array = fill_array

    def get_JOB_info(self):
        """
        通过DO_INFO从料号中获取info并存入字典
        :return:
        :rtype:
        """
        # --从料号info中获取创建md2层别时的插入位置
        info = self.GEN.DO_INFO('-t layer -e %s/panel/c2 -d EXISTS' % self.JOB)
        if info['gEXISTS'] == "yes":
            zero_layer = "c2"
        else:
            zero_layer = "m2"

        # --变量和数组定义
        zero_tmp = 0
        self.have_silk_in_pcb = "no"
        silk_array = []
        drill_array = []
        sm_array = []
        all_signal_array = []
        burry_list = []
        blind_list = []
        blind_burry_list = []
        blind_burry_start = []
        blind_burry_end = []
        burry_start = []
        burry_end = []
        jx_drill_list = []
        jx_drill_start = []
        jx_drill_end = []
        Burry_Reg = re.compile(r'^[b][0-9][0-9]?-?[0-9][0-9]?$')
        Blind_Reg = re.compile(r'^[s,b][0-9][0-9]?-?[0-9][0-9]?$')
        Machine_Reg = re.compile(r'^m[0-9][0-9]?-?[0-9][0-9]?$')

        # --从料号info中获取层别及信息
        info = self.GEN.DO_INFO('-t matrix -e %s/matrix -m script -d ROW' % self.JOB)
        for i, name in enumerate(info['gROWname']):
            context = info['gROWcontext'][i]
            layer_type = info['gROWlayer_type'][i]
            # --获取bottom面插入新增board层的位置，一般在md2之后
            if name == zero_layer and zero_tmp == 0:
                zero_tmp = i + 1
                zero_layer = info['gROWname'][zero_tmp]
            if name in ["c1", "c2", "cc", "cc2","c1-1",'c2-1']:
                self.have_silk_in_pcb = "yes"
            # --获取字符层
            if context == 'board' and layer_type == 'silk_screen':
                silk_array.append(name)
            # --获取钻孔层
            if context == 'board' and layer_type == 'drill':
                drill_array.append(name)
                # --匹配镭射钻孔层
                if Blind_Reg.match(name):
                    blind_burry_list.append(name)
                    if Burry_Reg.match(name):
                        # --埋孔
                        burry_list.append(name)
                    else:
                        # --盲孔
                        blind_list.append(name)
                # --匹配镭射钻孔层
                if Machine_Reg.match(name):
                    jx_drill_list.append(name)
            # --获取阻焊层
            if context == 'board' and layer_type == 'solder_mask':
                sm_array.append(name)
            # --获取信号层
            if context == 'board' and layer_type in ['signal', 'power_ground']:
                all_signal_array.append(name)
        # --所有文字层即为barcode层
        barcode_layers_list = silk_array
        # --定义用来比较层数的变量
        try:            
            self.compare_layer_value1 = int(self.JOB[4:6])
        except Exception, e:
            self.compare_layer_value1 = len(all_signal_array)
            
        self.compare_layer_value2 = len(all_signal_array)
        # --后面check_parameter需要reference的变量
        self.lj_board_fd = "no"
        self.sh_single_pcb = "no"
        if self.JOB[4:6] == '01':
            self.lj_board_fd = "yes"
            self.sh_single_pcb = "yes"
        self.parm['lj_board_fd'] = self.lj_board_fd
        self.parm['sh_single_pcb'] = self.sh_single_pcb

        self.parm['add_px_panel'] = u'否'
        # --从料号名区分是否喷锡板
        if self.JOB[6] in ['h', 'l']:
            self.parm['add_px_panel'] = u'是'

        # --定义bottom面
        self.job_signal_numbers = len(all_signal_array)

        # --定义外层数组
        out_signal_array = ["l1", "l%s" % self.job_signal_numbers]
        # --定义hdi_num
        hdi_num = len(blind_burry_list)

        # --从InPlan中查询所有钻带的起始和结束层
        self.drl_info = self.InPlan.get_start_end()
        # --将孔带拉正确
        self.matrix_drill()

        # --获取机械盲孔起始结束层
        for layer in jx_drill_list:
            # --将起始层定义到信号层
            info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d DRL_START' % (self.JOB, layer))
            layer_start = info['gDRL_START']
            info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d SIDE' % (self.JOB, layer_start))
            side_start = info['gSIDE']
            if side_start == 'top':
                layer_start = 'l1'
            # --将结束层定义到信号层
            info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d DRL_END' % (self.JOB, layer))
            layer_end = info['gDRL_END']
            info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d SIDE' % (self.JOB, layer_end))
            side_end = info['gSIDE']
            if side_end == 'bottom':
                layer_end = 'l%s' % self.job_signal_numbers
            jx_drill_start.append(layer_start)
            jx_drill_end.append(layer_end)

        # --获取盲埋孔起始结束层
        for layer in blind_burry_list:
            m = re.match(r'^[s,b]([0-9][0-9]?)-?([0-9][0-9]?)$', layer)
            layer_start = 'l%s' % (m.group(1))
            layer_end = 'l%s' % (m.group(2))
            # # --将起始层定义到信号层
            # info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d DRL_START' % (self.JOB, layer))
            # layer_start = info['gDRL_START']
            # info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d SIDE' % (self.JOB, layer_start))
            # side_start = info['gSIDE']
            # if side_start == 'top':
            #     layer_start = 'l1'
            # # --将结束层定义到信号层
            # info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d DRL_END' % (self.JOB, layer))
            # layer_end = info['gDRL_END']
            # info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d SIDE' % (self.JOB, layer_end))
            # side_end = info['gSIDE']
            # if side_end == 'bottom':
            #     layer_end = 'l%s' % self.job_signal_numbers
            blind_burry_start.append(layer_start)
            blind_burry_end.append(layer_end)
            burry_m = re.match(r'^[b]([0-9][0-9]?)-?([0-9][0-9]?)$', layer)
            if burry_m:
                burry_start.append(layer_start)
                burry_end.append(layer_end)
        # --定义top_laser和bot_laser
        half_layer_num = int(self.job_signal_numbers * 0.5)
        top_hdi_list = []
        bot_hdi_list = []
        for i, layer in enumerate(blind_burry_list):
            if layer in blind_list:
                index_start = int(blind_burry_start[i][1:])
                index_end = int(blind_burry_end[i][1:])
                if index_start <= half_layer_num:
                    top_hdi_list.append(layer)
                else:
                    bot_hdi_list.append(layer)

        blind_burry_by_lamin = []
        lr_layer = None
        for cur_yh_num in range(1, self.yh_num + 1):
            cur_yh_start_num = int(
                [i['FROMLAY'] for i in self.lamin_data if int(i['PROCESS_NUM']) - 1 == cur_yh_num][0][1:])
            cur_yh_end_num = int(
                [i['TOLAY'] for i in self.lamin_data if int(i['PROCESS_NUM']) - 1 == cur_yh_num][0][1:])
            v5laser_yn = [i['V5LASER'] for i in self.lamin_data if int(i['PROCESS_NUM']) - 1 == cur_yh_num][0]
            # === 保证压合次数 0，1，2的顺序 ===
            if cur_yh_num == 1:
                zero_yh_num = 0
                zero_dict = {}
                # ===当第一压合的中间层数为2时，生成第0次压合，0压
                if cur_yh_end_num - cur_yh_start_num == 3:
                    zero_yh_start_num = cur_yh_start_num + 1
                    zero_yh_end_num = cur_yh_end_num - 1
                    if 'b%s-%s' % (zero_yh_start_num, zero_yh_end_num) in burry_list:
                        zero_dict = dict(cur_yh_num=zero_yh_num,
                                         burryLayer='b%s-%s' % (zero_yh_start_num, zero_yh_end_num),
                                         start_num=zero_yh_start_num, end_num=zero_yh_end_num)
                    zero_laser_list = []
                    for laser_layer in blind_list:
                        m = re.match(r'^[s]([0-9][0-9]?)-?([0-9][0-9]?)$', laser_layer)
                        layer_start_num = int(m.group(1))
                        if layer_start_num == zero_yh_start_num or layer_start_num == zero_yh_end_num:
                            zero_laser_list.append(laser_layer)

                        if zero_laser_list:
                            lr_layer = 'lr%s-%s' % (zero_yh_start_num, zero_yh_end_num)
                            if zero_dict:
                                zero_dict['blindLayer'] = zero_laser_list
                            else:
                                zero_dict = dict(cur_yh_num=zero_yh_num, blindLayer=zero_laser_list,
                                                 start_num=zero_yh_start_num, end_num=zero_yh_end_num)
                    if zero_dict:
                        blind_burry_by_lamin.append(zero_dict)

            cur_dict = {}
            if 'b%s-%s' % (cur_yh_start_num, cur_yh_end_num) in burry_list:
                cur_dict = dict(cur_yh_num=cur_yh_num, burryLayer='b%s-%s' % (cur_yh_start_num, cur_yh_end_num))
            cur_laser_list = []
            for laser_layer in blind_list:
                m = re.match(r'^[s]([0-9][0-9]?)-?([0-9][0-9]?)$', laser_layer)
                layer_start_num = int(m.group(1))
                if layer_start_num == cur_yh_start_num or layer_start_num == cur_yh_end_num:
                    cur_laser_list.append(laser_layer)
                if cur_laser_list:

                    if cur_dict:
                        cur_dict['blindLayer'] = cur_laser_list
                    else:
                        cur_dict = dict(cur_yh_num=cur_yh_num, blindLayer=cur_laser_list)
            if v5laser_yn == 1 and len(cur_laser_list) < 2:
                msg_box = msgBox()
                msg_box.critical(self, '警告',
                                 '料号：%s,第%s次压合有五代靶设计，\n镭射层：%s不足2层,请手动添加！' % (self.JOB, cur_yh_num, cur_laser_list),
                                 QMessageBox.Ok)
            if cur_dict:
                blind_burry_by_lamin.append(cur_dict)

        #计算HDI阶数
        top_laser_num = len(set([x.split("-")[0] for x in top_hdi_list]))
        bot_laser_num = len(set([x.split("-")[0] for x in bot_hdi_list]))
        hdi_jie = max([top_laser_num, bot_laser_num])
        
        # === 写入全局变量 ===
        self.parm['blind_burry_by_lamin'] = blind_burry_by_lamin
        self.parm['lr_layer'] = lr_layer
        # --定义需要添加尾孔的清单
        tail_hole_list = ['drl']
        info = self.GEN.DO_INFO('-t layer -e %s/edit/%s -d EXISTS' % (self.JOB, '2nd'))
        if info['gEXISTS'] == "yes":
            # --如果钻带名在当前料号不存在
            tail_hole_list.append('2nd')
        info = self.GEN.DO_INFO('-t layer -e %s/edit/%s -d EXISTS' % (self.JOB, '3nd'))
        if info['gEXISTS'] == "yes":
            # --如果钻带名在当前料号不存在
            tail_hole_list.append('3nd')
        tail_hole_list += burry_list + jx_drill_list
        self.parm['tail_hole_list'] = tail_hole_list

        # --定义二次防焊层别名,有机械盲孔m1-2存在时,二次防焊名要用别的名字
        twice_fh_top = 'm1-2'
        info_e = self.GEN.DO_INFO('-t layer -e %s/panel/m1-2 -d EXISTS' % self.JOB)
        if info_e['gEXISTS'] == "yes":
            info_t = self.GEN.DO_INFO('-t layer -e %s/panel/m1-2 -m script -d TYPE' % self.JOB)
            if info_t['gTYPE'] == 'drill':
                # --有机械盲孔m1-2存在时,二次防焊字要用别的名字
                twice_fh_top = 'm1_2'
        self.parm['twice_fh_top'] = twice_fh_top

        # --将变量和数组写入字典
        self.parm['barcode_layers_list'] = barcode_layers_list
        self.parm['compare_layer_value1'] = self.compare_layer_value1
        self.parm['compare_layer_value2'] = self.compare_layer_value2
        # --直接用层别定义并不准确,没有考虑到辅助层
        assist_layer = self.parm['assist_layer']
        self.job_signal_numbers += len(assist_layer)
        self.parm['job_signal_numbers'] = self.job_signal_numbers
        self.parm['out_signal_array'] = out_signal_array
        self.parm['have_silk_in_pcb'] = self.have_silk_in_pcb
        self.parm['zero_layer'] = zero_layer
        self.parm['silk_array'] = silk_array
        self.parm['drill_array'] = drill_array
        self.parm['sm_array'] = sm_array
        self.parm['all_signal_array'] = all_signal_array
        self.parm['blind_burry_list'] = blind_burry_list
        self.parm['burry_list'] = burry_list
        self.parm['blind_list'] = blind_list
        self.parm['blind_burry_start'] = blind_burry_start
        self.parm['blind_burry_end'] = blind_burry_end
        self.parm['burry_start'] = burry_start
        self.parm['burry_end'] = burry_end

        self.parm['top_hdi_list'] = top_hdi_list
        self.parm['bot_hdi_list'] = bot_hdi_list
        self.parm['jx_drill_list'] = jx_drill_list
        self.parm['jx_drill_start'] = jx_drill_start
        self.parm['jx_drill_end'] = jx_drill_end
        self.parm['hdi_num'] = hdi_num
        self.parm['hdi_jie'] = hdi_jie

    def matrix_drill(self):
        """
        将孔带拉正确
        :return: None
        :rtype: None
        """
        pid = os.getpid()
        if platform.system() == "Linux":
            tmpPath = "/tmp"
        else:
            tmpPath = "C:/tmp"
        tmp_file = '%s/info.%s' % (tmpPath, pid)
        drl_info = dict(self.drl_info)
        # TODO 镭射层不符合的起始层在Linux下会报错
        # self.GEN.COM('open_entity,job=%s,type=matrix,name=matrix,iconic=no' % self.JOB)
        # for drl_name in drl_info.keys():
        #     drl_layer = drl_name.lower()
        #     self.GEN.VOF()
        #     info_status = self.GEN.COM('info, out_file=%s,args= -t layer -e %s/edit/%s -d EXISTS' % (tmp_file,self.JOB,drl_layer))
        #     os.remove(tmp_file)
        #     self.GEN.VON()
        #     if info_status:
        #         # --如果查询结果中有非法的层别名,比如a00/024b1 (bd1-3&1-5&1-1)
        #         continue
        #     info = self.GEN.DO_INFO('-t layer -e %s/edit/%s -d EXISTS' % (self.JOB,drl_layer))
        #     if info['gEXISTS'] == "no":
        #         # --如果钻带名在当前料号不存在
        #         continue
        #     info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d CONTEXT' % (self.JOB,drl_layer))
        #     if info['gCONTEXT'] != "board":
        #         # --如果钻带不是board属性
        #         continue
        #     info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d TYPE' % (self.JOB, drl_layer))
        #     if info['gTYPE'] != "drill":
        #         # --如果钻带不是drill属性,二次防焊m1-2,会与机械盲孔m1-2冲突，参考料号s51506hi068a6
        #         continue
        #     drl_type = drl_info[drl_name]['drl_type']
        #     if drl_type not in ['Laser','Mechanical']:
        #         # --只对镭射和机械钻孔拉钻带,定深和背钻不一定准确,忽略
        #         continue
        #     drl_start = "l%s" % drl_info[drl_name]['drl_start']
        #     drl_end = "l%s" % drl_info[drl_name]['drl_end']
        #     # --将起始层定义到信号层
        #     info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d DRL_START' % (self.JOB, drl_layer))
        #     layer_start = info['gDRL_START']
        #     org_start = layer_start
        #     info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d SIDE' % (self.JOB, layer_start))
        #     side_start = info['gSIDE']
        #     if side_start == 'top':
        #         layer_start = 'l1'
        #     # --将结束层定义到信号层
        #     info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d DRL_END' % (self.JOB, drl_layer))
        #     layer_end = info['gDRL_END']
        #     org_end = layer_end
        #     info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d SIDE' % (self.JOB, layer_end))
        #     side_end = info['gSIDE']
        #     if side_end == 'bottom':
        #         layer_end = 'l%s' % self.job_signal_numbers
        #     # --只有孔带不正确时才拉孔带
        #     if layer_start != drl_start or layer_end != drl_end:
        #         # --拉到外层以后的孔带尽量维持不动
        #         if side_start == 'top' and layer_start == drl_start:
        #             drl_start = org_start
        #         if side_end == 'bottom' and layer_end == drl_end:
        #             drl_end = org_end
        #         self.GEN.COM('matrix_layer_drill,job=%s,matrix=matrix,layer=%s,start=%s,end=%s'
        #                      % (self.JOB, drl_layer, drl_start, drl_end))
        # self.GEN.COM('matrix_page_close,job=%s,matrix=matrix' % self.JOB)

    def set_UI_by_SQL(self):
        '''
        根据从inplan和ERP数据库中查询的数据,更新window界面参数
        :return:
        :rtype:
        '''
        # --TODO 料号中获取数据 设置切片via和pth
        # self.split_via,self.split_pth = self.InPlan.get_hole_size()
        # --干膜孔大小固定为0.452
        self.dry_hole = 0.452
        # --设置是否为镭雕制程
        self.add_ld_symbol_yes = False
        print json.dumps(self.job_data, ensure_ascii=False, indent=2)
        if self.job_data['是否有雷雕'] == "无":
            self.add_ld_symbol_yes = False
        elif self.job_data['是否有雷雕'] == "有":
            self.add_ld_symbol_yes = True

        # if self.job_data['是否树脂塞']:
        self.parm['RESIN_PLUG'] = self.job_data['是否树脂塞']
        # if self.job_data['是否防焊塞']:
        self.parm['SM_PLUG'] = self.job_data['是否阻焊塞']
        self.parm['INPLAN_PCS_PER_SET'] = self.job_data['SET中的PCS数']
        # --设置锣边后尺寸
        self.rout_x = [i['PNLROUTX'] for i in self.lamin_data if (int(i['PROCESS_NUM']) - 1) == self.yh_num][0] * 25.4
        self.rout_y = [i['PNLROUTY'] for i in self.lamin_data if (int(i['PROCESS_NUM']) - 1) == self.yh_num][0] * 25.4
        # --设置周期添加面别
        PERIOD_FACE_ = self.job_data['周期面别']
        if PERIOD_FACE_ == '文字S面' or PERIOD_FACE_ == '文字C面' or PERIOD_FACE_ == '文字C面+S面':
            self.cycle_in_silk = True
        if PERIOD_FACE_ == '防焊C面' or PERIOD_FACE_ == '防焊S面' or PERIOD_FACE_ == '防焊C面+S面':
            self.cycle_in_sm = True
        if PERIOD_FACE_ == '蚀刻C面' or PERIOD_FACE_ == '蚀刻S面' or PERIOD_FACE_ == '蚀刻C面+S面':
            self.cycle_in_signal = True
        # --设置板厚
        self.board_thick = self.job_data['成品板厚']
        # --设置厂别
        # if self.InPlan.get_site():
        #     # --优先从InPlan中取值
        #     self.sh_site = self.InPlan.get_site()
        # else:
        #     # --如果InPlan中没有厂别信息，则从ERP中获取
        if self.job_data['工厂'] == "S01H1:HDI一厂":
            self.sh_site = u"HDI一厂"
        elif self.job_data['工厂'] == "S01H2:HDI二厂":
            self.sh_site = u"HDI二厂"
        # --设置一次铜二次铜流程
        self.flow_content = [i['蚀刻类型'] for i in self.allProcessInfo if (int(i['压合级别']) - 1) == self.yh_num][0]
        # == 1代表一次铜，2代表二次铜 0代表NONE
        if self.flow_content == 1 or self.flow_content == 0:
            # --2对应none,也当成一次铜
            self.flow_content = u'一次铜'
        else:
            self.flow_content = u'二次铜'

        self.add_eagle_panel_yes = self.InPlan.judge_led_board()
        self.mini_led = self.ERP.judge_mini_LED()

        # === 获取inplan流程，从流程中判断是否选化印油 ===
        self.inplan_all_flow = self.InPlan.get_inplan_all_flow()
        self.linek_flow = False
        # 定义二次选化
        # 周涌通知 20221125 by lyh
        #1，有linek-c-1与linek-c-2存在时，就不需要linek-c
        #2，有linek-c-1与linek-c-2存在时，就要有xlym-c
        #3，单独的linek-c存在时，不需要xlym-c
        self.linek_flow_1 = False
        self.linek_flow_2 = False
        self.xh_xlym = False
        self.xh_xlym2 = False   
        # print  self.inplan_all_flow
        if '印选化油' in [i['WORK_CENTER_CODE'] for i in self.inplan_all_flow]:
            self.linek_flow = True
            
            for i in self.inplan_all_flow:
                if i['VALUE_AS_STRING'] is not None :
                    value = i['VALUE_AS_STRING']
                    if "xlym-c" in value or \
                       "xlym-s" in value:
                        self.xh_xlym = True              
                        
                if i['NOTE_STRING'] is not None :
                    value = i['NOTE_STRING']
                    if "xlym-c" in value or \
                       "xlym-s" in value:
                        self.xh_xlym = True              
            
        if '印选化油（二）' in [i['WORK_CENTER_CODE'] for i in self.inplan_all_flow]:
            self.linek_flow = False                  
            
        for i in self.inplan_all_flow:
            if '印选化油' in i['WORK_CENTER_CODE'] or '印选化油（二）' in i['WORK_CENTER_CODE']:
                if i['VALUE_AS_STRING'] is not None :
                    value = i['VALUE_AS_STRING']
                    if "linek-c-1" in value or \
                       "linek-s-1" in value:
                        self.linek_flow_1 = True                        
                    if "linek-c-2" in value or \
                       "linek-s-2" in value:
                        self.linek_flow_2 = True
                        
                    if "xlym-c-2" in value or \
                       "xlym-s-2" in value:
                        self.xh_xlym2 = True                          
                        
                if i['NOTE_STRING'] is not None :
                    value = i['NOTE_STRING']                      
                    if "linek-c-1" in value or \
                       "linek-s-1" in value:
                        self.linek_flow_1 = True                        
                    if "linek-c-2" in value or \
                       "linek-s-2" in value:
                        self.linek_flow_2 = True
                        
                    if "xlym-c-2" in value or \
                       "xlym-s-2" in value:
                        self.xh_xlym2 = True                         
                        
        if not self.linek_flow_1 and not self.linek_flow_2:            
            if '印选化油' in [i['WORK_CENTER_CODE'] for i in self.inplan_all_flow]:
                self.linek_flow = True  

        self.judge_phone_subplate = False
        cusNo = self.JOB[1:4]
        if cusNo == '183':
            self.judge_phone_subplate = self.ERP.judge_phone_subplate()
        self.parm['linek_flow'] = self.linek_flow
        self.parm['linek_flow_1'] = self.linek_flow_1
        self.parm['linek_flow_2'] = self.linek_flow_2
        self.parm['xh_xlym'] = self.xh_xlym
        self.parm['xh_xlym2'] = self.xh_xlym2
        
        self.parm['mini_led'] = self.mini_led
        self.parm['judge_phone_subplate'] = self.judge_phone_subplate

        # --设置文字颜色
        self.select_silk_times = u'%s' % self.job_data['字符次数']
        self.select_solder_times = u'%s' % self.job_data['阻焊次数']
        # print  self.job_data['字符颜色']
        if self.job_data['字符颜色']:
            if self.job_data['字符颜色'] == '/':
                self.ui.select_color_silk.setDisabled(False)
                msg_box = msgBox()
                msg_box.critical(self, '警告', 'Inplan中无有效字符颜色！', QMessageBox.Ok)
            elif '+' in  self.job_data['字符颜色']:
                # === TODO 2022.05.20 料号：H01104PI016A1有两种字符颜色:白色+黑色，先定义自行选择 ===
                # self.ui.select_color_silk.setDisabled(False)
                msg_box = msgBox()
                msg_box.critical(self, '警告', 'Inplan存在两种字符颜色：%s，请自行在板边添加颜色标记！' % self.job_data['字符颜色'], QMessageBox.Ok)
            else:
                self.select_color_silk = u'%s' % self.job_data['字符颜色']
        else:
            self.ui.select_color_silk.setDisabled(True)
        #
        # --设置版本信息
        date_today = datetime.strftime(datetime.now(), "%Y.%m.%d")
        self.appVersion = u'版权所有：胜宏科技 作者：Michael&Song 日期：%s 版本：V2.15' % date_today
        version_info = {
            'V1.03': {
                'author': 'song',
                'develop_date': '2021-09-15',
                'publish_date': '2021-09-17',
                'purpose': '1.开料尺寸＜21.5*24.5inch，板边铺铜采用蜂窝铜;'
                           '2.开料尺寸＜21.5*24.5inch, dld设计在短边'
                           '3.通孔板，线路用钻出的4颗孔对位',
                'url': 'http://192.168.2.120:82/zentao/story-view-3360.html'
            },
            'V1.04': {
                'author': 'song',
                'develop_date': '2021-09-20',
                'publish_date': '2021-09-22',
                'purpose': '1.2oz的内层PE光点更改为35mil(增加35mil pad)(9-20);'
                           '2.取消阴阳拼版新建层别时，切换step的动作(9-20);'
                           '3.双面板的dbk应设计板角四孔而inn不设计(9-22)',
                'url': '1.http://192.168.2.120:82/zentao/story-view-3536.html'
            },
            'V1.05': {
                'author': 'song',
                'develop_date': '2021-09-28',
                'publish_date': None,
                'purpose': '1.InPlan类中更改函数getInplanBKbar获取背钻靶位数据的SQL中增加ERP中钻带命名;'
                           '2.InPlan类中增加get_inplan_drill_info更改为从inplan中获取钻带信息，归类当前钻带中的所有钻孔层;'
                           '3.切片via与切片PTH孔径从InPlan获取;'
                           '4.金手指XY方向均有时，检测单只铜到镀金开窗铜是否满足20mm;'
                           '5.10-14 3张PP的溶胶区添加未生效，增加三张PP条件，Bug料号503-097a2',
                'url': '1.http://192.168.2.120:82/zentao/story-view-3265.html'
                       '2.http://192.168.2.120:82/zentao/story-view-3546.html'
                       '3.http://192.168.2.120:82/zentao/story-view-3502.html'
            },
            'V1.06': {
                'author': 'song',
                'develop_date': '2021-10-11',
                'publish_date': '2021-10-19',
                'purpose': '1.长7短5靶放在内层干膜的有效范围内,改写长七短五部分程序写法，改为单独类,使格式统一'
                           '2.更改界面，做部分项目锁定，避免人员随意更改'
                           '3.TopCAM结果栏位中增加了运行完成的时间日期'
                           '4.开发备注：testButton更改为unlockUIButton',
                'url': '1.http://192.168.2.120:82/zentao/story-view-3556.html'
                       '2.http://192.168.2.120:82/zentao/story-view-3547.html'
            },
            'V1.07': {
                'author': 'song',
                'develop_date': '2021-10-18',
                'publish_date': '2021-10-22',
                'purpose': '1.修正备用靶会与板角四孔的情况'
                           '2.修正函数write_base中写入数据库时的异常，应使用最后一条数据'
                           '3.修正类silk_word中选化层的处理'
                           '4.埋孔防爆孔与埋孔距离近，进行删除过近埋孔防爆孔',
                'url': '1.http://192.168.2.120:82/zentao/story-view-3549.html'
            },
            'V1.08': {
                'author': 'song',
                'develop_date': '2021-10-26',
                'publish_date': '2021-10-28',
                'purpose': '1.修正溶胶防爆孔部分，无论如何加两排'
                           '2.切片孔避让备用靶'
                           '3.文字对位pad改为在X-Ray靶后添加，并增加动态移动，用于避让备用靶'
                           '4.防焊对位pad改为在X-Ray靶后添加，并增加动态移动，用于避让备用靶'
                           '5.10-29 3张PP的最外两层添加了溶胶区，实际不需要'
                           '6.11-09 周期支持蚀刻C面+S面，料号：B74-006A2',
                'url': None
            },
            'V1.09': {
                'author': 'song',
                'develop_date': '2021-11-17',
                'publish_date': '2021-11-18',
                'purpose': '1. panel边锣刀位/铣刀位铺铜更改'
                           '2. Mini LED及Micro LED板边蝴蝶pad/鹰眼pad开窗挡点状态更改'
                           '3. 板厚小于0.4，板边切铜'
                           '4. 更改阴阳拼版判断语句，如果有阴阳拼版于添加层别前在edit中释放依赖关系'
                           '5. 11-24 双面板二次文字白油块跑至中间，修正此问题888-704C1'
                           '6. 11-24 板边Core层铜厚字样仅纯内层保留，其他删除'
                           '7. 12-2 双面板金手指外层未铺铜，修复此问题'
                           '8. 修正vcut对位孔的公差问题',
                'url': 'http://192.168.2.120:82/zentao/story-view-3617.html'
                       'http://192.168.2.120:82/zentao/story-view-3689.html'
                       'http://192.168.2.120:82/zentao/story-view-3558.html'
                       'http://192.168.2.120:82/zentao/story-view-3685.html'
            },
            'V1.10': {
                'author': 'song',
                'develop_date': '2021-11-25',
                'publish_date': None,
                'purpose': '未发布，合并至V2.00版本',
                'url': None
            },
            'V2.00': {
                'author': 'song',
                'develop_date': '2021-11-25',
                'publish_date': '2021-12-16',
                'purpose': '1.	压合靶距数据防呆，靶距不符合规则时，板边界面跑板边按钮禁用;'
                           '2	对比ERP验证盲埋孔钻带在料号中是否存在;'
                           '3	通孔料号孔避让五代靶及内靶;'
                           '4	阴阳拼版存在时，辅助层生成在外层之外，避免阴阳刷新时报错，Job:515-070AA;'
                           '5	core层机械盲埋孔inn类、dbk类层别生成及制作;'
                           '6	0压的埋孔dbk类inn类层别建立合并至core层机械埋建立，制作方式不变;'
                           '7	外层的辅助层，不添加溶胶区;'
                           '8	防爆孔距离钻孔靶及备用靶距离防呆，6.5mm内删除处理;'
                           '9	双面板的定位角四孔距开料边2mm更改为6mm，按规范更改;'
                           '10	备用标靶添加与五代靶之后，保证五代靶优先放置在板角;'
                           '11	外层CCD靶位使用动态添加，避让钻孔对位靶6.5mm;'
                           '12	芯板开料的盲埋孔，使用板角五孔中的四孔对位，使用对位图形symbol，并增加r0对位点'
                           '13 料号名第八位为N，增加铺铜条：需求3689'
                           '14 防焊ccd，文字自动对位改为动态添加，添加顺序在五代靶—>备用靶->防焊CCD->文字自动对位',
                'url': 'http://192.168.2.120:82/zentao/story-view-3722.html'
                       'http://192.168.2.120:82/zentao/story-view-3696.html'
                       'http://192.168.2.120:82/zentao/story-view-3533.html'
                       'http://192.168.2.120:82/zentao/story-view-3710.html'
            },
            'V2.01': {
                'author': 'song',
                'develop_date': '2021-12-17',
                'publish_date': '2021-12-17',
                'purpose': '1. 分割靶增加外四吧坐标（在短边，inplan数据中增加SIGX1,SIGX2）;'
                           '2. OSP LED板防焊增加开窗，档点增加档油点'
                           '3. 删除板边跑出的sh_csx_pad sh-csx，sh-ipd 应为线路测试pad'
                           '4. 修复由于数据防呆导致的无法跑板边问题.相关料号:567-284A1,B05-366A1',
                'url': 'http://192.168.2.120:82/zentao/story-view-3770.html'
                       'http://192.168.2.120:82/zentao/story-view-3793.html'
                       'http://192.168.2.120:82/zentao/story-view-3766.html'
            },
            'V2.02': {
                'author': 'song',
                'develop_date': '2022-01-05',
                'publish_date': '2022-01-10',
                'purpose': '1. 检验set中的pcs数，不退出，仅提示'
                           '2. 修正外层ccd左下角可能不防呆的情形。料号：B05-369A1'
                           '3. 仅一压的3张PP料号未跑出溶胶区，修正sql中的判断，不排除外层铜箔层。料号：515-028A5'
                           '4. 更新右下角层别标识，避免频繁报不避开',
                'url': 'http://192.168.2.120:82/zentao/story-view-3770.html'
            },
            'V2.03': {
                'author': 'song',
                'develop_date': '2022-01-17',
                'publish_date': '2022-01-17',
                'purpose': '1. 分割料号的线路对位靶，仅能是11字样及22字样，料号：A51006GIA58C1'
                           '2. 喷锡防爆孔跑出，默认1mm. 1-20 按公共脚本修正，喷锡防爆孔孔心距5mm'
                           '3. 修正五代靶的防呆坐标均为负值，即右上角均向下防呆'
                           '4. 01-20 左下角的四角防呆孔，避让靶孔后使用防呆数据'
                           '5. 01-20 蚀刻引线层加对位symbol',
                'url': 'http://192.168.2.120:82/zentao/story-view-3877.html'
                       'http://192.168.2.120:82/zentao/story-view-3793.html'
            },
            'V2.04': {
                'author': 'song',
                'develop_date': '2022-01-26',
                'publish_date': '2022-02-10',
                'purpose': '1.五代靶根据镭射层的介质厚度，介厚<2.1mil使用1通3设计，介厚>=2.1mil使用1通2设计;'
                           '2.需求3899，更改二次文字1、2的预添加位置(错开文字周期字样)',
                'url': 'http://192.168.2.120:82/zentao/story-view-3829.html'
                       'http://192.168.2.120:82/zentao/story-view-3899.html'
            },
            'V2.05': {
                'author': 'song',
                'develop_date': '2022-02-25',
                'publish_date': '2022-03-01',
                'purpose': '1.有镭雕时，用负极性盖住短边文字标靶pad.'
                           '2.3-2 上线多张core增加防叠反二维码，增加barcode类型的添加;',
                'url': 'http://192.168.2.120:82/zentao/story-view-3918.html'
                       'http://192.168.2.120:82/zentao/story-view-3771.html',
            },
            'V2.06': {
                'author': 'song',
                'develop_date': '2022-03-04',
                'publish_date': '2022-03-09',
                'purpose': '1.183系列手机副板,增加了从ERP获取三级产品类型的SQL查询,更改化金板挡点及防焊铺铜.'
                           '2.辅助菲林层不加同心圆,同心圆圆心点大小更改为40mil.'
                           '3.双面板切铜部分修正routx及routy数据为板大小'
                           '4.同心圆部分获取干膜尺寸使用程序中内定变量',
                'url': 'http://192.168.2.120:82/zentao/story-view-4008.html'
                       'http://192.168.2.120:82/zentao/story-view-4002.html',
            },
            'V2.07': {
                'author': 'song',
                'develop_date': '2022-03-16',
                'publish_date': '2022-03-17',
                'purpose': '1.一张core，3张PP仅铆合不融合.'
                           '2.外层辅助菲林也添加溶胶区，周涌钉钉告知，此前变更为版本V2.01',
                'url': 'http://192.168.2.120:82/zentao/story-view-4047.html',
            },
            'V2.08': {
                'author': 'song',
                'develop_date': '2022-03-21',
                'publish_date': '2022-03-23',
                'purpose': '1.InPlan外四靶数据，非分割料号跑出TT靶.'
                           '2.4-1 文字按流程跑出板边四角对位圈'
                           '3.4-1 阻抗条的选化层NPTH孔不套铜'
                           '4.4-1 左下角CCD与防焊对位pad有重合的可能性，做动态避让，无url.'
                           '5.4-1 二次文字时会与镭雕字样重叠，下移3.5.无url'
                           '6.4-8 光板钻带，不核对光板钻孔层。料号：QD1804GI001A1，ERP钻带名称L0-0埋孔',
                'url': 'http://192.168.2.120:82/zentao/story-view-4100.html'
                       'http://192.168.2.120:82/zentao/story-view-3899.html'
                       'http://192.168.2.120:82/zentao/story-view-4135.html',
            },
            'V2.09': {
                'author': 'song',
                'develop_date': '2022-05-08',
                'publish_date': '2022-05-13',
                'purpose': '1.短边TT靶，镭射的定位孔没有在TT靶上，需要改下，B15-098B1'
                           '2.防爆孔取消选化层盖干膜'
                           '3.辅助层不跑出靶孔'
                           '4.跑边带出选化印油层'
                           '5.183系列副板板边外层铺铜增加流胶口'
                           '6.蚀刻引线板边铺铜至set边'
                           '7.周涌提出2nd.inn层定位pin由原来5颗取4颗，不需要跑出左下角一颗孔'
                           '8.2022.05.20字符颜色为两种的判定防呆：白色+黑色，料号：H01104PI016A1',
                           'url': '2.http://192.168.2.120:82/zentao/story-view-4163.html'
                                  '3.http://192.168.2.120:82/zentao/story-view-4229.html'
                                  '4.http://192.168.2.120:82/zentao/story-view-3814.html'
                                  '5.http://192.168.2.120:82/zentao/story-view-4243.html'
                                  '6.http://192.168.2.120:82/zentao/story-view-4280.html',
            },
            'V2.10': {
                'author': 'song',
                'develop_date': '2022-07-26',
                'publish_date': None,
                'purpose': '1. 分割料号，不添加镭射对位孔在外八靶位置 BUg料号：190-173A1'
                           '2.2022-08-23 铝片字样下移6.5-->19.15',
                           'url':'2.http://192.168.2.120:82/zentao/story-view-4542.html'
            },
            'V2.11': {
                'author': 'song',
                'develop_date': '2022-09-16',
                'publish_date': '2022-09-30',
                'purpose': '1.优化双面板dbk'
                           '2.2nd层别未制作防呆'
                           '3.蚀刻引线取消对应防焊8个ccd的对位symbol，sh-dwsig2014',
                'url': '1.http://192.168.2.120:82/zentao/story-view-4611.html'
                       '2.http://192.168.2.120:82/zentao/story-view-4553.html'
                       '3.http://192.168.2.120:82/zentao/story-view-4536.html'
            },
            'V2.12': {
                'author': 'song',
                'develop_date': '2022-10-20',
                'publish_date': None,
                'purpose': '1.正片板边外层铺铜更改'
                           '2.绕单元铺铜条，stamp位置更改至右侧，板边字样套铜区更改，'
                           '3.stamp避让干膜线，同心圆错开设计，选化印油层板边料号名，引入symbol sh-op2'
                           '4.外层靶标样式变更',
                'url': '1.http://192.168.2.120:82/zentao/story-view-4762.html'
                       '2.http://192.168.2.120:82/zentao/story-view-4717.html'
                       '3.http://192.168.2.120:82/zentao/story-view-4695.html'
                       '4.http://192.168.2.120:82/zentao/story-view-4537.html'
            },
            'V2.13': {
                'author': 'lyh',
                'develop_date': '2022-11-22',
                'publish_date': None,
                'purpose': """
                1.VCP镀金系列铜边距金手指位置至少保留30mm，（板边距金手指位置保留20mm，VCP夹具位置板边开窗留铜10+/-1mm）。
                留边方向，按板尺寸规格≤650mm时留短边，＞650mm留长边，其余三边干膜覆盖。 
                依照拼版尺寸变更:开料尺寸≤650mm时，留边与开窗取短边，短边留边需大于30mm，短边开窗依最后一次锣边往内开10mm，如留边不够提示需修改拼版。
                开料尺寸＞650mm时，留边与开窗取长边，长边留边需大于30mm，长边开窗依最后一次锣边往内开10mm，如留边不够提示需修改拼版。
                
                2.跑边程序优化，针对b58系列不区分融合板及非融合板，板边全加长7短5涨缩pad""",
                'url': '1.http://192.168.2.120:82/zentao/story-view-4625.html'
                       '2.http://192.168.2.120:82/zentao/story-view-4499.html'
            },
            'V2.14': {
                'author': 'lyh',
                'develop_date': '2022-11-23',
                'publish_date': '2022-11-28',
                'purpose': """
                1.工程在选化资料板边增加中文标注（第一次，第二次）
                2.选化印油层别命名抓取流程，板边内容依照3814需求，网板板边需要将drl层的板边孔及inn层的孔套开单边15mil做不下油。
                  曝光资料板边取防焊对位ccd，板边不开窗，参考料号：D10-065A1。
                  3814需求优化，网板板边需要将drl层的板边孔及inn层的孔套开单边15mil做不下油
                3.985-077A2，vcut监测孔与机钻CCD重叠时，vcut监测孔未加上。
                  985-077a2，双面板dbk层中间3颗孔需与钻孔层的孔避开6.5mm。
                4.工艺要求，在背钻孔层添加5颗3.175的孔，双面背钻的需双面错开，且还需与通孔的工具孔错开，短边加不下可以加长边。(A86-230A3)""",
                'url': '1.http://192.168.2.120:82/zentao/story-view-4759.html'
                       '2.http://192.168.2.120:82/zentao/story-view-4640.html'
                       '3.http://192.168.2.120:82/zentao/story-view-4467.html'
                       '4.http://192.168.2.120:82/zentao/story-view-4391.html'
            },
            'V2.15': {
                'author': 'lyh',
                'develop_date': '2022-11-28',
                'publish_date': '2022-12-07',
                'purpose': """
                1.优化4.4 hdi新板边，(1)，dld需要放置在40-90的位置，如此位置与其它物件重叠，需提醒。
                  (2)，右上角防呆的dld与右下角的dld防呆距离减少至2mm，现940-764B3防呆距离达到了40mm以上，导致dld的距离板边超出了40-90mm.
                  (3)，dld内靶放置可参考940-764B3修改后的资料位置放置，将内靶放置t靶的两边，保证靶在40-90范围。
                2.(1)防焊板边料号名旁边有正字样，目前都是不用菲林的不需要此字样
                  (2)档点短边下发的w字样也不需要
                3.2022.12.08 Song 更改二次铜标靶极性
                4.2023.02.15 背钻层靶距均为0认为不需要跑出靶孔 job:SD1012GH078B1""",
                'url': '1.http://192.168.2.120:82/zentao/story-view-4865.html'
                       '2.http://192.168.2.120:82/zentao/story-view-4941.html'
            },
            'V2.16': {
                'author': 'lyh',
                'develop_date': '2023-02-20',
                'publish_date': '2023-03-08',
                'purpose': """
                1.短边x方向 放置：涨缩系数代码+料号层次+xy方向系数，  长边y 方向放置： 批号孔  钻孔机台别+日期+人员代码
                  当上述距离压合后的铣边5mm不能满足时；建议按panel边料1/2处 位置如（图1黄色圆圈27mm除以2=13.5） 放置
                2.跑板边识别cdc-1&cds-1，靶标图形依照inplan数据跑出来对应的靶及层别。
                3.优化跑边程序，将etch,gold,linek,xlym板边料号名字框取消，按照档点的板边料号的形式跑出,只需要‘料号名，层别名，日期’即可。
                4.优化跑边程序，将防焊CCD及文字CCD右上角的防呆靶点，两面在防呆一个靶位。
                5.PNL板边设计变更，对应优化脚本 负片板边金手指板 重新切铜""",
                'url': '1.http://192.168.2.120:82/zentao/story-view-4965.html'
                       '2.http://192.168.2.120:82/zentao/story-view-4992.html'
                       '3.http://192.168.2.120:82/zentao/story-view-5085.html'
                       '4.http://192.168.2.120:82/zentao/story-view-5091.html'
                       '5.http://192.168.2.120:82/zentao/story-view-5150.html'
            },
            'V2.17': {
                'author': 'lyh',
                'develop_date': '2023-05-04',
                'publish_date': '2023-05-17',
                'purpose': """
                1.跑Panel时背钻及控深钻位置将通孔四个角的方向孔 其中一个防呆 到背钻及控深钻的靶孔层，大小改为2.0mm        
                2.Led板除外
                3.输出钻带时2.0mm固定放最后一把刀，按T99刀序
                """,
                'url': '1.http://192.168.2.120:82/zentao/story-view-5456.html'
            },
            'V2.18': {
                'author': 'lyh',
                'develop_date': '2023-07-14',
                'publish_date': '',
                'purpose': """
                1.厂内要求追溯码由8码改成13码，只改暗码 symbol 由hdi_orbldi_stamp 变成hdi_orbldi_stamp_1 20230714 by lyh   
                """,
                'url': '1.http://192.168.2.120:82/zentao/story-view-5781.html'
            },
        }
        #      
        # -- 从ERP或者InPlan中获取叠构信息,优先ERP,备用InPlan
        # ----------------------------------------------------------------------------------------------------------
        self.stack_dict = self.ERP.get_ERP_stackup()
        # print json.dumps(self.stack_dict)
        self.parm['lamination'] = self.lamin_data
        if len(self.stack_dict['all_layer']) == 0:
            self.stack_dict = self.InPlan.get_InPlan_stackup()
            # self.parm['lamination'] = self.InPlan.lamination
        if len(self.stack_dict['all_layer']) == 0:
            msg_box = msgBox()
            msg_box.critical(self, '警告', '%s ERP与Inplan中均没有叠构数据，无法自动生成辅助层别！' % self.JOB, QMessageBox.Ok)
            sys.exit()
        # === 2021.09.28 获取inplan的钻孔信息
        self.drill_dict = self.InPlan.get_inplan_drill_info()
        silk_stations = self.InPlan.get_inplan_wz_times()
        if silk_stations:
            self.parm['fir_silk_station'] = silk_stations[0]
            self.parm['sec_silk_station'] = silk_stations[1]
            self.parm['thd_silk_station'] = silk_stations[2]
            self.parm['all_silk_layers'] = silk_stations[3]
        else:
            msg_box = msgBox ()
            msg_box.critical (self, '警告', '%s 无法从文字流程中获取唯一喷墨或印刷站别！' % self.JOB, QMessageBox.Ok)
            sys.exit ()
        if self.parm['sec_silk_station']:
            self.select_silk_times = u'二次'
        if self.parm['thd_silk_station']:
            self.select_silk_times = u'三次'
        self.inplan_drill_layers, self.drill_type_yn = self.InPlan.extract_inplan_drill_layers(self.drill_dict)
        self.laser_config = self.InPlan.get_laser_config()

        self.job_split_config = self.InPlan.get_board_split()
        self.parm['job_split'] = self.job_split_config
        self.parm['create_drill_layers'] = self.inplan_drill_layers
        self.parm['drill_type_yn'] = self.drill_type_yn
        self.parm['laser_config'] = self.laser_config
        self.split_via, self.split_pth = self.InPlan.get_split_drills(self.drill_dict)
        # print json.dumps(self.drill_type_yn,indent=2)
        
        self.layer_cu_info = self.InPlan.get_Layer_Info()
        self.parm["layer_cu_info"] = self.layer_cu_info
        
        self.stackup_pp_foil_info = self.InPlan.get_stackup_pp_foil_info()
        self.parm["stackup_pp_foil_info"] = self.stackup_pp_foil_info
        
        # --多次压合捞边数据只从inplan中取,更改此处数据获取为已有的结果  
        self.parm['lam_rout'] = [
            (int(i['PROCESS_NUM']) - 1, float(i['PNLROUTX']) * 25.4, float(i['PNLROUTY']) * 25.4) for i in
            self.lamin_data]
        
        self.parm['lam_rout_new'] = [
            (int(i['PROCESS_NUM']) - 1, float(i['PNLROUTX']) * 25.4, float(i['PNLROUTY']) * 25.4,
             i['FROMLAY'], i['TOLAY']) for i in self.lamin_data]

        all_etch_layer = self.stack_dict['all_layer']
        pp3_layer = self.stack_dict['3pp_layer']
        
        self.parm['pp2_layer'] = self.stack_dict['2pp_layer']        
        
        assist_layer, assist_side, assist_ref, all_etch_layer = self.deal_assist_layer(all_etch_layer)
        JB_layers = self.stack_dict['JB_layer']
        self.parm['all_etch_layer'] = all_etch_layer
        self.parm['pp3_layer'] = pp3_layer
        
        # 检测背钻是否有3.175的定位孔 20221123 V2.14
        self.parm['bd_has_3175_dw_hole'] = self.InPlan.get_bd_hole_condition(self.drill_dict)
        
        #检测限位孔是否和料号孔为同一把刀 20230316 by lyh
        self.parm['xianwei_hole_same_to_jobname_hole'] = self.InPlan.check_xianwei_hole_condition(self.drill_dict)

        # 辅助层别的处理
        # self.parm['pp2_layer'] = pp2_layer
        self.parm['assist_layer'] = assist_layer
        self.parm['assist_side'] = assist_side
        self.parm['assist_ref'] = assist_ref
        self.parm['JB_layers'] = JB_layers
        # --计算core的张数，story-view-486线圈板锣铜块能用到此参数
        core_count = len(JB_layers) / 2
        self.parm['core_count'] = core_count
        #
        tail_lamin_info = [i for i in self.lamin_data if (i['PROCESS_NUM'] - 1) == self.yh_num][0]
        self.parm['panel_x_InPlan'] = tail_lamin_info['PNLXINCH'] * 25.4
        self.parm['panel_y_InPlan'] = tail_lamin_info['PNLYINCH'] * 25.4
        self.parm['rout_x_InPlan'] = tail_lamin_info['PNLROUTX'] * 25.4
        self.parm['rout_y_InPlan'] = tail_lamin_info['PNLROUTY'] * 25.4

        # === 使用需要添加铆钉的层别的最小干膜尺寸进行铆钉位置添加的依据
        md_pnl_x = self.parm['panel_x_InPlan'] - 4
        md_pnl_y = self.parm['panel_y_InPlan'] - 4

        # ===归类干膜数据,干膜数据包含1压内层
        gm_array = []
        # self.parm['lam_rout'] = [(int(i['PROCESS_NUM']) - 1,float(i['PNLROUTX']) * 25.4, float(i['PNLROUTY'])*25.4) for i in self.lamin_data]
        # print json.dumps(self.lamin_data, indent=2)
        # print tmp_lamin_num
        # print json.dumps(self.sqlDic, indent=2)
        # print len(self.sqlDic)
        max_lamin_num = max([i['PROCESS_NUM'] for i in self.lamin_data])
        for tmp_lamin_num in range(max_lamin_num):
            # print json.dumps(self.lamin_data ,indent=2)
            print tmp_lamin_num
            # print json.dumps(self.sqlDic ,indent=2)
            # print len(self.sqlDic)
            if len(self.sqlDic) <= 2 and len(self.lamin_data) == 1:
                # === 增加双面板选项 ===
                current_gm_size = [i['gm_inch'] for i in self.sqlDic if int(i['lamin_num']) == 0][0] * 25.4
            else:
                current_gm_size = [i['gm_inch'] for i in self.sqlDic if int(i['lamin_num']) == tmp_lamin_num][0] * 25.4
            if tmp_lamin_num == 0 or (len(self.sqlDic) <= 2 and len(self.lamin_data) == 1):
                # 开料芯板或双面板
                input_rout_x = self.parm['panel_x_InPlan']
                input_rout_y = self.parm['panel_y_InPlan']
            else:
                input_rout_x = [i[1] for i in self.parm['lam_rout'] if i[0] == tmp_lamin_num][0]
                input_rout_y = [i[2] for i in self.parm['lam_rout'] if i[0] == tmp_lamin_num][0]
            # === 判断干膜线加在长边还是短边 ===
            if input_rout_x < current_gm_size <= input_rout_y:
                add_gm_side = 'updown'
                gm_startx = (self.parm['panel_x_InPlan'] - input_rout_x) * 0.5
                gm_starty = (self.parm['panel_y_InPlan'] - current_gm_size) * 0.5
                gm_endx = gm_startx + input_rout_x
                gm_endy = gm_starty + current_gm_size
                gm_size_x = gm_endx - gm_startx
                gm_size_y = gm_endy - gm_starty
            elif current_gm_size <= input_rout_x:
                add_gm_side = 'leftright'
                gm_startx = (self.parm['panel_x_InPlan'] - current_gm_size) * 0.5
                gm_starty = (self.parm['panel_y_InPlan'] - input_rout_y) * 0.5
                gm_endx = gm_startx + current_gm_size
                gm_endy = gm_starty + input_rout_y
                # gm_endy = gm_endx - gm_startx
                gm_size_x = gm_endx - gm_startx
                gm_size_y = gm_endy - gm_starty
                msg_box = msgBox()
                msg_box.warning(self, '警告',
                                '压合:%s 干膜尺寸:%s小于短边成型尺寸%s,请判断是否异常!' % (tmp_lamin_num, current_gm_size, input_rout_x),
                                QMessageBox.Ok)
                add_gm_side = 'leftright'

            else:
                msg_box = msgBox()
                msg_box.warning(self, '警告', '压合:%s干膜尺寸:%s 无法确认加在长边还是短边!' % (tmp_lamin_num, current_gm_size),
                                QMessageBox.Ok)

            cur_dict = dict(lamin_num=tmp_lamin_num, add_gm_side=add_gm_side, gm_startx=gm_startx, gm_starty=gm_starty,
                            gm_endx=gm_endx, gm_endy=gm_endy, gm_size_x=gm_size_x, gm_size_y=gm_size_y)
            gm_array.append(cur_dict)
        self.parm['gm_array'] = gm_array

        if self.parm['core_count'] > 1:
            self.hdi_contain_tag_layer += [i['LAYER_NAME'] for i in self.sqlDic if i['lamin_num'] == 0]
        if len(self.parm['pp3_layer']) > 0:
            # V1.08 三张PP的最外两层不加溶胶区 示例料号：781-059A1、781-050B2、503-097a2
            self.hdi_contain_tag_layer += self.parm['pp3_layer'][1:-1]

        for layer_m in self.hdi_contain_tag_layer:
            cur_gm_size = [i['gm_inch'] for i in self.sqlDic if i['LAYER_NAME'] == layer_m][0] * 25.4
            tmp_lamin_num = [i['lamin_num'] for i in self.sqlDic if i['LAYER_NAME'] == layer_m][0]
            input_rout_x = self.rout_x
            input_rout_y = self.rout_y
            if tmp_lamin_num == 0:
                input_rout_x = self.parm['panel_x_InPlan']
                input_rout_y = self.parm['panel_y_InPlan']
            else:
                input_rout_x = self.lamin_data[tmp_lamin_num - 1]['PNLROUTX'] * 25.4
                input_rout_y = self.lamin_data[tmp_lamin_num - 1]['PNLROUTY'] * 25.4

            add_gm_side = ''
            # === 判断干膜线加在长边还是短边 ===
            if cur_gm_size <= input_rout_y and cur_gm_size > input_rout_x:
                add_gm_side = 'updown'
                # 取较小值
                if md_pnl_x > input_rout_x or md_pnl_y > cur_gm_size:
                    md_pnl_x = input_rout_x
                    md_pnl_y = cur_gm_size
            elif cur_gm_size <= input_rout_x:

                # msg_box = msgBox()
                # msg_box.warning(self, '警告', '压合:%s 干膜尺寸:%s小于短边留边,请判断是否异常!' % (tmp_lamin_num,cur_gm_size), QMessageBox.Ok)
                # # check_result = False
                # add_gm_side = 'leftright'
                # 取较小值
                if md_pnl_x > cur_gm_size or md_pnl_y > input_rout_y:
                    md_pnl_x = cur_gm_size
                    md_pnl_y = input_rout_y
            else:
                pass
                # msg_box = msgBox()
                # msg_box.warning(self, '警告', '压合:%s干膜尺寸:%s 无法确认加在长边还是短边!' % (tmp_lamin_num,cur_gm_size), QMessageBox.Ok)
        # === TODO check 基板层别是否包含外层，如包含则应存在辅助层别，应添加入self.hdi_contain_tag_layer
        # self.hdi_contain_tag_layer = list (set (self.hdi_contain_tag_layer))
        if self.parm['core_count'] > 1:
            for jlayer in JB_layers:
                # === 基板层别和辅助层别对应，则添加进标靶层别 ===
                for as_layer in assist_layer:
                    as_cut_layer = as_layer.split('-')[0]
                    if as_cut_layer == jlayer:
                        self.hdi_contain_tag_layer.append(as_layer)
                if jlayer != 'l1' and jlayer != all_etch_layer[-1]:
                    self.hdi_contain_tag_layer.append(jlayer)

        self.hdi_contain_tag_layer = list(set(self.hdi_contain_tag_layer))

        self.parm['hdi_contain_tag_layer'] = self.hdi_contain_tag_layer
        self.update_parameter(panel_x=md_pnl_x, panel_y=md_pnl_y, core_count=self.parm['core_count'])

    def set_UI_by_JOB(self):
        """
        通过料号DO_INFO获取信息并填充主界面参数
        :return:
        :rtype:
        """
        # 优先通过INPLAN信息判断, ynh20231030
        # --通过料号名第八码判定是否为金手指
        try:
            if 'GF' in self.job_data['表面处理']:
                self.sel_jsz_yes = True
            else:
                self.sel_jsz_yes = False

        except:
            if self.JOB[7] in ['y', 'r', 'h', 'l', 's']:
                self.sel_jsz_yes = True
            else:
                self.sel_jsz_yes = False
        

        # --通过料号名第七码判定是否为化金板
        # --第七码是e的为化金+碳油流程,2021.2.17刘文东要求添加
        # 增加选化o识别
        if self.JOB[6] in ['g', 'e', 'o']:
            self.add_hj_panel_yes = True
            
        # === 周涌2021.08.03要求gh默认勾选金手指 === 2021.09.24 修正gh-> ph === 2021.12.09 周涌钉钉需求，增加gh ===
        # === 2021.12.16 周涌钉钉需求，增加gy
        if self.JOB[6:8] in ['ph', 'gh', 'gy']:
            self.sel_finger_yes = True
            self.On_sel_finger_yes()

        # --从料号层别判断是否是大板vcut,如果有vcut层则为是
        info = self.GEN.DO_INFO('-t layer -e %s/panel/vcut -d EXISTS' % self.JOB)
        # if info['gEXISTS'] == "yes":
        #     self.sel_vut_yes = True
        # print json.dumps(self.job_data,indent=2)
        if self.job_data['大板VCUT'] == 1:
            self.sel_vut_yes = True
            if info['gEXISTS'] == "no":
                msg_box = msgBox()
                msg_box.critical(self, '警告', 'Inplan获取料号：%s为大板Vcut，但未设计vcut层别\n程序退出！' % self.JOB, QMessageBox.Ok)
                sys.exit()
        
        self.anylayer = "no"
        if self.job_data['是否任意互连ELIC'] == 1:
            self.anylayer = "yes"
        
        self.parm['anylayer'] = self.anylayer
        # --从料号info中获取单只名称
        info = self.GEN.DO_INFO('-t job -e %s -m script -d STEPS_LIST' % self.JOB)
        array_step = "edit"
        icg_list = []
        for step_name in info['gSTEPS_LIST']:
            if step_name == "set":
                array_step = "set"
            if re.match('icg', step_name):
                icg_list.append(step_name)
        self.array_step = array_step
        self.parm['icg_list'] = icg_list

        # --从料号info中获取单只尺寸
        info = self.GEN.DO_INFO('-t step -e %s/%s -m script -d PROF_LIMITS' % (self.JOB, array_step))
        xmin = info['gPROF_LIMITSxmin']
        ymin = info['gPROF_LIMITSymin']
        xmax = info['gPROF_LIMITSxmax']
        ymax = info['gPROF_LIMITSymax']
        array_x_size = float(xmax) - float(xmin)
        array_y_size = float(ymax) - float(ymin)
        self.array_x_size = array_x_size
        self.array_y_size = array_y_size

        # === 2021.07.23 增加无通孔设计的板边支持 ===
        # --从料号层别判断是否是大板vcut,如果有vcut层则为是
        # === 从料号中获取切片via及切片pth 更改为SQL获取 ===
        # info = self.GEN.DO_INFO ('-t layer -e %s/panel/drl -d EXISTS' % self.JOB)
        # if info['gEXISTS'] == "yes":
        #     # === 获取split_via 与 split_pth
        #     info = self.GEN.DO_INFO ('-t layer -e %s/%s/%s -m script -d TOOL' % (self.JOB, 'edit', self.drl))
        #     for i, tool_type in enumerate (info['gTOOLtype']):
        #         tool_size = float (info['gTOOLdrill_size'][i]) * 0.001
        #         if tool_type == 'via':
        #             if self.split_via == 0 or self.split_via == "":
        #                 self.split_via = tool_size
        #             else:
        #                 if tool_size < self.split_via:
        #                     self.split_via = tool_size
        #         elif tool_type == 'plated':
        #             if self.split_pth == 0 or self.split_pth == "":
        #                 self.split_pth = tool_size
        #             else:
        #                 if tool_size < self.split_pth:
        #                     self.split_pth = tool_size
        # --从料号info中获取panel长宽
        panel_x = ''
        panel_y = ''
        info = self.GEN.DO_INFO('-t step -e %s/panel -d EXISTS' % self.JOB)
        if info['gEXISTS'] == "yes":
            info = self.GEN.DO_INFO('-t step -e %s/panel -m script -d PROF_LIMITS' % self.JOB)
            panel_x = float(info['gPROF_LIMITSxmax'])
            panel_y = float(info['gPROF_LIMITSymax'])
        self.panel_x = panel_x
        self.panel_y = panel_y

        # --第7码g代表化金板,一厂化金保留铜皮
        # --第七码是e的为化金+碳油流程,2021.2.17刘文东要求添加
        if self.JOB[6] in ['g', 'e']:
            if self.sh_site == u'胜宏一厂' and panel_y > 620:
                self.sel_mid_rout_long = True
        self.parm['sel_mid_rout_long'] = self.sel_mid_rout_long

        # --经纬向从json文件中读取，更改为从SQL中获取
        # self.json_dict = self.read_file ()
        # if self.json_dict.has_key ('wei_xiang'):
        #     self.wei_xiang = self.json_dict['wei_xiang']

        if self.job_data['X经纬'] == '纬向':
            self.wei_xiang = u'纬向X'
        elif self.job_data['Y经纬'] == '纬向':
            self.wei_xiang = u'纬向Y'
        else:
            self.json_dict = self.read_file()
            if self.json_dict.has_key('wei_xiang'):
                self.wei_xiang = self.json_dict['wei_xiang']

        # --更新或计算铆钉参数
        self.parm['array_step'] = array_step
        self.parm['panel_x'] = self.panel_x
        self.parm['panel_y'] = self.panel_y
        # self.update_parameter(panel_x=panel_x,panel_y=panel_y,core_count=self.parm['core_count'])
        # === 2021.09.07 由于数据库写入使用保留三位小数 ===
        # 取消此提示 后面上传数据库直接保留三位小数 20230807 by lyh
        #if len(str(self.panel_x).split('.')[1]) >= 4 or len(str(self.panel_y).split('.')[1]) >= 4:
            #msg_box = msgBox()
            #msg_box.warning(self, '警告', 'Panel 尺寸X:%s 尺寸Y:%s \n超出四位小数，\n请MI重新核定数据!' % (self.panel_x, self.panel_y),
                            #QMessageBox.Ok)

    def define_variables(self):
        """
        定义添加symbol所凭借的变量
        :return:
        :rtype:
        """
        # --定义panel长边之和的情况.
        panel_case = "no"
        short_he_value = "no"
        panel_all_value = self.parm['sr_xmin'] + self.parm['profile_xmax'] - self.parm['sr_xmax']
        # --20210203李家兴修改此规则,留边应该为压合留边,而不是开料留边,保持与InPlan一致,20210118新规则,所有板层,以开料尺寸做拼版
        panel_all_value = self.rout_x - (self.parm['sr_xmax'] - self.parm['sr_xmin'])
        if panel_all_value >= 11.96 and panel_all_value < 14.96:
            panel_case = "case1"
        if panel_all_value >= 14.96 and panel_all_value < 17.96:
            panel_case = "case2"
        self.parm['panel_case'] = panel_case

        # --定义是否窄短边
        panel_all_value_y = self.rout_y - (self.parm['sr_ymax'] - self.parm['sr_ymin'])
        if panel_all_value_y < 14:
            short_he_value = "yes"
        self.parm['short_he_value'] = short_he_value

        # --定义次外层
        sub_outer = []
        assist_layer = self.parm['assist_layer']
        # --两层板有辅助层时,job_signal_numbers为4,但是并没有次外层
        true_signal_numbers = self.job_signal_numbers - len(assist_layer)
        if true_signal_numbers >= 4:
            sub_outer.append("l2")
            sub_outer.append("l%s" % (true_signal_numbers - 1))
        self.parm['sub_outer'] = sub_outer
        self.parm['true_signal_numbers'] = true_signal_numbers

        # === HDI 定义以下两个变量为no 2021.06.30
        add_three_plant = "no"
        self.parm['add_first_plant'] = 'no'
        self.parm['add_three_plant'] = 'no'
        #
        # --外层是否铺铜
        put_copper_out = "yes"
        # --一厂也有一次铜板边,所以add_first_plant=="no"不对
        # if self.parm['sel_jsz'] == "否" and add_first_plant == "no" and self.parm['flow_content'] == '一次铜':
        if self.parm['sel_jsz'] == "否" and self.parm['flow_content'] == '一次铜':
            put_copper_out = "no"
            if (self.board_thick <= 0.5 and self.parm['add_hj_panel'] == "是") or \
               (self.board_thick <= 0.4 and self.parm['add_hj_panel'] == "否"):
                put_copper_out = 'yes'
            # === V2.06 183系列手机副板 板边铺铜 ===
            if self.judge_phone_subplate:
                put_copper_out = 'yes'

        self.parm['put_copper_out'] = put_copper_out
        #
        # --挡点是否铺铜
        # --第七码是e的为化金+碳油流程,2021.2.17刘文东要求添加
        pn_seven = self.JOB[6]
        put_copper_md = "yes"
        if add_three_plant == 'no' or self.parm['flow_content'] == '二次铜':
            if pn_seven in ['g', 'h', 'l', 'e']:
                put_copper_md = "no"
        self.parm['put_copper_md'] = put_copper_md
        #
        # --定义add_number_x,依据铆钉X来确定,.5的小数为0.25，否则为0
        mao_pin_x = self.parm['mao_pin_x']
        mao_pin_y = self.parm['mao_pin_y']
        add_number_x = 0
        add_number_y = 0
        if mao_pin_x:
            # --考虑四层板mao_pin_x为空值的情况
            if self.parm['ape3000_base'] == '0.25inch':
                if math.modf(mao_pin_x)[0] == 0.0 or math.modf(mao_pin_x)[0] == 0.5:
                    # --APE3000 0.25进制,小数位为0或者0.5,中心在profile中心
                    add_number_x = 0
                else:
                    # --APE3000 0.25进制,小数位为0.25或者0.75,中心在profile中心偏左0.125inch
                    add_number_x = 0.125
            else:
                if math.modf(mao_pin_x)[0] == 0.0:
                    # --PE3000 0.5进制,小数位为0,中心在profile中心
                    add_number_x = 0
                else:
                    # --PE3000 0.5进制,小数位为0.5,中心在profile中心偏左0.25inch
                    add_number_x = 0.25
        if mao_pin_y:
            # --考虑四层板mao_pin_y为空值的情况
            if self.parm['ape3000_base'] == '0.25inch':
                if math.modf(mao_pin_y)[0] == 0.0 or math.modf(mao_pin_y)[0] == 0.5:
                    # --APE3000 0.25进制,小数位为0或者0.5,中心在profile中心
                    add_number_y = 0
                else:
                    # --APE3000 0.25进制,小数位为0.25或者0.75,中心在profile中心偏下0.125inch
                    add_number_y = 0.125
            else:
                if math.modf(mao_pin_y)[0] == 0.0:
                    # --PE3000 0.5进制,小数位为0,中心在profile中心
                    add_number_y = 0
                else:
                    # --PE3000 0.5进制,小数位为0.5,中心在profile中心偏左0.25inch
                    add_number_y = 0.25
        panel_x_inch = float(self.panel_x) * 0.03937
        panel_y_inch = float(self.panel_y) * 0.03937
        ck_fid_x1 = panel_x_inch * 0.5 + 1.499997 - add_number_x
        ck_fid_y4 = panel_y_inch * 0.5 + 1.6877919 - add_number_y
        self.parm['add_number_x'] = add_number_x
        self.parm['add_number_y'] = add_number_y
        self.parm['ck_fid_x1'] = ck_fid_x1
        self.parm['ck_fid_y4'] = ck_fid_y4

    def write_file(self):
        """
        用json把参数字典直接写入user文件夹中的panel_parameter.json
        json_str = json.dumps(self.parm)将字典dump成string的格式
        :return:
        :rtype:
        """
        # 将收集到的数据以json的格式写入user/param
        stat_file = os.path.join(self.userDir, 'panel_parameter.json')
        fd = open(stat_file, 'w')
        json.dump(self.parm, fd, ensure_ascii=False, indent=4, separators=(', ', ': '), sort_keys=True)
        fd.close()

    def read_file(self):
        """
        用json从user文件夹中的panel_parameter.json中读取字典
        :return:
        :rtype:
        """
        json_dict = {}
        stat_file = os.path.join(self.userDir, 'panel_parameter.json')
        if os.path.exists(stat_file):
            fd = open(stat_file, 'r')
            json_dict = json.load(fd)
            fd.close()
        return json_dict

    def sr_popup_del_step(self):
        """
        删除Panel中自动拼进的 drl fa lp 2nd step
        :return:
        :rtype:
        """
        Burry_Reg = re.compile(r'^[b][0-9][0-9]?-?[0-9][0-9]?$')
        Machine_Reg = re.compile(r'^m[0-9][0-9]?-?[0-9][0-9]?$')
        delete_i = 1
        info = self.GEN.DO_INFO('-t step -e %s/panel -m script -d SR' % self.JOB)
        for i, step in enumerate(info['gSRstep']):
            if step in ['drl', 'fa', 'lp', '2nd']:
                self.GEN.COM('sr_tab_del,line=%s' % delete_i)
                delete_i -= 1
            elif Machine_Reg.match(step):
                # --匹配机械钻孔尾孔模块
                self.GEN.COM('sr_tab_del,line=%s' % delete_i)
                delete_i -= 1
            elif Burry_Reg.match(step):
                # --匹配埋孔尾孔模块
                self.GEN.COM('sr_tab_del,line=%s' % delete_i)
                delete_i -= 1
            delete_i += 1

    def update_parameter(self, panel_x=0.0, panel_y=0.0, core_count=0, ape3000_base='0.5inch'):
        """
        计算铆钉X和Y
        :return:
        :rtype:
        """
        mao_pin_base = float(ape3000_base.strip('inch'))
        mao_pin_x = ""
        mao_pin_y = ""
        if core_count < 2 and len(self.parm['pp3_layer']) == 0:
            # --两张core以上的才需要铆钉组合
            self.parm['mao_pin_x'] = mao_pin_x
            self.parm['mao_pin_y'] = mao_pin_y
            return mao_pin_x, mao_pin_y
        info = self.GEN.DO_INFO('-t step -e %s/panel -m script -d SR_LIMITS' % self.JOB)
        # --根据排版大小计算mao_pin_x,必须是0.5inch的整数倍
        panel_x_inch = float(panel_x) * 0.03937
        panel_x_integer = math.modf(panel_x_inch)[1]
        panel_x_decimal = math.modf(panel_x_inch)[0]
        if ape3000_base == '0.5inch':
            if panel_x_decimal > 0.50:
                mao_pin_x = panel_x_integer + 1
            else:
                mao_pin_x = panel_x_integer + 0.5
        else:
            if panel_x_decimal > 0.75:
                mao_pin_x = panel_x_integer + 1
            elif panel_x_decimal > 0.50:
                mao_pin_x = panel_x_integer + 0.75
            elif panel_x_decimal > 0.25:
                mao_pin_x = panel_x_integer + 0.5
            else:
                mao_pin_x = panel_x_integer + 0.25

        # --实际添加铆钉时，会将mao_pin_x的坐标减0.75再添加
        mao_pin_LR = mao_pin_x - 0.75
        mao_pin2profile = (panel_x_inch - mao_pin_LR) * 0.5 * 25.4
        if ape3000_base == '0.5inch':
            if mao_pin2profile < 5.8:
                # --距profile不足5.8mm时，内缩0.5inch,单边0.25inch
                mao_pin_LR = mao_pin_LR - mao_pin_base
                mao_pin2profile = (panel_x_inch - mao_pin_LR) * 0.5 * 25.4
                # --距排版的距离是否大于5.8mm.铆钉中心距profile与距排版之和正好等于gSR_LIMITSxmin
                mao_pin2SR = float(info['gSR_LIMITSxmin']) - mao_pin2profile
                if mao_pin2SR >= 5.8:
                    mao_pin_x = mao_pin_x - mao_pin_base
        else:
            mao_pin2SR = float(info['gSR_LIMITSxmin']) - mao_pin2profile
            # --依据板边设计准则5.2要求,长边铆钉距排版必须大于7.5mm(同梁涛商议6.5mm较为合理)
            if mao_pin2SR < 6.5:
                mao_pin_x = mao_pin_x + mao_pin_base

        # --根据排版大小计算mao_pin_y,必须是0.5inch的整数倍
        panel_y_inch = float(panel_y) * 0.03937
        panel_y_integer = math.modf(panel_y_inch)[1]
        panel_y_decimal = math.modf(panel_y_inch)[0]
        if ape3000_base == '0.5inch':
            if panel_y_decimal > 0.50:
                mao_pin_y = panel_y_integer + 1
            else:
                mao_pin_y = panel_y_integer + 0.5
        else:
            if panel_y_decimal > 0.75:
                mao_pin_y = panel_y_integer + 1
            elif panel_y_decimal > 0.50:
                mao_pin_y = panel_y_integer + 0.75
            elif panel_y_decimal > 0.25:
                mao_pin_y = panel_y_integer + 0.5
            else:
                mao_pin_y = panel_y_integer + 0.25

        # --实际添加铆钉时，会将mao_pin_x的坐标减0.75再添加
        mao_pin_UD = mao_pin_y - 0.75
        mao_pin2profile = (panel_y_inch - mao_pin_UD) * 0.5 * 25.4
        if ape3000_base == '0.5inch':
            if mao_pin2profile < 5.8:
                # --距profile不足5.8mm时，内缩0.5inch,单边0.25inch
                mao_pin_UD = mao_pin_UD - mao_pin_base
                mao_pin2profile = (panel_y_inch - mao_pin_UD) * 0.5 * 25.4
                # --距排版的距离是否大于5.8mm.铆钉中心距profile与距排版之和正好等于gSR_LIMITSymin
                mao_pin2SR = float(info['gSR_LIMITSymin']) - mao_pin2profile
                if mao_pin2SR >= 5.8:
                    mao_pin_y = mao_pin_y - mao_pin_base
        else:
            mao_pin2SR = float(info['gSR_LIMITSymin']) - mao_pin2profile
            # --依据板边设计准则5.2要求,短边铆钉距排版必须大于4mm
            if mao_pin2SR < 4.0:
                mao_pin_y = mao_pin_y + mao_pin_base
        self.mao_pin_x = mao_pin_x
        self.mao_pin_y = mao_pin_y
        self.mao_pin_y_org = mao_pin_y
        self.parm['mao_pin_x'] = mao_pin_x
        self.parm['mao_pin_y'] = mao_pin_y
        return True

    def unlock_panel_ui(self):
        """
        点击test时要求输入解锁密码,初始密码为1234
        :return:
        :rtype:
        """
        inputDialog = QInputDialog(self)
        inputDialog.setOkButtonText(u'解锁')
        inputDialog.setCancelButtonText(u'退出')
        inputDialog.setLabelText(u'请输入解锁密码:')
        inputDialog.setWindowTitle(u'输入密码解锁')
        inputDialog.setTextEchoMode(QLineEdit.Password)
        if inputDialog.exec_():
            # --如果点击了ok按钮
            text = inputDialog.textValue()
            if text != '1234':
                msg_box = msgBox()
                msg_box.critical(self, '密码错误', '密码错误无法解锁界面锁定项！', QMessageBox.Ok)
                # self.test_panel()
            else:
                # --密码输入正确，与正式一样运行
                self.testButton_clicked = True
                self.set_ui_enable(status=True)
                # self.clickApply()

    def check_parameter(self):
        """
        检查界面参数
        :return:
        :rtype:
        """
        check_result = True
        styleSheet_black = 'QLabel{color: black}'
        styleSheet_red = 'QLabel{color: red}'
        # === 取消此检测 ===
        # if not self.attention_for_job_name():
        #     # --如果料号名都不是正式料号名，返回False
        #     check_result = False

        # === 2021.07.28 增加检测，镭射层别命名是否标准，否则中断
        if not self.checkBlindBuriedLayerName():
            check_result = False

        if self.job_signal_numbers >= 4:
            if self.rout_x == '':
                # --仅限输入为空的情况，输入为零时，后面会有<100的防呆
                self.ui.label_rout_x.setStyleSheet(styleSheet_red)
                msg_box = msgBox()
                msg_box.warning(self, '警告', '请输入锣边后的尺寸X值!', QMessageBox.Ok)
                check_result = False
            if self.rout_y == '' or self.rout_y == 0:
                # --仅限输入为空的情况，输入为零时，后面会有<100的防呆
                self.ui.label_rout_y.setStyleSheet(styleSheet_red)
                msg_box = msgBox()
                msg_box.warning(self, '警告', '请输入锣边后的尺寸Y值!', QMessageBox.Ok)
                check_result = False
            if self.rout_x < 100 or self.rout_y < 100:
                # --包括输入为零的情况
                if self.rout_x < 100:
                    self.ui.label_rout_x.setStyleSheet(styleSheet_red)
                if self.rout_y < 100:
                    self.ui.label_rout_y.setStyleSheet(styleSheet_red)
                msg_box = msgBox()
                msg_box.warning(self, '警告', '请输出正确的锣边尺寸；提醒：不要输入锣掉的尺寸，要输入锣边后的尺寸', QMessageBox.Ok)
                check_result = False
        if self.job_signal_numbers == 4:
            if self.rout_x == self.panel_x or self.rout_y == self.panel_y:
                # --四层板锣边后的尺寸和开料尺寸一样
                self.ui.label_rout_x.setStyleSheet(styleSheet_red)
                # --20210118新规则,所有板层,以开料尺寸做拼版
                msg_box = msgBox()
                msg_box.warning(self, '警告', '四层板锣边后的尺寸和开料尺寸一样，请检查', QMessageBox.Ok)
                check_result = False
        if (self.job_signal_numbers >= 6 and self.parm['core_count'] >= 2) or len(self.parm['pp3_layer']) > 0:
            if self.mao_pin_x == '' or self.mao_pin_x == 0:
                self.ui.label_mao_pin_x.setStyleSheet(styleSheet_red)
                msg_box = msgBox()
                msg_box.warning(self, '警告', '铆钉数据X值不能为空!', QMessageBox.Ok)
                check_result = False
            else:
                panel_x_inch = float(self.panel_x) * 0.03937
                sr_xmin = self.parm['sr_xmin']
                mao_pin_base = float(self.ape3000_base.strip('inch'))
                if mao_pin_base == 0.25:
                    # 依据板边设计准则5.2要求长边铆钉中心距内profile必须>7.5mm(考虑长边留边只有12mm,同梁涛商议设为6.5mm较合适),
                    # 距开料边5.5mm(3.5mm只能保证铆钉图形不出开料边)
                    mao_pin2SR_min = 6.5
                    mao_pin2profile_min = 3.5
                else:
                    # --slot槽中心到边5.08mm
                    mao_pin2SR_min = 5.8
                    mao_pin2profile_min = 5.8
                mao_pin_LR = self.mao_pin_x - 0.75
                mao_pin2profile = (panel_x_inch - mao_pin_LR) * 0.5 * 25.4
                mao_pin2SR = sr_xmin - mao_pin2profile
                mao_pin_x_decimal = math.modf(self.mao_pin_x)[0]
                if sr_xmin < 10.16:
                    # --10.16=5.08+5.08
                    msg_box = msgBox()
                    msg_box.critical(self, '错误', 'x方向留边太小,至少要10.16才可以加下铆钉symbol', QMessageBox.Ok)
                    check_result = False
                if mao_pin2SR < mao_pin2SR_min:
                    msg_box = msgBox()
                    msg_box.critical(self, '错误', '铆钉x的值太小,铆钉开花可能会进板内,请加大%s' % mao_pin_base, QMessageBox.Ok)
                    check_result = False
                if mao_pin2profile < mao_pin2profile_min:
                    msg_box = msgBox()
                    msg_box.critical(self, '错误', '铆钉x的值太大,会出板外,请减少%s' % mao_pin_base, QMessageBox.Ok)
                    # --参考料号338/423a1
                    # check_result = False
                if mao_pin_x_decimal % mao_pin_base != 0 and mao_pin_x_decimal != 0.0:
                    msg_box = msgBox()
                    msg_box.critical(self, '错误', '铆钉x的值必须是%s的整数倍！' % mao_pin_base, QMessageBox.Ok)
                    check_result = False
            if self.mao_pin_y == '' or self.mao_pin_y == 0:
                self.ui.label_mao_pin_y.setStyleSheet(styleSheet_red)
                msg_box = msgBox()
                msg_box.warning(self, '警告', '铆钉数据Y值不能为空!', QMessageBox.Ok)
                check_result = False
            else:
                panel_y_inch = float(self.panel_y) * 0.03937
                mao_pin_base = float(self.ape3000_base.strip('inch'))
                if mao_pin_base == 0.25:
                    # 依据板边设计准则5.2要求长边铆钉中心距内profile必须>4mm(只铆长边),距开料3.5mm
                    mao_pin2SR_min = 4
                    mao_pin2profile_min = 3.5
                else:
                    # --slot槽中心到边5.08mm
                    mao_pin2SR_min = 5.8
                    mao_pin2profile_min = 5.8
                sr_ymin = self.parm['sr_ymin']
                mao_pin_UD = self.mao_pin_y - 0.75
                mao_pin2profile = (panel_y_inch - mao_pin_UD) * 0.5 * 25.4
                mao_pin2SR = sr_ymin - mao_pin2profile
                mao_pin_y_decimal = math.modf(self.mao_pin_y)[0]

                # --定义xa, xb, ya, yb的长度 : xa->top xb->bot ya->right yb->left
                xa = mao_pin_UD * 0.5
                xb = xa
                mdk_y1 = (panel_y_inch * 0.5 - xb) * 25.4
                # --TODO 计算短边铆钉到内sr的距离,y方向根据到内profile的大小有三种不同symbol可以添加,最小3.8mm
                rm_to_sr_distan = sr_ymin - mdk_y1
                if rm_to_sr_distan < 7.5 and rm_to_sr_distan >= 3.8:
                    top_up_mdk = bot_up_mdk = 'rm_dw_topqie'
                    top_down_mdk = bot_down_mdk = 'rm_dw_botqie'
                elif rm_to_sr_distan >= 7.5 and rm_to_sr_distan < 9:
                    top_up_mdk = bot_up_mdk = 'rm_dw_topmin'
                    top_down_mdk = bot_down_mdk = 'rm_dw_botmin'
                else:
                    top_down_mdk = 'rm_dw_bot-t'
                    bot_down_mdk = 'rm_dw_bot-b'
                    top_up_mdk = 'rm_dw_top-t'
                    bot_up_mdk = 'rm_dw_top-b'

                if sr_ymin < 10.16:
                    # --10.16=5.08+5.08
                    msg_box = msgBox()
                    msg_box.critical(self, '错误', 'y方向留边太小,至少要10.16才可以加下铆钉symbol', QMessageBox.Ok)
                    check_result = False
                if mao_pin2SR < 3.8 and mao_pin_base == 0.5:
                    msg_box = msgBox()
                    msg_box.critical(self, '错误', '铆钉y的值太小,PE3000铆钉距排版必须大于3.8mm,请加大%s' % mao_pin_base, QMessageBox.Ok)
                    self.mao_pin_y_org = self.mao_pin_y
                    check_result = False
                if mao_pin2SR < mao_pin2SR_min and mao_pin_base == 0.25:
                    # --0.25进制的APE3000只加完整的光学点,不切割也不加min形式的光学点
                    msg_box = msgBox()
                    msg_box.critical(self, '错误', '铆钉y的值太小,铆钉距排版必须大于%s,请加大%s' % (mao_pin2SR_min, mao_pin_base),
                                     QMessageBox.Ok)
                    self.mao_pin_y_org = self.mao_pin_y
                    check_result = False
                if mao_pin2profile < mao_pin2profile_min:
                    msg_box = msgBox()
                    # print "self.mao_pin_y_org",self.mao_pin_y_org
                    # print "self.mao_pin_y",self.mao_pin_y
                    # self.GEN.PAUSE("check")
                    if self.mao_pin_y == self.mao_pin_y_org:
                        msg_box.critical(self, '错误', '铆钉y的值太大,会出板外,请减少%s' % mao_pin_base, QMessageBox.Ok)
                        check_result = False
                    else:
                        # --如果已经在org的基础上对mao_pin_y的值做过调整,弹出提示后点击继续是放行
                        ret = msg_box.question(self, '铆钉y的值太大', '铆钉y的值太大,会出板外,\n请确认是否继续？',
                                               QMessageBox.Yes, QMessageBox.No)
                        if ret == "否":
                            check_result = False
                if mao_pin_y_decimal % mao_pin_base != 0 and mao_pin_y_decimal != 0.0:
                    msg_box = msgBox()
                    msg_box.critical(self, '错误', '铆钉y的值必须是%s的整数倍！' % mao_pin_base, QMessageBox.Ok)
                    check_result = False
            if self.panel_x < 271:
                msg_box = msgBox()
                msg_box.warning(self, '警告', '板边X尺寸小于271...请检查...', QMessageBox.Ok)
                check_result = False
        # --如果料号名的层数和线路层的层数不同，提示错误。
        if self.compare_layer_value1 != self.compare_layer_value2:
            if self.lj_board_fd == "no":
                msg_box = msgBox()
                msg_box.warning(self, '警告', '料号名的层数与线路层的层数不符，请核对....', QMessageBox.Ok)
                # ==== 2022.04.21  双面板制作为光板，则此项不退出 HB150000093A1  
                if self.JOB[4:6] == '00':
                    self.layer_number = self.compare_layer_value2
                else:
                    check_result = False
        if not self.cycle_in_silk and not self.cycle_in_signal and not self.cycle_in_sm:
            msg_box = msgBox()
            msg_box.warning(self, '警告', '请选择层添加周期....', QMessageBox.Ok)
            check_result = False
        if self.sh_site == '':
            # --因为厂别直接从InPlan和ERP中查询获得，不可能为空,此处列出只是为了在重构Panel时保持与原有逻辑一致
            msg_box = msgBox()
            msg_box.warning(self, '警告', '请选择厂别....', QMessageBox.Ok)
            check_result = False
        if self.wei_xiang == '未选中' and self.job_signal_numbers != 2:
            # --经纬向不能为未选中，默认为纬向x,此处列出只是为了在重构Panel时保持与原有逻辑一致
            msg_box = msgBox()
            msg_box.warning(self, '警告', '请选择经纬向....', QMessageBox.Ok)
            check_result = False
        if self.rout_x != '' and self.rout_y != '':
            # --rout_x和rout_y不为空的情况下
            if self.rout_x > self.panel_x or self.rout_y > self.panel_y:
                msg_box = msgBox()
                msg_box.warning(self, '警告', '锣边后的尺寸大于panel尺寸....', QMessageBox.Ok)
                check_result = False

        if self.split_via == '' or self.split_pth == '':
            msg_box = msgBox()
            ret = msg_box.question(self, '切片孔径via或pth为空', '切片孔径via或pth为空,将无法添加切片孔。\n请确认是否继续？',
                                   QMessageBox.Yes, QMessageBox.No)
            if ret == "否":
                check_result = False
        # if self.add_ld_symbol_no and self.have_silk_in_pcb:
        #     # --有文字层，但是没有选择镭雕制程，提醒
        #     msg_box = msgBox()
        #     msg_box.warning(self, '警告', '请选择镭雕制程....', QMessageBox.Ok)
        #     check_result = False
        if math.fabs(self.U_margin - self.D_margin) > 0.1:
            msg_box = msgBox()
            msg_box.critical(self, "警告", "上下留边不对称...请检查,"
                                         "\n\ntop : %s"
                                         "\n\nbot : %s" % (self.U_margin, self.D_margin), QMessageBox.Ok)
            check_result = False
        if math.fabs(self.L_margin - self.R_margin) > 0.1:
            msg_box = msgBox()
            msg_box.critical(self, "警告", "左右留边不对称...请检查,"
                                         "\n\nleft : %s"
                                         "\n\nright : %s" % (self.L_margin, self.R_margin), QMessageBox.Ok)
            check_result = False
        # V2.13 === 2021.09.20 金手指需选择手指方向 ===
        # 因为现在更新不需要选择金手指方向，是按照开料尺寸 故隐取消此判断 20221117 by lyh
        # 20230221 工艺要求恢复手指选择
        if self.sel_finger_yes and self.g_direction == '请选择':
            msg_box = msgBox()
            msg_box.critical(self, "警告", "请选择金手指方向！", QMessageBox.Ok)
            check_result = False
            
        # 检查 VCP镀金系列铜边距金手指位置至少保留30mm 20221115 by lyh
        #if self.sel_finger_yes:
            #result = self.check_gold_open_min_edge()
            #if result:
                ##msg_box = msgBox()
                ##msg_box.critical(self, "警告", result, QMessageBox.Ok)
                ##check_result = False
                #res = send_message_to_director(result, self.JOB)
                #if not res and "-lyh" not in self.JOB:
                    #check_result = False
        
        if check_result == "yes":
            # --将QLabel的红色提醒重置为黑色
            self.ui.label_rout_x.setStyleSheet(styleSheet_black)
            self.ui.label_rout_y.setStyleSheet(styleSheet_black)
        return check_result
    
    def check_gold_open_min_edge(self):
        """
        20221115 by lyh
        1,开料尺寸≤650mm时，留边与开窗取短边，短边留边需大于30mm，短边开窗依最后一次锣边往内开10mm，如留边不够提示需修改拼版。
        2，开料尺寸＞650mm时，留边与开窗取长边，长边留边需大于30mm，长边开窗依最后一次锣边往内开10mm，如留边不够提示需修改拼版。
        http://192.168.2.120:82/zentao/story-view-4625.html
        gold-c/gold-s
        :return:
        """
        log = ""
        if self.parm["panel_y"] > 650:
            lb = (self.rout_x - (self.parm["sr_xmax"] - self.parm["sr_xmin"])) * 0.5
            if lb < 30:
                log = u'开料尺寸＞650mm时，镀金板边开窗留边取长边，长边留边锣后需大于30mm,当前留边大小：{0}mm,请重新拼版！'.format(lb)
        else:
            lb = (self.rout_y - (self.parm["sr_ymax"] - self.parm["sr_ymin"])) * 0.5
            if lb < 30:
                log = u'开料尺寸≤650mm时，镀金板边开窗留边取短边，短边留边锣后需大于30mm,当前留边大小：{0}mm,请重新拼版！'.format(lb)
                
        return log

    def checkSQL(self):
        """
        统一检查sql查询结果
        :return:
        :rtype:
        """
        panel_x = '%s' %  round(self.parm['panel_x'], 3)
        panel_y = '%s' % round(self.parm['panel_y'] ,3)
        if self.parm.has_key('panel_x_InPlan'):
            panel_x_InPlan = '%s' % round(self.parm['panel_x_InPlan'], 3)
            panel_y_InPlan = '%s' % round(self.parm['panel_y_InPlan'], 3)
            rout_x_InPlan = '%s' % round(self.parm['rout_x_InPlan'], 3)
            rout_y_InPlan = '%s' % round(self.parm['rout_y_InPlan'], 3)

            # Bar_x = self.parm['Bar_x']
            # Bar_y = self.parm['Bar_y']
            # backupBar = self.parm['Bar_Backup']
            if panel_x != panel_x_InPlan or panel_y_InPlan != panel_y:
                # --20210118新规则,所有板层，panel尺寸等于开料
                msg_box = msgBox()
                ret = msg_box.critical(self, "是否继续？", "排版尺寸与数据库查询结果不一致 !"
                                                      "\n\n数据库查询结果为: %s %s "
                                                      "\n\n当前排版尺寸为: %s %s" %
                                       (panel_x_InPlan, panel_y_InPlan, panel_x, panel_y),
                                       QMessageBox.Yes, QMessageBox.No)
                if ret == "否":
                    return False
                # if Bar_x and Bar_y and backupBar:
                #     # 三个防呆数据都齐全，而且排版尺寸与数据库一样，什么都不提示
                #     pass
                # else:
                #     msg_box = msgBox()
                #     ret = msg_box.critical(self, "是否继续？", "料号: %s"
                #                                           "\n\n(固定尺寸及非标拼),"
                #                                           "\n\n数据库中没有靶孔防呆数据!" % self.JOB,
                #                            QMessageBox.Yes, QMessageBox.No)
                if ret == "否":
                    return False
        # --若检测均没有问题，最后返回True
        return True

    def checkDrlName(self):
        """
        检查当前料号的钻孔层名与Inplan钻带名是否相同
        """
        no_exist_list = []
        create_drill_layers = self.parm['create_drill_layers']
        current_drill_layers = self.parm['drill_array']
        machine_reg = re.compile(r'L(\d+)-(\d+)机械盲孔')
        burry_reg = re.compile(r'L(\d+)-(\d+)埋孔')
        for cur_item in create_drill_layers:
            hole_name = None
            if cur_item == '一次钻孔':
                hole_name = 'drl'
            elif cur_item == 'TOP面控深钻':
                hole_name = 'cdc'
            elif cur_item == 'BOTTOM面控深钻':
                hole_name = 'cds'
            #周涌通知 2nd不检测 直接自动创建20221125 by lyh
            #elif  cur_item == '2nd':
                #hole_name = '2nd'
            # elif cur_item == 'TOP面背钻':
            #     hole_name = 'bdc'
            # elif cur_item == 'BOTTOM面背钻':
            #     hole_name = 'bds'
            elif burry_reg.match(cur_item):
                regex_obj = burry_reg.match(cur_item)
                hole_name = 'b' + '-'.join(regex_obj.groups())
            elif machine_reg.match(cur_item):
                regex_obj = machine_reg.match(cur_item)
                hole_name = 'm' + '-'.join(regex_obj.groups())
            # === 2022.04.08 Song 排除光板钻孔定义 L0-0埋孔 ===
            if hole_name and hole_name not in current_drill_layers and hole_name != 'b0-0':
                no_exist_list.append(hole_name)
        if len(no_exist_list) > 0:
            msg_box = msgBox()
            ret = msg_box.critical(self, "钻带不存在", "钻带:%s，在料号中不存在, 请确认" % ','.join(no_exist_list), QMessageBox.Ok)
            return False
        return True

    def checkCouponStep(self):
        """
        检查阻抗条到panel板边是否>20mm
        :return:
        :rtype:
        """
        info = self.GEN.DO_INFO('-t step -e %s/panel -m script -d PROF_LIMITS' % self.JOB)
        profile_xmin = float(info['gPROF_LIMITSxmin'])
        profile_xmax = float(info['gPROF_LIMITSxmax'])
        profile_ymin = float(info['gPROF_LIMITSymin'])
        profile_ymax = float(info['gPROF_LIMITSymax'])
        self.parm['profile_xmin'] = profile_xmin
        self.parm['profile_xmax'] = profile_xmax
        self.parm['profile_ymin'] = profile_ymin
        self.parm['profile_ymax'] = profile_ymax

        info = self.GEN.DO_INFO('-t step -e %s/panel -m script -d SR_LIMITS' % self.JOB)
        sr_xmin = float(info['gSR_LIMITSxmin'])
        sr_xmax = float(info['gSR_LIMITSxmax'])
        sr_ymin = float(info['gSR_LIMITSymin'])
        sr_ymax = float(info['gSR_LIMITSymax'])
        self.parm['sr_xmin'] = sr_xmin
        self.parm['sr_xmax'] = sr_xmax
        self.parm['sr_ymin'] = sr_ymin
        self.parm['sr_ymax'] = sr_ymax
        self.parm['sr_lenth'] = sr_xmax - sr_xmin
        self.parm['sr_width'] = sr_ymax - sr_ymin

        step_tuple = []
        info = self.GEN.DO_INFO('-t step -e %s/panel -m script -d SR' % self.JOB)
        for i, step in enumerate(info['gSRstep']):
            stepSRxmin = float(info['gSRxmin'][i])
            stepSRxmax = float(info['gSRxmax'][i])
            stepSRymin = float(info['gSRymin'][i])
            stepSRymax = float(info['gSRymax'][i])
            if re.compile(r'^icg').match(step):
                width = stepSRxmax - stepSRxmin
                height = stepSRymax - stepSRymin
                if stepSRxmin - profile_xmin < 20 and width < height:
                    # --阻抗条竖着放，阻抗条的长边到panel左侧长边不足20mm
                    step_tuple.append((step, 'panel_left'))
                elif profile_xmax - stepSRxmax < 20 and width < height:
                    # --阻抗条竖着放，阻抗条的长边到panel右侧长边不足20mm
                    step_tuple.append((step, 'panel_right'))
                elif stepSRymin - profile_ymin < 20 and width > height:
                    # --阻抗条横着放，阻抗条的长边到panel bot短边不足20mm
                    step_tuple.append((step, 'panel_bot'))
                elif profile_ymax - stepSRymax < 20 and width > height:
                    # --阻抗条横着放，阻抗条的长边到panel top短边不足20mm
                    step_tuple.append((step, 'panel_top'))

        # --计算panel留边大小
        self.L_margin = sr_xmin - profile_xmin
        self.R_margin = profile_xmax - sr_xmax
        self.U_margin = profile_ymax - sr_ymax
        self.D_margin = sr_ymin - profile_ymin
        if self.rout_x == 0 and self.rout_y == 0:
            # === 双面板此项为0，四层板以上有检测
            self.top_after_margin = sr_ymin
            self.left_after_margin = sr_xmin
        else:
            self.top_after_margin = sr_ymin - (profile_ymax - self.rout_y) * 0.5
            self.left_after_margin = sr_xmin - (profile_xmax - self.rout_x) * 0.5
        self.parm['L_margin'] = self.L_margin
        self.parm['R_margin'] = self.R_margin
        self.parm['U_margin'] = self.U_margin
        self.parm['D_margin'] = self.D_margin
        self.parm['top_after_margin'] = self.top_after_margin
        self.parm['left_after_margin'] = self.left_after_margin
        
        self.add_rmyt_symbol = "no"
        self.add_rmyt_special = "no"
        if self.L_margin >= 16 and self.R_margin >= 16 and self.U_margin >= 13 and self.D_margin >= 13:
            self.add_rmyt_symbol = "yes"
            if self.U_margin <= 15 and self.D_margin <= 15:
                self.add_rmyt_special = "yes"
        self.parm['add_rmyt_symbol'] = self.add_rmyt_symbol
        self.parm['add_rmyt_special'] = self.add_rmyt_special             

        # --多层需求,取消检查 AresHe 2021.12.30
        return True
        if self.L_margin < 20 or self.R_margin < 20 or self.U_margin < 20 or self.D_margin < 20:
            # --panel留边不足20mm时，阻抗条有可能放在set中
            info = self.GEN.DO_INFO('-t step -e %s/set -m script -d EXISTS' % self.JOB)
            if info['gEXISTS'] == "yes":
                info = self.GEN.DO_INFO('-t step -e %s/set -m script -d PROF_LIMITS' % self.JOB)
                prof_xmin_set = float(info['gPROF_LIMITSxmin'])
                prof_xmax_set = float(info['gPROF_LIMITSxmax'])
                prof_ymin_set = float(info['gPROF_LIMITSymin'])
                prof_ymax_set = float(info['gPROF_LIMITSymax'])

                srCouponXmin = 99999999999999
                srCouponXmax = -99999999999999
                srCouponYmin = 99999999999999
                srCouponYmax = -99999999999999

                srOtherXmin = 99999999999999
                srOtherXmax = -99999999999999
                srOtherYmin = 99999999999999
                srOtherYmax = -99999999999999

                stepCouponArray = []
                coupon = defaultdict(dict)
                info = self.GEN.DO_INFO('-t step -e %s/set -m script -d SR' % self.JOB)
                for i, step in enumerate(info['gSRstep']):
                    stepSRxmin = float(info['gSRxmin'][i])
                    stepSRxmax = float(info['gSRxmax'][i])
                    stepSRymin = float(info['gSRymin'][i])
                    stepSRymax = float(info['gSRymax'][i])
                    if re.compile(r'^zk').match(step):
                        if stepSRxmin < srCouponXmin:
                            srCouponXmin = stepSRxmin
                        if stepSRxmax > srCouponXmax:
                            srCouponXmax = stepSRxmax
                        if stepSRymin < srCouponYmin:
                            srCouponYmin = stepSRymin
                        if stepSRymax > srCouponYmax:
                            srCouponYmax = stepSRymax
                        coupon[i]['srCouponXmin'] = stepSRxmin
                        coupon[i]['srCouponXmax'] = stepSRxmax
                        coupon[i]['srCouponYmin'] = stepSRymin
                        coupon[i]['srCouponYmax'] = stepSRymax
                    else:
                        # --高水位原则计算set中其它step的最大最小值
                        if stepSRxmin < srOtherXmin:
                            srOtherXmin = stepSRxmin
                        if stepSRxmax > srOtherXmax:
                            srOtherXmax = stepSRxmax
                        if stepSRymin < srOtherYmin:
                            srOtherYmin = stepSRymin
                        if stepSRymax > srOtherYmax:
                            srOtherYmax = stepSRymax
                for key, value in coupon.items():
                    width = value['srCouponXmax'] - value['srCouponXmin']
                    height = value['srCouponYmax'] - value['srCouponYmin']
                    if value['srCouponYmin'] >= srOtherYmax and width > height:
                        # --阻抗条横放在top位置
                        stepCouponArray.append("top")
                    if value['srCouponYmax'] <= srOtherYmin and width > height:
                        # --阻抗条横放在bot位置
                        stepCouponArray.append("bot")
                    if value['srCouponXmax'] <= srOtherXmin and width < height:
                        # --阻抗条竖放在left位置
                        stepCouponArray.append("left")
                    if value['srCouponXmin'] >= srOtherXmax and width < height:
                        # --阻抗条竖放在right位置
                        stepCouponArray.append("right")
                # --如果在set中检测到coupon距profil不足20mm,要将set中的step放到panel衡量
                if stepCouponArray:
                    self.GEN.OPEN_STEP(job=self.JOB, step='set')
                    self.GEN.CLEAR_LAYER()
                    self.GEN.CHANGE_UNITS('mm')
                    self.GEN.DELETE_LAYER('checkcouponlayer')
                    self.GEN.CREATE_LAYER('checkcouponlayer')
                    self.GEN.WORK_LAYER('checkcouponlayer')
                    for pos in stepCouponArray:
                        if pos == "top":
                            self.GEN.ADD_LINE(prof_xmin_set, prof_ymax_set, prof_xmax_set, prof_ymax_set, 'r10')
                        if pos == "bot":
                            self.GEN.ADD_LINE(prof_xmin_set, prof_ymin_set, prof_xmax_set, prof_ymin_set, 'r10')
                        if pos == "left":
                            self.GEN.ADD_LINE(prof_xmin_set, prof_ymin_set, prof_xmin_set, prof_ymax_set, 'r10')
                        if pos == "top":
                            self.GEN.ADD_LINE(prof_xmax_set, prof_ymin_set, prof_xmax_set, prof_ymax_set, 'r10')
                    self.GEN.COM('sel_reverse')
                    count = self.GEN.GET_SELECT_COUNT()
                    if count > 0:
                        # --将set中的线move_repeat到panel中
                        self.GEN.COM('sel_move_repeat,dest_step=panel,x_repeats=0,y_repeats=0,delete_orig=yes')
                        self.GEN.OPEN_STEP(job=self.JOB, step='set')
                        self.GEN.CLOSE_STEP()
                        self.GEN.OPEN_STEP(job=self.JOB, step='panel')
                        self.GEN.CLEAR_LAYER()
                        self.GEN.CHANGE_UNITS('mm')
                        self.GEN.AFFECTED_LAYER('checkcouponlayer', 'yes')
                        for pos in ['left', 'right', 'top', 'bot']:
                            _tuple = ("set", "set_none")
                            if pos == 'left':
                                selectProXmin = profile_xmin - 2
                                selectProXmax = profile_xmin + 22
                                selectProYmin = profile_ymin - 2
                                selectProYmax = profile_ymax + 2
                                _tuple = ("set", "set_left")
                            elif pos == 'right':
                                selectProXmin = profile_xmax - 22
                                selectProXmax = profile_xmax + 2
                                selectProYmin = profile_ymin - 2
                                selectProYmax = profile_ymax + 2
                                _tuple = ("set", "set_right")
                            elif pos == 'top':
                                selectProXmin = profile_xmin - 2
                                selectProXmax = profile_xmax + 2
                                selectProYmin = profile_ymax - 22
                                selectProYmax = profile_ymax + 2
                                _tuple = ("set", "set_top")
                            elif pos == 'bot':
                                selectProXmin = profile_xmin - 2
                                selectProXmax = profile_xmax + 2
                                selectProYmin = profile_ymin - 2
                                selectProYmax = profile_ymin + 22
                                _tuple = ("set", "set_bot")
                            self.GEN.COM('filter_area_strt')
                            self.GEN.COM('filter_area_xy,x=%s,y=%s' % (selectProXmin, selectProYmax))
                            self.GEN.COM('filter_area_xy,x=%s,y=%s' % (selectProXmax, selectProYmin))
                            self.GEN.COM(
                                'filter_area_end,layer=,filter_name=popup,operation=select,area_type=rectangle,'
                                'inside_area=yes,intersect_area=no')
                            count = self.GEN.GET_SELECT_COUNT()
                            if count > 0:
                                self.GEN.CLEAR_FEAT()
                                step_tuple.append(_tuple)
                    self.GEN.DELETE_LAYER('checkcouponlayer')
        if step_tuple:
            # --初始化窗口
            self.password = passwordDialog(parent=self, data=step_tuple, path=self.userDir)
            if self.password.exec_():
                # --检测到阻抗counpon问题，但输入了正确的工号及密码，记录后返回真
                return True
            else:
                # --检测到阻抗counpon问题，工号及密码输入不正确，返回False
                return False
        else:
            # --没有检测到阻抗counpon问题，直接返回真
            return True

    def checkBlindBuriedLayerName(self):
        """
        检查镭射及埋孔层别是否按最新标准正确命名
        :return:
        """
        true_signal_numbers = self.job_signal_numbers - len(self.parm['assist_layer'])
        blind_burry_list = self.parm['blind_burry_list']

        check_result = 'ok'
        halfjob_numb = true_signal_numbers / 2
        # === 盲埋层别匹配 ===
        BB_Reg = re.compile(r'^[bs]([0-9][0-9]?)-([0-9][0-9]?)$')
        # Blind_Reg = re.compile (r'^s([0-9][0-9]?)-([0-9][0-9]?)$')
        for tmp in blind_burry_list:
            BB_obj = BB_Reg.match(tmp)
            if BB_obj:
                tmp1 = int(BB_obj.group(1))
                tmp2 = int(BB_obj.group(2))
                if (tmp1 < tmp2 and tmp1 <= halfjob_numb) or (tmp1 > tmp2 and tmp2 > halfjob_numb):
                    if tmp1 < tmp2 and tmp1 <= halfjob_numb:
                        pass
                    elif tmp1 > tmp2 and tmp2 >= halfjob_numb:
                        pass
                    else:
                        msg_box = msgBox()
                        msg_box.warning(self, '警告', '%s埋孔及镭射层别应为起始层-终止层,中间加横杠!' % tmp, QMessageBox.Ok)
                        check_result = 'error'
                else:
                    msg_box = msgBox()
                    msg_box.warning(self, '警告', '埋孔及镭射层别,应按起止层命名,%s命名不正确!' % tmp, QMessageBox.Ok)
                    # check_result = 'error';
            else:
                msg_box = msgBox()
                msg_box.warning(self, '警告', '%s埋孔及镭射层别非最新命名标准，应为b或s起始层-终止层!' % tmp, QMessageBox.Ok)
                check_result = 'error'
        if check_result == 'error':
            return False
        else:
            return True


class FrozenJSON(object):
    """
    一个只读接口，使用属性表示法访问JSON类对象
    """

    def __init__(self, mapping):
        self.__data = dict(mapping)

    def __getattr__(self, name):
        """
        FrozenJSON 类的关键是__getattr__ 方法
        仅当无法使用常规的方式获取属性(即在实例、类或超类中找不到指定的属性),解释器才会调用特殊的__getattr__方法
        :param name: 属性名比如.keys,.values,.items,不是字典键
        :type name:
        :return:
        :rtype:
        """
        if hasattr(self.__data, name):
            # --比如调用字典的keys、values等方法
            return getattr(self.__data, name)
        else:
            return FrozenJSON.build(self.__data[name])

    @classmethod
    def build(cls, obj):
        """
        类方法，第一个参数是类本身
        :param arg: 构建类的参数
        """
        if isinstance(obj, Mapping):
            # --如果obj 是映射,那就构建一个FrozenJSON对象
            return cls(obj)
        elif isinstance(obj, MutableSequence):
            # --如果参数是序列实例
            return [cls.build(item) for item in obj]
        else:
            # --其它如字符、int形式直接返回
            return obj


class Panel(object):
    """
    具体执行panel中symbol添加的总类，可以传入json字符串，从而可以用socket的方式在远端服务器上运行
    """    

    def __init__(self, job_name=None, step_name=None, json_data=None, socket_mode=False, debug=False):
        self.JOB = job_name
        self.parm = FrozenJSON(json.loads(json_data, encoding='utf8'))
        self.STEP = step_name
        self.debug = debug
        self.InPlan = InPlan(job_name)
        # --收集错误和提示信息,最后统一释放,不阻塞运行过程
        self.msg_array = []
        # === 错误信息压入TopCAM 结果 ===
        # --接收TL_PUB_run_source_script_new.pl 传递过来的环境变量，并转化
        try:            
            print json.loads(os.environ.get('PARAM').replace(';', ','))
            self.paramJson = json.loads(os.environ.get('PARAM').replace(';', ','))
    
            self.processID = int(self.paramJson['process_id'])
            self.jobID = int(self.paramJson['job_id'])
        except:
            # 手动测试用
            self.processID = -1
            self.jobID = -1
        # 接口定义
        if debug:
            # 通过genesis gateway命令连结pid进行会话,不用在genesis环境下运行，直接用gateway的方式，可在pycharm环境下直接debug
            self.GEN = Gateway()
            self.GEN.genesis_connect()
            # 方法genesis_connect通过查询log-genesis文件获取的料号名
            self.JOB = self.GEN.job_name
            self.pid = self.GEN.pid
        else:
            self.GEN = genCOM.GEN_COM()
            self.pid = os.getpid()
        # --用来收集阴阳拼板信息
        self.stepFlipHash = {}
        self.flipList = []
        # --用来收集动态添中symbol时需要避开的区域
        self.avoidArea = {
            'inner': [],
            'outer': [],
            'all': [],
        }


    def reset_genesis_config(self, value=1):
        # --重置config参数
        self.GEN.VOF()
        self.GEN.COM('config_edit,name=gen_line_skip_post_hooks,value=%s,mode=user' % value)
        self.GEN.COM('config_edit,name=gen_line_skip_pre_hooks,value=%s,mode=user' % value)
        self.GEN.VON()

    def renew_symbol(self):
        """
        指定需要更新的symbol,并遂个更新
        :return:
        :rtype:
        """
        add_symbol_list = ("chris-rjpad", "chris-rjpad", "chris-rjpad", "chris-rjpad", "new_dw_rh_pad1",
                           "new_dw_rh_pad2", "new_rj_rh_pad1", "new_rj_rh_pad2", "new_rj_rh_pad11", "new_rj_rh_pad22",
                           "sh-rj2", "sh-rj3", "sh-mdk", "sh-rout-con", "rm_dw_bot", "rm_dw_top", "rm_dw_botmin",
                           "rm_dw_topmin", "rm_dw_topqie", "rm_dw_botqie", "sh-qpsig3", "sh-dwtop2013", "sh-dwbot2013",
                           "sh-dwsig2014", "sh_silk_autodw", "sh_innnew1_a", "sh_innnew1_b", "sh-bj", "sh-con","sh-con2")
        for sym in add_symbol_list:
            self.update_symbol(sym)

    def update_symbol(self, name):
        """
        更新symbol,从lib中copy,保证与lib一致
        :return:
        :rtype:
        """
        info = self.GEN.DO_INFO('-t symbol -e %s/%s -m script -d EXISTS' % (self.JOB, name))
        if info['gEXISTS']:
            if platform.system() == "Linux" and PRODUCT is not None:
                self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                             'dst_names=%s' % name)
            else:
                self.GEN.COM('copy_entity,type=symbol,source_job=genesislib,source_name=%s,dest_job=%s,dest_name=%s,'
                             'dest_database=' % (name, self.JOB, name))

    def symbol_update(self):
        """
        新增加的symbol,genesis lib库中不存在,将Z:\incam\genesis\symbols中的symbol cp到本机
        :return:
        :rtype:
        """
        # --为了sh-opnew2014-new/sh-opnew2021-new symbol可以正常添加，
        # 需要copy "Z:/incam/genesis/fonts/standard-04"到本机目录
        src_fonts = "Z:/incam/genesis/fw/lib/fonts/standard-04"
        dst_fonts = "%s/fw/lib/fonts/standard-04" % (os.environ.get('GENESIS_DIR', 'D:/genesis'))
        date_today = datetime.strftime(datetime.now(), "%Y%m%d")
        dst_backup = dst_fonts + "_bak" + date_today
        if not os.path.exists(dst_fonts):
            copyfile(src_fonts, dst_fonts)
        else:
            if not filecmp.cmp(src_fonts, dst_fonts):
                move(dst_fonts, dst_backup)
                copyfile(src_fonts, dst_fonts)

        # src_path = "Z:/incam/genesis/symbols"
        src_path = "Z:/incam/genesis/fw/lib/symbols"
        dst_path = "%s/fw/lib/symbols" % (os.environ.get('GENESIS_DIR', 'D:/genesis'))
        sym_list = ('chris_sh5', 'chris-2712symbol', 'xray-lower', 'xray-upper', 'sh_silk_autodw_2020', 'chris_sh6',
                    'site_sh1', 'site_sh2', 'site_sh3', 'site_sh4', 'site_sh5', 'site_sh6', 'site_sh7', 'site_sh8',
                    'site_sh9', 'site_sh10', 'factory_sh1', 'factory_sh2', 'factory_sh3', 'factory_sh4', 'factory_sh5',
                    'factory_sh6', 'factory_sh7', 'factory_sh8', 'factory_sh9', 'factory_sh10', 'hdi_orbldi_stamp',
                    'sh-dwsd2020', 'sh-pin-fx', 'fill_ladder_top', 'fill_ladder_bot', 'sh-baccd', 'sh-opnew2021+0mil',
                    'sh-opnew2014+0mil', 'sh-opnew2021+3mil', 'sh-opnew2014+3mil', 'forbid_produce', 'silk_hui_se',
                    'silk_ju_se', 'silk_lan_lu_se', 'silk_lan_se', 'silk_leng_hui_se', 'silk_liang_hei_se',
                    'silk_bai_se', 'silk_fen_se', 'silk_hei_se', 'silk_hong_se', 'silk_huang_se', 'silk_lu_se',
                    'silk_shen_hui_se', 'silk_wu_hong_se', 'silk_liang_hong_se', 'et_rj_pad', 'dry_md', 'hdi_orbldi_stamp_1')
        for sym in sym_list:
            src_dir = os.path.join(src_path, sym)
            dst_dir = os.path.join(dst_path, sym)
            if not os.path.exists(dst_dir):
                copytree(src_dir, dst_dir)
                pass

        # --为了hdi_orbldi_stamp symbol可以正常添加，
        # 需要copy "Z:/incam/genesis/sys/hooks/userdef_stamp_formats"到本机目录
        src_file = "Z:/incam/genesis/sys/hooks/userdef_stamp_formats"
        dst_file = "%s/sys/hooks/userdef_stamp_formats" % (os.environ.get('GENESIS_DIR', 'D:/genesis'))
        date_today = datetime.strftime(datetime.now(), "%Y%m%d")
        dst_backup = dst_file + "_bak" + date_today
        if not filecmp.cmp(src_file, dst_file):
            move(dst_file, dst_backup)
            copyfile(src_file, dst_file)

        # --为了能够正常输出劲鑫tgz,需要加id=101属性，所以要更新userattr文件
        # src_user_attr = "Z:/incam/genesis/userattr/userattr"
        src_user_attr = "Z:/incam/genesis/fw/lib/misc/userattr"
        dst_user_attr = "%s/fw/lib/misc/userattr" % (os.environ.get('GENESIS_DIR', 'D:/genesis'))
        dst_attr_backup = dst_user_attr + "_bak" + date_today
        if not filecmp.cmp(src_user_attr, dst_user_attr):
            move(dst_user_attr, dst_attr_backup)
            copyfile(src_user_attr, dst_user_attr)

    def run(self):
        # self.goldBoard_cover_Cu()
        # sys.exit()
        # --针对genesis环境symbol库中不存在的symbol,从公用z盘copy
        if platform.system() == "Linux" and PRODUCT is not None:
            # --Linux InCAM InCAMPro环境下不需要更新
            # 以下三个symbol有修改 需重新更新20230727 by lyh
            # http://192.168.2.120:82/zentao/story-view-5815.html
            self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                         'dst_names=sh-dwsd2014')                           
            self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                         'dst_names=sh-con2')               
            self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                         'dst_names=hdi_orbldi_stamp_1')
            
            #http://192.168.2.120:82/zentao/story-view-5994.html 翟鸣通知 改为直接更新以下三个symbol 20230925 by lyh
            self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                         'dst_names=sh-dwtop')
            self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                         'dst_names=sh-dwbot')
            self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                         'dst_names=sh-pindonut') 
        else:
            self.reset_genesis_config(value=2)
            self.symbol_update()
        # --针对symbol库中已经存在的symbol进行更新
        # TODO 测试阶段不刷新symbol，提升速度
        # self.renew_symbol()
        # self.modify_symbols_test()
        self.compare_job_pcs_per_set()
        self.break_edit_holes()
        self.del_all_features()
        self.create_layers()        
        self.GEN.DELETE_LAYER('panel_map')
        self.GEN.CREATE_LAYER('panel_map')
        self.GEN.WORK_LAYER('panel_map')
        self.GEN.CHANGE_UNITS('mm')
        self.GEN.SEL_DELETE()
        self.icg_fill_copper()
        self.opt_side = self.get_opt_side()
        # === 为了鹰眼pad，把外层铺铜提前
        out_copper = OUT_copper(frozen_json=self.parm)
        # out_copper.put_copper ()
        # --品字形排版板内鹰眼pad添加底铜
        if self.parm.add_eagle_panel == '是':
            out_copper.add_eagle_inncu()
        # --外层板边铺铜
        out_copper.put_copper()
        # --鹰眼pad添加底铜
        # === 取消底铜 http://192.168.2.120:82/zentao/story-view-3053.html
        # if self.parm.add_eagle_panel == '是':
        #     out_copper.add_eagle_cu ()

        inner_copper = INN_copper(frozen_json=self.parm)
        inner_copper.put_copper()

        sm_copper = SM_copper(frozen_json=self.parm)
        sm_copper.put_copper()
        # --金手指卡板切铜
        # out_copper.vgaChange ()
        md_copper = MD_copper(frozen_json=self.parm, opt_side=self.opt_side)
        md_copper.put_copper()

        gold_copper = GOLD_copper(frozen_json=self.parm)
        gold_copper.put_copper()
        etch_copper = ETCH_copper(frozen_json=self.parm)
        etch_copper.put_copper()
        sgt_copper = SGT_copper(frozen_json=self.parm)
        sgt_copper.put_copper()

        linek_copper = LineK_copper(frozen_json=self.parm)
        linek_copper.put_copper()

        # sys.exit()
        # --定义静态symbol列表，静态symbol依此顺序添加
        # --------------------------------------------------------------------------------------------------------------
        symbol_static = []
        for cls in STATIC_SYM.__subclasses__():
            cls_name = cls.__name__
            # --sh-xh对应的英文字母和阿拉伯数字外层无使用，可以取消out_word
            if cls_name not in ['DYNAMIC_SYM', 'out_word', 'sh_csx_pad']:
                # --实例化
                instance = cls(frozen_json=self.parm)
                symbol_static.append(instance)
            # if cls_name != 'DYNAMIC_SYM' and cls_name in ['sm_outline']:
            #     # --实例化
            #     instance = cls(frozen_json=self.parm)
            #     symbol_static.append(instance)
        # --添加时按实例的优先级排序，优先级越小越先添加
        for instance in sorted(symbol_static, key=attrgetter('priority')):
            self.extend_rectangles(instance=instance)
        # print "self.avoidArea : --------------------"
        # pprint(self.avoidArea)
        # sys.exit()

        # --定义动态symbol列表，动态symbol依此顺序添加
        # --------------------------------------------------------------------------------------------------------------
        symbol_dynamic = []
        for cls in DYNAMIC_SYM.__subclasses__():
            # if cls.__name__ in ['rvc_ccd','add_four_lengnew']:
            #     symbol_dynamic.append(cls)
            if cls.__name__ not in ['moving_test']:
                symbol_dynamic.append(cls)
        # --添加时按实例的优先级排序，优先级越小越先添加
        for cls in sorted(symbol_dynamic, key=attrgetter('priority')):
            # --print语句不要删除，在报错时可以看到是哪个symbol有问题
            if cls.__name__ in ['drl_moudle']:
                # --尾孔模块要运行多次
                for drl_step in self.parm.tail_hole_list:
                    self.extend_rectangles(cls=cls, step=drl_step)
            else:
                self.extend_rectangles(cls=cls)
        # print "self.avoidArea : --------------------"
        # pprint(self.avoidArea)
        # sys.exit()

        # === TODO
        # self.GEN.PAUSE('xxxxxxxxxxxxxxxxxxxxxxxxx')
        # --删除板外孔
        self.del_hole_out_of_rout()
        # --删除与其它孔touch到的防暴孔
        self.del_touched_fbk()

        # --灯板添加鹰眼pad
        if self.parm.add_eagle_panel == '是':
            out_copper.add_eagle_mark()
            inner_copper.add_inn_eagle_pad()
            # ===  防焊挡点层鹰眼pad位置盖油 ===
            self.add_sm_md_eagle_pad()
            
        # --有二次选化印油 印选化油层通孔跟inn 孔需套开单边15mil 不下油 20221123 by lyh
        # --以及曝光资料板边取防焊对位ccd，板边不开窗 
        # http://192.168.2.120:82/zentao/story-view-4640.html V2.14
        self.modify_xh_layer()
        
        #双面板dbk层中间3颗孔需与钻孔层的孔避开6.5mm。20221123 by lyh
        # http://192.168.2.120:82/zentao/story-view-4467.html V2.14
        self.opt_dbk_hole_distance()
        
        # 1，电镀前钻2nd时，2nd,inn用3.175mm的大小。
        # 2，电镀后钻2nd时，2nd,inn用2.95mm的大小
        #http://192.168.2.120:82/zentao/story-view-4553.html 20221126 by lyh
        self.modify_2nd_hole_condition()
        
        # --化金板文字盖油 === HDI 不运行此项 ===
        # self.goldBoard_cover_Cu ()
        # --调用其它python脚本,检测inn层添加的Bk是否有与drl层重叠（以免发生，钻机钻轴碰到销钉）
        self.innTouchDrl_check()
        self.jobname_touch_bar_check()
        # --调用forbid_produce,禁止生产字样 添加脚本
        # forbid_production = forbid_produce()
        # forbid_production.add_symbol()

        # --检查内容物是否进板内
        self.TouchSRCheck()

        # === 检查镀金层xy均有金手指时是否满足20mm要求
        self.gold_open_touch_cu_check()
        # --还原genesis config参数
        if platform.system() == "Linux" and PRODUCT is not None:
            pass
        else:
            # --只有genesis环境下才需要重置
            self.reset_genesis_config(value=1)

        #清除避开区域临时层 20221123 by lyh
        # self.GEN.DELETE_LAYER("bk_area_tmp")
        # 运行全流程追溯二维码 20240801 by lyh
        array_jobtype_info = get_job_type(self.JOB)
        car_type = [info for info in array_jobtype_info
                    if (info["JOB_PRODUCT_LEVEL1_"] and u"汽车" in info["JOB_PRODUCT_LEVEL1_"].decode("utf8"))
                    or info["ES_CAR_BOARD_"] == 1]
        
        if self.JOB[1:4] in ["183", 'a86', 'd10'] or \
           self.JOB.startswith("q") or car_type:        
            os.system("python /incam/server/site_data/scripts/sh_script/add_all_process_barcode/add_all_process_barcode.py")        

        # --保存料号
        self.GEN.COM('save_job,job=%s,override=no' % self.JOB)
        # --因为考虑到socket运行模式,向上抛出异常，供上一级捕获
        raise SystemExit
    
    def modify_symbols_test(self):
        """测试修改symbol 20230725 by lyh"""
        self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                     'dst_names=sh-dwsd2014')           
        self.GEN.COM("set_sym,name=sh-dwsd2014")
        self.GEN.COM("open_group,job={0},step=sh-dwsd2014,is_sym=yes".format(self.JOB))
        self.GEN.COM("open_entity,job={0},type=symbol,name=sh-dwsd2014,iconic=no".format(self.JOB))
        self.GEN.FILTER_RESET()
        self.GEN.FILTER_SET_INCLUDE_SYMS("*donut*", reset=1)
        self.GEN.FILTER_SELECT()
        if self.GEN.GET_SELECT_COUNT():
            self.GEN.COM('sel_delete')
            
        self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                     'dst_names=sh-con2')       
        self.GEN.COM("set_sym,name=sh-con2")
        self.GEN.COM("open_group,job={0},step=sh-con2,is_sym=yes".format(self.JOB))
        self.GEN.COM("open_entity,job={0},type=symbol,name=sh-con2,iconic=no".format(self.JOB))
        self.GEN.FILTER_RESET()
        self.GEN.FILTER_SET_INCLUDE_SYMS("r60;r1524", reset=1)
        self.GEN.FILTER_SELECT()
        if self.GEN.GET_SELECT_COUNT():
            self.GEN.COM('sel_delete')
    
        self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                     'dst_names=hdi_orbldi_stamp_1')   
        self.GEN.COM("set_sym,name=hdi_orbldi_stamp_1")
        self.GEN.COM("open_group,job={0},step=hdi_orbldi_stamp_1,is_sym=yes".format(self.JOB))
        self.GEN.COM("open_entity,job={0},type=symbol,name=hdi_orbldi_stamp_1,iconic=no".format(self.JOB))
        self.GEN.FILTER_RESET()
        self.GEN.FILTER_SET_INCLUDE_SYMS("s10;s254", reset=1)
        self.GEN.FILTER_SELECT()
        if self.GEN.GET_SELECT_COUNT():
            self.GEN.COM('sel_delete')              
        
    def modify_2nd_hole_condition(self):
        """1，电镀前钻2nd时，2nd.inn用3.175mm的大小。
        2，电镀后钻2nd时，2nd.inn用2.95mm的大小 20221126 by lyh
        逻辑判断：二次钻孔 前有电镀 且中间没有蚀刻 且二次钻孔后有 盖孔电镀"""
        self.inplan_all_flow = self.InPlan.get_inplan_all_flow()
        index_2nd = 0
        index_diandu = 0
        index_gaikongdiandu = 0
        index_shike = 0
        
        order_num = 0
        for i in self.inplan_all_flow:            
            if '二次钻孔' in i['WORK_CENTER_CODE']:
                order_num = i['ORDER_NUM']
                if i["TRAVELER_ORDERING_INDEX"] > index_2nd:
                    index_2nd = i["TRAVELER_ORDERING_INDEX"]
                 
        for i in self.inplan_all_flow:        
            if i['ORDER_NUM'] == order_num:
                
                if i['WORK_CENTER_CODE'] in ['电镀', '电镀（一）', '电镀（二）', '电镀（三）']:
                    if i["TRAVELER_ORDERING_INDEX"] > index_diandu:
                        index_diandu = i["TRAVELER_ORDERING_INDEX"]
                        
                if '盖孔电镀' in i['WORK_CENTER_CODE']:
                    if i["TRAVELER_ORDERING_INDEX"] > index_gaikongdiandu:
                        index_gaikongdiandu = i["TRAVELER_ORDERING_INDEX"]               
                                    
                if '蚀刻' in i['WORK_CENTER_CODE']:
                    if i["TRAVELER_ORDERING_INDEX"] > index_shike:
                        index_shike = i["TRAVELER_ORDERING_INDEX"]
        
        change_2nd_hole = False
        if index_2nd and index_diandu and index_gaikongdiandu:
            if index_diandu < index_2nd < index_gaikongdiandu:
                change_2nd_hole = True
                if index_shike:
                    if index_diandu< index_shike < index_2nd:
                        change_2nd_hole = False
                        
        if change_2nd_hole:
            jobname = self.JOB
            stepname = "panel"
            worklayer = "2nd.inn"
            if self.GEN.LAYER_EXISTS(worklayer, jobname, stepname) == "yes":
                self.GEN.CLEAR_LAYER()
                self.GEN.WORK_LAYER(worklayer)
                self.GEN.FILTER_RESET()
                self.GEN.FILTER_SET_INCLUDE_SYMS("r3175", reset=1)
                self.GEN.FILTER_SELECT()
                if self.GEN.GET_SELECT_COUNT():
                    self.GEN.SEL_CHANEG_SYM("r2950")
                    
        self.GEN.CLEAR_LAYER()
    
    def modify_xh_layer(self):
        """修改选化层"""
        through_drl = self.parm.drl
        # out_signal_array = self.parm.out_signal_array
        prof_ymin = self.parm.profile_ymin
        prof_ymax = self.parm.profile_ymax
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        
        jobname = self.JOB
        stepname = "panel"
        arraylist_layer = ["linek-c", "linek-s","linek-c-1","linek-s-1","linek-c-2","linek-s-2"]
        for worklayer in [through_drl, "inn"]:            
            if self.GEN.LAYER_EXISTS(worklayer, jobname, stepname):
                self.GEN.CLEAR_LAYER()
                self.GEN.WORK_LAYER(worklayer)
                for dest_layer in arraylist_layer:
                    if self.GEN.LAYER_EXISTS(dest_layer, jobname, stepname) == "yes":
                        self.GEN.SEL_COPY(dest_layer, invert='yes', size=30*25.4)
                        
        #for worklayer in out_signal_array:
            #if self.GEN.LAYER_EXISTS(worklayer, jobname, stepname):
        worklayer = "l1"
        self.GEN.CLEAR_LAYER()
        self.GEN.WORK_LAYER(worklayer)
        self.GEN.FILTER_RESET()
        self.GEN.FILTER_SET_INCLUDE_SYMS("sh-dwtop2013;sh-dwsd2014;sh-dwsig2014;dwtop;sh-dwtop;hdi-dwtop*")
        self.GEN.FILTER_SELECT()
        self.GEN.DELETE_LAYER("xh_symbol_tmp")
        
        if self.GEN.GET_SELECT_COUNT():
            self.GEN.SEL_COPY("xh_symbol_tmp")
            self.GEN.CLEAR_LAYER()
            self.GEN.WORK_LAYER("xh_symbol_tmp")
            self.GEN.SEL_POLARITY("positive")
            self.GEN.FILTER_SET_INCLUDE_SYMS("sh-dwtop2013;sh-dwsd2014;sh-dwsig2014", reset=1)
            self.GEN.FILTER_SELECT()
            if self.GEN.GET_SELECT_COUNT():
                self.GEN.SEL_CHANEG_SYM("s3750")
                
            self.GEN.FILTER_SET_INCLUDE_SYMS("dwtop;sh-dwtop;hdi-dwtop*", reset=1)
            self.GEN.FILTER_SELECT()
            if self.GEN.GET_SELECT_COUNT():
                self.GEN.SEL_CHANEG_SYM("s5150")
                
            for dest_layer in arraylist_layer:
                if self.GEN.LAYER_EXISTS(dest_layer, jobname, stepname) == "yes":
                    self.GEN.SEL_COPY(dest_layer, invert='yes', size=30*25.4)
                    
        self.GEN.DELETE_LAYER("xh_symbol_tmp")            
        worklayer = "md1"
        if self.GEN.LAYER_EXISTS(worklayer, jobname, stepname) == "yes":
            self.GEN.CLEAR_LAYER()
            self.GEN.WORK_LAYER(worklayer)
            self.GEN.FILTER_RESET()
            self.GEN.FILTER_SET_INCLUDE_SYMS("sh-fxpad")
            self.GEN.FILTER_SELECT()
            if self.GEN.GET_SELECT_COUNT():
                self.GEN.SEL_COPY("xh_symbol_tmp")
                self.GEN.CLEAR_LAYER()
                self.GEN.WORK_LAYER("xh_symbol_tmp")
                self.GEN.SEL_CHANEG_SYM("sh_xh_fxpad")
                for dest_layer in arraylist_layer:
                    if self.GEN.LAYER_EXISTS(dest_layer, jobname, stepname) == "yes":
                        self.GEN.SEL_COPY(dest_layer, invert='yes')
        
        self.GEN.DELETE_LAYER("xh_symbol_tmp")  
        dic_zu = {}
        dic_zu["xlym-c"] = "m1"
        dic_zu["xlym-s"] = "m2"
        dic_zu["xlym-c-2"] = "m1"
        dic_zu["xlym-s-2"] = "m2"        
        for worklayer in ["xlym-c", "xlym-s", "xlym-c-2", "xlym-s-2"]:
            if self.GEN.LAYER_EXISTS(worklayer, jobname, stepname) == "yes":
                if self.GEN.LAYER_EXISTS(dic_zu[worklayer], jobname, stepname) == "yes":
                    self.GEN.CLEAR_LAYER()
                    self.GEN.WORK_LAYER(dic_zu[worklayer])
                    self.GEN.FILTER_SET_INCLUDE_SYMS("sh-dwsd2014", reset=1)
                    self.GEN.FILTER_SELECT()
                    if self.GEN.GET_SELECT_COUNT():
                        self.GEN.SEL_COPY(worklayer)
                        
                #xlym-c/s层短边4个CCD增加r0，属性.fiducial_name=317.reg
                self.GEN.CLEAR_LAYER()
                self.GEN.WORK_LAYER(worklayer)
                self.GEN.FILTER_RESET()
                self.GEN.FILTER_SET_INCLUDE_SYMS("sh-dwsd2014", reset=1)
                self.GEN.COM('filter_area_strt') 
                self.GEN.COM('filter_area_xy,x='+`sr_xmin`+',y='+`prof_ymin`)
                self.GEN.COM('filter_area_xy,x='+`sr_xmax`+',y='+`prof_ymax`)
                self.GEN.COM('filter_area_end,layer=,filter_name=popup,operation=select,area_type=rectangle,inside_area=yes,intersect_area=no')
                if self.GEN.GET_SELECT_COUNT():
                    self.GEN.DELETE_LAYER("xh_symbol_tmp")
                    self.GEN.SEL_COPY("xh_symbol_tmp")
                    self.GEN.CLEAR_LAYER()
                    self.GEN.WORK_LAYER("xh_symbol_tmp")                      
                    self.GEN.SEL_CHANEG_SYM("r0")
                    self.GEN.COM("cur_atr_reset")
                    self.GEN.COM('cur_atr_set,attribute=.fiducial_name,text=317.reg')
                    self.GEN.COM("sel_change_atr,mode=add")
                    self.GEN.SEL_COPY(worklayer)
              
              
        self.GEN.DELETE_LAYER("xh_symbol_tmp")
        
    def opt_dbk_hole_distance(self):
        """优化dbk层中间3个孔的位置 双面板dbk层中间3颗孔需与钻孔层的孔避开6.5mm 20221123 by lyh"""
        jobname = self.JOB
        stepname = "panel"
        job = gClasses.Job(jobname)
        step = gClasses.Step(job, stepname)
        step.open()
        step.COM("units,type=mm")
        prof_ymax = self.parm.profile_ymax
        prof_xmax = self.parm.profile_xmax
        sr_ymax = self.parm.sr_ymax
        
        worklayer = "dbk"
        if step.isLayer(worklayer) and \
           self.parm.job_signal_numbers <= 2:
            step.clearAll()
            step.affect(worklayer)
            step.resetFilter()
            step.selectSymbol("r3175", 1, 1)
            if step.featureSelected():
                step.removeLayer("dbk_tmp")
                step.moveSel("dbk_tmp")
                step.clearAll()
                step.resetFilter()
                step.affect("dbk_tmp")
                step.COM("sel_resize,size=13000")
                step.refSelectFilter("drl")
                if not step.featureSelected():
                    step.COM("sel_resize,size=-13000")                    
                    step.moveSel(worklayer)
                    step.removeLayer("dbk_tmp")
                    return
                
                step.selectNone()
                step.resetFilter()
                step.selectRectangle(0, sr_ymax-5, prof_xmax, prof_ymax, intersect="yes")
                if step.featureSelected() == 2:                    
                    move_size_x = 1
                    move_size_y = 0
                else:
                    move_size_x = 0
                    move_size_y = 1
                    
                step.selectNone()
                step.copyLayer(jobname, stepname, "dbk_tmp", "dbk_bak")
                count = 1
                while True:                    
                    step.COM("sel_transform,mode=anchor,oper=scale,duplicate=no,"
                             "x_anchor=0,y_anchor=0,angle=0,x_scale=1,y_scale=1,"
                             "x_offset={0},y_offset={1}".format(move_size_x, move_size_y))
                    step.refSelectFilter("drl")
                    if not step.featureSelected():
                        step.COM("sel_resize,size=-13000")                        
                        step.copySel(worklayer)
                        #inn层需跟dbk层一致 20230329 by lyh
                        step.changeSymbol("r3100")
                        step.COM("truncate_layer,layer=inn")
                        step.copySel("inn")
                        step.removeLayer("dbk_tmp")
                        step.removeLayer("dbk_bak")
                        return
                    
                    if count > 150:
                        step.clearAll()
                        step.affect("dbk_bak")
                        step.COM("sel_resize,size=-13000")                    
                        step.moveSel(worklayer)
                        step.removeLayer("dbk_tmp")
                        step.removeLayer("dbk_bak")
                        msg_box = msgBox()
                        msg_box.critical(self, '错误', '双面板dbk层中间3颗孔需与钻孔层的孔避开6.5mm,程序无法自动避开，请手动调整',
                                         QMessageBox.Ok)                        
                        break
                    
                    count += 1

    def extend_rectangles(self, cls=None, instance=None, step=None):
        """
        实例化类，并收集错误信息以及rectangles
        :return:
        :rtype:
        """
        if not instance:
            if step:
                # --尾孔模块要传入尾孔step名
                instance = cls(frozen_json=self.parm, avoidArea=self.avoidArea, step=step)
            else:
                instance = cls(frozen_json=self.parm, avoidArea=self.avoidArea)
        # --print语句不要删除，在报错时可以看到是哪个symbol有问题
        print instance.__class__.__name__
        try:
            # --静态symbol也要考虑相互避开，直接将self.avoidArea赋值给instance
            if instance.__class__.__name__ in ['hdi_tag_symbol', 'silk_auto_dw_sym', 'sh_dwsd', 'core_core_board',
                                               'pin_donut']:
                instance.avoidArea = self.avoidArea
            # --通过添加symbol获取避让区域
            rectangles = instance.add_symbol()
            # --扩充实例收集到的错误警告信息
            self.msg_array.extend(instance.msg_array)
        except:
            msg_box = msgBox()
            msg_box.critical(self, '错误', '程序运行到添加symbol : ★%s★ 时出错!\n程序终止，请联系程序课维护人员!' % instance.__class__.__name__,
                             QMessageBox.Ok)
            # --这种错误会阻断程序运行，只能提示并退出，不能继续收集
            # msg_dict = {'type'       : 'critical',
            #             'windowTitle': '错误',
            #             'content'    : '程序运行到添加symbol : %s时出错' % instance.__class__.__name__}
            # self.msg_array.append(msg_dict)
            raise
        # --计算当前symbol所占用的area
        for rect in reversed(sorted(rectangles, key=attrgetter('area'))):
            # --以面积从大到小排序
            type = instance.avoidType
            if not any(rect.check_diff(obj) for obj in self.avoidArea[type]) and type is not None:
                self.avoidArea[type].append(rect)
        # --OZ标示每层不一样，要change_text
        if hasattr(instance, 'change_text'):
            instance.change_text()
        # --更改钻字属性
        if hasattr(instance, 'set_attribute'):
            instance.set_attribute()
        # --防焊对位点切铜
        if hasattr(instance, 'clip_copper'):
            instance.clip_copper()
        if hasattr(instance, 'change_symbol'):
            instance.change_symbol()

    def compare_job_pcs_per_set(self):
        """
        获取料号中每set中的psc数,对比inplan数据，不做退出处理，仅提醒。
        :return:
        """
        array_step = self.parm.array_step
        inplan_pcs_per_set = self.parm.INPLAN_PCS_PER_SET
        if array_step != 'set':
            return True
        ginfo = self.GEN.DO_INFO("-t step -e %s/%s -d REPEAT" % (self.JOB, array_step))
        edit_reg = re.compile('edit')
        edit_list = []
        for gstep in ginfo['gREPEATstep']:
            if edit_reg.match(gstep):
                edit_list.append(gstep)
        incam_pcs_per_set = len(edit_list)
        if inplan_pcs_per_set != incam_pcs_per_set:
            msg_dict = {'type': 'critical',
                        'windowTitle': '警告',
                        'content': 'SET中的PCS数不相同，请提示MI修改。InPlan中为%s,InCAM中为%s!' % (
                            inplan_pcs_per_set, incam_pcs_per_set)}
            self.msg_array.append(msg_dict)
        return True

    def break_edit_holes(self):
        """
        打开edit，并将oval形式的钻孔打散
        :return:
        :rtype:
        """
        through_drl = self.parm.drl
        self.GEN.OPEN_STEP(job=self.JOB, step='edit')
        self.GEN.COM('units,type=mm')
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(through_drl, 'yes')
        self.GEN.COM('sel_break')
        self.GEN.AFFECTED_LAYER(through_drl, 'no')
        self.GEN.CLOSE_STEP()

    def del_all_features(self):
        """
        删除panel所有内容物
        :return:
        :rtype:
        """
        self.GEN.OPEN_STEP(job=self.JOB, step='panel')
        self.GEN.COM('units,type=mm')
        self.GEN.CLEAR_LAYER()
        # --删除所有层别内容物
        self.GEN.COM('affected_layer,mode=all,affected=yes')
        self.GEN.COM('sel_delete')
        self.GEN.CLEAR_LAYER()

    def icg_fill_copper(self):
        """
        在icg step中的'etch-c','etch-s','sgt-c','sgt-s'层别铺铜
        :return:
        """
        # 2020-10-30 8.4.9 唐成添加，有阻抗条icg是将sgt-c,sgt-s填铜
        # 查询是否有icg Step
        icg_list = self.parm.icg_list
        through_drl = self.parm.drl
        if len(icg_list) == 0:
            return

        # coupon_name = "icg"
        # coupon_exist = self.GEN.DO_INFO("-t step -e %s/%s -d EXISTS" % (self.JOB,coupon_name))
        # if coupon_exist['gEXISTS'] ==  "yes":
        for coupon_name in icg_list:
            # 跳转到icg  step
            self.GEN.OPEN_STEP(coupon_name, job=self.JOB)
            self.GEN.CHANGE_UNITS('mm')
            self.GEN.CLEAR_LAYER()
            self.GEN.VOF()
            for layer in ['etch-c', 'etch-s', 'sgt-c', 'sgt-s']:
                self.GEN.AFFECTED_LAYER(layer, 'yes')
            self.GEN.VON()
            self.GEN.COM('get_affect_layer')
            layers = self.GEN.COMANS.split()
            if len(layers) == 0:
                self.GEN.COM("editor_page_close")
                self.GEN.OPEN_STEP('panel', job=self.JOB)
                return

            self.GEN.SEL_DELETE()
            self.GEN.COM(
                "sr_fill,polarity=positive,step_margin_x=-0.279,step_margin_y=-0.279,step_max_dist_x=100,step_max_dist_y=100,sr_margin_x=0,sr_margin_y=0,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no");
            self.GEN.CLEAR_LAYER()
            # === V2.08 取消Npth孔在选化层的套铜需求。http://192.168.2.120:82/zentao/story-view-4135.html
            # self.GEN.WORK_LAYER(through_drl)
            # # self.GEN.AFFECTED_LAYER(through_drl,'yes')
            # self.GEN.FILTER_RESET()
            # self.GEN.FILTER_OPTION_ATTR('.drill', 'non_plated')
            # self.GEN.FILTER_SELECT()
            # if int(self.GEN.GET_SELECT_COUNT()) > 0:
            #     for layer in ['sgt-c', 'sgt-s']:
            #         self.GEN.AFFECTED_LAYER(layer, 'yes')
            #         self.GEN.COM('get_affect_layer')
            #         layers = self.GEN.COMANS.split()
            #         # === 没有sgt-c，sgt-s时 === Genesis 和 Incam 的结果可能不同，数量为1或者0时均不可行
            #         if len(layers) == 1 or len(layers) == 0:
            #             self.GEN.CLEAR_LAYER()
            #             self.GEN.COM("editor_page_close")
            #             self.GEN.OPEN_STEP('panel', job=self.JOB)
            #             return
            #     # self.GEN.SEL_COPY('.affected',invert='yes',size='508')
            #     self.GEN.COM('sel_copy_other, dest = affected_layers, target_layer =, invert = yes, dx = 0,'
            #                  ' dy = 0, size = 508, x_anchor = 0, y_anchor = 0, rotation = 0, mirror = none')
            # else:
            #     msg_dict = {'type': 'critical',
            #                 'windowTitle': '警告',
            #                 'content': '阻抗条:%s,未选择到npth孔，请手动处理选化层!' % coupon_name}
            #     self.msg_array.append(msg_dict)
            self.GEN.CLEAR_LAYER()
            self.GEN.COM("editor_page_close")

        self.GEN.OPEN_STEP('panel', job=self.JOB)

    def create_layers(self):
        """
        统一创建层别，考虑到阴阳拼版，
        :return:
        :rtype:
        """
        if platform.system() == "Linux" and PRODUCT is not None:
            # --循环并打开对应的STEP，释放关系,只针对Linux系统下的incam和incampro软件
            self.flipStepName('panel')
            if len(self.flipList) > 0:
                self.flipList = ['edit']
            for stepName in self.flipList:
                # --打开step，并释放关联关系
                self.GEN.OPEN_STEP(job=self.JOB, step=stepName)
                self.GEN.COM('matrix_suspend_symmetry_check,job=%s,matrix=matrix,suspend=yes' % self.JOB)
                self.GEN.CLOSE_STEP()
        if platform.system() == "Windows":
            data = self.GEN.DO_INFO("-t matrix -e %s/matrix -d COL" % self.JOB, units='mm')
            for stpName in data['gCOLstep_name']:
                # --当存在阴阳step时
                if 'flip' in stpName:
                    self.flipList.append(stpName)
                    # --打开step，并释放关联关系
                    self.GEN.OPEN_STEP(stpName, job=self.JOB)
                    self.GEN.COM("change_step_dependency,job=%s,step=%s,operation=release" % (self.JOB, stpName))
                    self.GEN.CLOSE_STEP()

        # --创建各钻孔层对应的inn层 === windows下可以打开step，InCAM下不用切换step
        if platform.system() == "Windows":
            self.GEN.OPEN_STEP(job=self.JOB, step='panel')
        fill_array = self.parm.fill_array
        # TODO 原本钻孔层列表在ERP获取，待更改为inplan获取，或者不获取，使用当前料号
        drill_layers = self.parm.create_drill_layers
        burry_sz_dict = self.parm.burry_sz_dict
        thorugh_drl = self.parm.drl
        machine_reg = re.compile(r'L(\d+)-(\d+)机械盲孔')
        burry_reg = re.compile(r'L(\d+)-(\d+)埋孔')
        # === 内层背钻孔 ===L2层背钻 ==
        innbd_reg = re.compile(r'L(\d+)层背钻')
        # solder_mask_plug_type = self.parm.solder_mask_plug_type
        for layer in drill_layers:
            # --中文要先编码再匹配
            layer = layer.encode('utf8')
            if re.compile(r'(bd-c)').match(layer):
                self.addLayer('bdc.inn', ins_layer='drl', location='after', del_exists=True)
            elif re.compile(r'(bd-s)').match(layer):
                self.addLayer('bds.inn', ins_layer='drl', location='after', del_exists=True)
            elif re.compile(r'(2nd)').match(layer):
                # --创建二次钻带层
                info = self.GEN.DO_INFO('-t layer -e %s/panel/2nd -d EXISTS' % self.JOB)
                if info['gEXISTS'] == "no":
                    self.addLayer('2nd', ins_layer='drl', location='after', del_exists=True)
                    
                self.addLayer('2nd.inn', ins_layer='2nd', location='after', del_exists=True)
            elif machine_reg.match(layer):
                # --机械盲孔需要对应的m1-2.inn层别
                regex_obj = machine_reg.match(layer)
                layer = 'm' + '-'.join(regex_obj.groups())
                inn_layer = layer + ".inn"
                self.addLayer(layer, ins_layer=thorugh_drl, location='after')
                self.addLayer(inn_layer, ins_layer=thorugh_drl, location='after', del_exists=True)
                # === core层机械盲埋孔===
                if abs(int(regex_obj.group(1)) - int(regex_obj.group(2))) == 1:
                    dbk_layer = 'dbk%s' % layer
                    self.addLayer(layer=dbk_layer, ins_layer=thorugh_drl, location='after', del_exists=True)
            elif burry_reg.match(layer):
                regex_obj = burry_reg.match(layer)
                layer = 'b' + '-'.join(regex_obj.groups())
                if abs(int(regex_obj.group(1)) - int(regex_obj.group(2))) == 1:
                    inn_layer = "inn%s" % (''.join(regex_obj.groups()))
                    dbk_layer = 'dbk%s' % (layer)
                    self.addLayer(layer=inn_layer, ins_layer=thorugh_drl, location='after', del_exists=True)
                    self.addLayer(layer=dbk_layer, ins_layer=thorugh_drl, location='after', del_exists=True)
            elif innbd_reg.match(layer):
                # === 内层背钻定位孔的添加 ===
                regex_obj = innbd_reg.match(layer)
                start_layer = 'l%s' % regex_obj.group(1)
                get_side = [i.layer_side for i in fill_array if i.layer_name == start_layer][0]
                side_word = ''
                if get_side == '正':
                    side_word = 'c'
                elif get_side == '反':
                    side_word = 's'
                bdlayer = 'bd-%s%s' % (regex_obj.group(1), side_word)
                inn_layer = '%s.inn' % bdlayer
                self.addLayer(bdlayer, ins_layer='drl', location='after')
                self.addLayer(inn_layer, ins_layer='drl', location='after')
            elif layer == "TOP面控深盲孔":
                self.addLayer('cdc.inn', ins_layer='cdc', location='after', del_exists=True)
            elif layer == "BOTTOM面控深盲孔":
                self.addLayer('cds.inn', ins_layer='cds', location='after', del_exists=True)
            elif layer == "TOP面背钻":
                self.addLayer('bdc', ins_layer='drl', location='after', context='board')
                self.addLayer('bdc.inn', ins_layer='bdc', location='after', del_exists=True)
            elif layer == "BOTTOM面背钻":
                self.addLayer('bds', ins_layer='drl', location='after', context='board')
                self.addLayer('bds.inn', ins_layer='bds', location='after', del_exists=True)

        for sz_hash in burry_sz_dict:
            self.addLayer(sz_hash.sz_layer, ins_layer=sz_hash.mach_drill, location='after')
            self.addLayer(sz_hash.dq_layer, ins_layer=sz_hash.mach_drill, location='after')

        # === 标准inn类的层别使用压合进行添加 ===
        lamination = self.parm.lamination
        max_yh_mum =  max([i.PROCESS_NUM for i in lamination]) - 1
        if self.parm.job_signal_numbers >= 4:
            for every_lamin in lamination:
                start_num = int(every_lamin.FROMLAY[1:])
                end_num = int(every_lamin.TOLAY[1:])
                cur_yh_num = int(every_lamin.PROCESS_NUM) - 1
                if cur_yh_num == max_yh_mum:
                    inn_layer = 'inn'
                else:
                    inn_layer = 'inn%s%s' % (start_num, end_num)

                self.addLayer(inn_layer, ins_layer=thorugh_drl, location='after', del_exists=True)
        # === 零压的相关层别 === 埋孔的dbk和inn在上述匹配位置建立
        # blind_burry_by_lamin = self.parm.blind_burry_by_lamin
        # tmp_check = [i for i in blind_burry_by_lamin if int (i.cur_yh_num) == 0]
        # if len(tmp_check) > 0:
        #     zero_lamin_dict = tmp_check[0]
        #     if hasattr(zero_lamin_dict,'burryLayer'):
        #         from_id = zero_lamin_dict.start_num
        #         to_id = zero_lamin_dict.end_num
        #         inn_layer = 'inn%s%s' % (from_id, to_id)
        #         dbk_layer = 'dbkb%s-%s' % (from_id, to_id)
        #         self.addLayer (layer=inn_layer, ins_layer=thorugh_drl,location='after',del_exists=True)
        #         self.addLayer (layer=dbk_layer, ins_layer=thorugh_drl,location='after',del_exists=True)
        # === 双面板加inn层及dbk层
        if self.parm.job_signal_numbers <= 2:
            self.addLayer(layer='inn', ins_layer=thorugh_drl, location='after')
            self.addLayer(layer='dbk', ins_layer=thorugh_drl, location='after')
            # --创建挡点层
        self.addLayer(layer='md1', ins_layer='m1', type='solder_paste', location='before')
        self.addLayer(layer='md2', ins_layer='m2', type='solder_paste', location='after')

        # --创建碳油层
        # --第七码是e的为化金+碳油流程,2021.2.17刘文东要求添加
        # -- 2021.09.07 按最新规范，第七码e为镍钯金流程，取消此默认跑出 2021.06.15规则 C:碳油，D：化金+碳油，F：喷锡+碳油
        carbon = self.JOB[6]
        if carbon in ['c', 'd', 'f']:
            self.addLayer(layer='ty-c', ins_layer='md1', type='solder_paste', location='before')
            self.addLayer(layer='ty-s', ins_layer='md2', type='solder_paste', location='after')

        # --创建二次文字
        # 因工具有存在备注内 无法按工具来判断是否要建层 全部统一建由用户手动删除20230724 by lyh
        info = self.GEN.DO_INFO('-t layer -e %s/panel/c1 -d EXISTS' % self.JOB)
        if info['gEXISTS'] == "yes" and self.parm.twice_wz_panel == '是':
            # if "c1-2" in " ".join(self.parm.all_silk_layers):                
            self.addLayer(layer='c1-2', ins_layer='c1', type='silk_screen', location='before')
                
        info = self.GEN.DO_INFO('-t layer -e %s/panel/c2 -d EXISTS' % self.JOB)
        if info['gEXISTS'] == "yes" and self.parm.twice_wz_panel == '是':
            # if "c2-2" in " ".join(self.parm.all_silk_layers):    
            self.addLayer(layer='c2-2', ins_layer='c2', type='silk_screen', location='after')

        # --创建二次防焊
        info = self.GEN.DO_INFO('-t layer -e %s/panel/m1 -d EXISTS' % self.JOB)
        if info['gEXISTS'] == "yes" and self.parm.twice_fh_panel == '是':
            self.addLayer(layer=self.parm.twice_fh_top, ins_layer='m1', type='solder_mask', location='before')
        info = self.GEN.DO_INFO('-t layer -e %s/panel/m2 -d EXISTS' % self.JOB)
        if info['gEXISTS'] == "yes" and self.parm.twice_fh_panel == '是':
            self.addLayer(layer='m2-2', ins_layer='m2', type='solder_mask', location='after')

        # --创建inn-pp层,两张core以上料号生成inn-pp层
        if self.parm.core_count >= 2:
            self.addLayer(layer='inn-pp', location='after')

        # === 树脂塞孔类层别创建
        if self.parm.SM_PLUG == "yes":
            self.addLayer(layer='lp', ins_layer=thorugh_drl, location='after')
        else:
            info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -d EXISTS' % (self.JOB, 'lp'))
            if info['gEXISTS'] == "yes":
                self.GEN.COM("rename_layer,name=lp,new_name=error_lp")

        if self.parm.RESIN_PLUG == 'yes':
            self.addLayer(layer='sz.lp', ins_layer=thorugh_drl, location='after')
            self.addLayer(layer='sz...dq', ins_layer='sz.lp', location='after')
        else:
            # === TODO 树脂塞孔时，导气的处理 ===
            info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -d EXISTS' % (self.JOB, 'sz.lp'))
            if info['gEXISTS'] == "yes":
                self.GEN.COM("rename_layer,name=sz.lp,new_name=error_sz.lp")
        # === lr层别 === 0压且镭射存在，则增加lr层别
        blind_burry_by_lamin = self.parm.blind_burry_by_lamin

        lr_layer = self.parm.lr_layer
        if lr_layer:
            self.addLayer(layer=lr_layer, context='board')

        # tmp_check = [i for i in blind_burry_by_lamin if int (i.cur_yh_num) == 0]
        # if len(tmp_check) == 1:
        #     zero_lamin = tmp_check[0]
        #     if hasattr(zero_lamin,'blindLayer') :
        #         lr_layer = 'lr%s-%s' % (zero_lamin.start_num,zero_lamin.end_num)
        #         self.addLayer (layer=lr_layer)

        # --创建锣边层
        lam_rout = self.parm.lam_rout
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        rout_tuple = []
        # --双面板没有锣边
        if self.parm.job_signal_numbers != 2:
            if len(lam_rout) == 1 and self.parm.hdi_num < 1:
                # --一压
                self.addLayer(layer='pnl_rout', location='after', type='rout', ins_layer=thorugh_drl)
                rout_tuple.append(('pnl_rout', rout_x, rout_y))
            else:
                # --HDI板多次压合
                for i, tuple_info in enumerate(lam_rout, 1):
                    layer = 'pnl_rout' + str(i)
                    # --元组解包[('一压',540,616),('二压',536,612)]
                    (lam_des, rout_x, rout_y) = tuple_info
                    self.addLayer(layer=layer, location='after', type='rout', ins_layer=thorugh_drl)
                    rout_tuple.append((layer, rout_x, rout_y))
            # TODO HDI是否有一次锣添加层别要求
            # has_routed_pth = self.parm.has_routed_pth
            # if has_routed_pth == True:
            #     # --是否有镀前成型为True
            #     self.addLayer(layer='ww1', location='after', type='signal',context='misc', ins_layer='')
            #     self.build_rout('ww1',rout_x,rout_y)

        # --创建panel_map
        self.addLayer(layer='panel_map', location='after', type='signal', context='misc', ins_layer='',
                      del_exists=True)

        # --创建选化
        # 判断是否有金手指  #以前是on, 现在改为o, 此要求陈才凤提出，梁涛确认，时间为2017.04.21.
        sel_finger = self.parm.sel_finger
        on_do = self.JOB[6]
        sgt_list1 = []
        sgt_list2 = []

        if on_do == 'o' and sel_finger == "否":
            sgt_list1 = ['sgt-c', 'sgt-s']
        if sel_finger == "是":
            sgt_list2 = ['sgt-c', 'sgt-s']
            
        # 根据inplan中是否有选镀干膜工具来确认是创建层 20221125 by lyh
        self.inplan_all_flow = self.InPlan.get_inplan_all_flow()
        for i in self.inplan_all_flow:
            if i['VALUE_AS_STRING'] is not None :
                value = i['VALUE_AS_STRING']
                if "sgt-c" in value or \
                   "sgt-s" in value:
                    sgt_list1 = ['sgt-c', 'sgt-s']          
                    
            if i['NOTE_STRING'] is not None :
                value = i['NOTE_STRING']
                if "sgt-c" in value or \
                   "sgt-s" in value:
                    sgt_list1 = ['sgt-c', 'sgt-s']
                    
        if len(sgt_list1) > 0:
            self.addLayer(layer='sgt-c', location='before', type='solder_paste', ins_layer='md1')
            self.addLayer(layer='sgt-s', location='after', type='solder_paste', ins_layer='md2')

        # --创建化金层
        if len(sgt_list2) > 0:
            create_layer = False
            for i in self.inplan_all_flow:
                if i['VALUE_AS_STRING'] is not None :
                    value = i['VALUE_AS_STRING']
                    if "gold-c" in value or \
                       "gold-s" in value:
                        create_layer = True              
                        
                if i['NOTE_STRING'] is not None :
                    value = i['NOTE_STRING']
                    if "gold-c" in value or \
                       "gold-s" in value:
                        create_layer = True
                        
            if create_layer:                
                self.addLayer(layer='gold-c', location='before', type='solder_paste', ins_layer='md1')
                self.addLayer(layer='gold-s', location='after', type='solder_paste', ins_layer='md2')

        # --创建蚀刻引线层
        if len(sgt_list2) > 0:
            self.addLayer(layer='etch-c', location='before', type='solder_paste', ins_layer='md1')
            self.addLayer(layer='etch-s', location='after', type='solder_paste', ins_layer='md2')

        if self.parm.linek_flow:
            self.addLayer(layer='linek-c', location='before', type='solder_paste', ins_layer='md1')
            self.addLayer(layer='linek-s', location='after', type='solder_paste', ins_layer='md2')
        if self.parm.linek_flow_2:
            self.addLayer(layer='linek-c-2', location='before', type='solder_paste', ins_layer='md1')
            self.addLayer(layer='linek-s-2', location='after', type='solder_paste', ins_layer='md2')
        if self.parm.linek_flow_1:
            self.addLayer(layer='linek-c-1', location='before', type='solder_paste', ins_layer='md1')
            self.addLayer(layer='linek-s-1', location='after', type='solder_paste', ins_layer='md2')
        if self.parm.xh_xlym:
            self.addLayer(layer='xlym-c', location='before', type='solder_paste', ins_layer='md1')
            self.addLayer(layer='xlym-s', location='after', type='solder_paste', ins_layer='md2')            
        if self.parm.xh_xlym2:
            self.addLayer(layer='xlym-c-2', location='before', type='solder_paste', ins_layer='md1')
            self.addLayer(layer='xlym-s-2', location='after', type='solder_paste', ins_layer='md2')              
        # TODO HDI 对验孔的处理
        # # --创建验孔层
        # have_yan_kong = self.parm.have_yan_kong
        # if have_yan_kong:
        #     info = self.GEN.DO_INFO('-t layer -e %s/panel/w -d EXISTS' % self.JOB)
        #     if info['gEXISTS'] == "yes":
        #         self.addLayer(layer='yk', location='after', type='drill', context='misc', ins_layer='w')
        #     else:
        #         self.addLayer(layer='yk', location='after', type='drill', context='misc', ins_layer='drl')

        # === 生成辅助层 ===
        assist_layer = self.parm.assist_layer
        assist_side = self.parm.assist_side
        out_signal_array = self.parm.out_signal_array

        if len(assist_layer) > 0:
            for cur_assist_layer in assist_layer:
                locate_layer = cur_assist_layer.split('-')[0]
                locate_side = [i.layer_side for i in fill_array if i.layer_name == locate_layer][0]
                # ulayer = u'%s' % locate_layer
                locate_word = ''
                if locate_side == '正':
                    locate_word = 'after'
                    if len(self.flipList) > 0 and locate_layer in out_signal_array:
                        # === V1.10 阴阳拼版则把辅助层建在外层之外，避免刷新阴阳时报错 ===
                        locate_word = 'before'
                elif locate_side == '反':
                    locate_word = 'before'
                    if len(self.flipList) > 0 and locate_layer in out_signal_array:
                        locate_word = 'after'
                self.addLayer(layer=cur_assist_layer, location=locate_word, type='solder_paste', ins_layer=locate_layer)

        # self.GEN.PAUSE('c' * 40)
        if platform.system() == "Linux" and PRODUCT is not None:
            # --循环并打开对应的STEP，重建依赖关系,只针对Linux系统下的incam和incampro软件
            for stepName in self.flipList:
                # --打开step，并释放关联关系
                self.GEN.OPEN_STEP(job=self.JOB, step=stepName)
                self.GEN.COM('matrix_suspend_symmetry_check,job=%s,matrix=matrix,suspend=no' % self.JOB)
                self.GEN.CLOSE_STEP()
        self.GEN.OPEN_STEP(job=self.JOB, step='panel')
        # --实际锣边层内容物添加,必须放在open panel之后，否则会在edit中创建锣边，参考料号B49-079a1
        for layer, rout_x, rout_y in rout_tuple:
            self.build_rout(layer, rout_x, rout_y)
        self.GEN.OPEN_STEP(job=self.JOB, step='panel')

    def addLayer(self, layer=None, context='board', type='drill', polarity='positive', ins_layer='drl',
                 location='before', del_exists=False):
        """
        创建board层
        :return:
        :rtype:
        """
        if not layer:
            # --层别必须定义,否则为了不报错，直接返回
            return
        if del_exists:
            self.GEN.DELETE_LAYER(layer)
        info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -d EXISTS' % (self.JOB, layer))
        if info['gEXISTS'] == "no":
            if ins_layer and self.GEN.LAYER_EXISTS(ins_layer, job=self.JOB, step='panel') == 'yes':                
                self.GEN.COM('create_layer,layer=%s,context=%s,type=%s,polarity=%s,ins_layer=%s,location=%s' %
                             (layer, context, type, polarity, ins_layer, location))
            else:
                self.GEN.COM('create_layer,layer=%s,context=%s,type=%s,polarity=%s,ins_layer=' %
                             (layer, context, type, polarity))                
        # 删除物件放到添加层之后统一删 否则阴阳拼版会删单元内的内容 20230204 by lyh
        #else:
            ## --删除当前panel中内容物，这样不用创建新层，其它step中的内容会被保留
            #self.GEN.AFFECTED_LAYER(layer, 'yes')
            #self.GEN.COM('sel_delete')
            #self.GEN.AFFECTED_LAYER(layer, 'no')

    def flipStepName(self, step):
        """
        递归寻找出有镜像的step，并append到 flipList数组中
        :param step: step名
        :return: None
        """
        info = self.GEN.DO_INFO('-t step -e %s/%s -m script -d SR -p flip+step' % (self.JOB, step))
        step_flip_tuple = [(info['gSRstep'][i], info['gSRflip'][i]) for i in range(len(info['gSRstep']))]
        step_flip_tuple = list(set(step_flip_tuple))
        for (stepName, flip_yn) in step_flip_tuple:
            if flip_yn == 'yes':
                self.flipList.append(stepName)
            elif flip_yn == 'no':
                self.flipStepName(stepName)
        # --返回
        return

    def build_rout(self, layer, rout_x, rout_y):
        """
        创建捞(锣)边
        :return:
        :rtype:
        """
        if layer == 'ww1':
            line_sym = 'r250'
        else:
            line_sym = 'r2400'
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin

        # 得到压合后的坐标
        rout_after_marginx = (profile_xmax - rout_x) * 0.5
        rout_after_marginy = (profile_ymax - rout_y) * 0.5

        rout_x1 = rout_after_marginx
        rout_x2 = rout_x1 + 5
        rout_x3 = profile_xmax - rout_after_marginx - 5
        rout_x4 = profile_xmax - rout_after_marginx

        rout_y4 = profile_ymax - rout_after_marginy
        rout_y3 = rout_y4 - 5
        rout_y2 = profile_ymin + rout_after_marginy + 5
        rout_y1 = profile_ymin + rout_after_marginy
        rout_yfd = rout_y1 + 50
        rout_xfd = rout_x4 - 2

        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(layer, 'yes')
        self.GEN.COM('add_polyline_strt')
        self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_x1, rout_y4))
        self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_x1, rout_y2))
        self.GEN.COM('add_polyline_end,attributes=no,symbol=%s,polarity=positive,bus_num_lines=0,bus_dist_by=pitch,'
                     'bus_distance=0,bus_reference=left' % line_sym)
        self.GEN.COM('add_arc,attributes=no,xc=%s,yc=%s,xs=%s,ys=%s,xe=%s,ye=%s,symbol=%s,polarity=positive,'
                     'direction=ccw' % (rout_x2, rout_y2, rout_x1, rout_y2, rout_x2, rout_y1, line_sym))

        self.GEN.COM('add_polyline_strt')
        self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_x2, rout_y1))
        self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_x3, rout_y1))
        self.GEN.COM('add_polyline_end,attributes=no,symbol=%s,polarity=positive,bus_num_lines=0,bus_dist_by=pitch,'
                     'bus_distance=0,bus_reference=left' % line_sym)
        self.GEN.COM('add_arc,attributes=no,xc=%s,yc=%s,xs=%s,ys=%s,xe=%s,ye=%s,symbol=%s,polarity=positive,'
                     'direction=ccw' % (rout_x3, rout_y2, rout_x3, rout_y1, rout_x4, rout_y2, line_sym))

        self.GEN.COM('add_polyline_strt')
        self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_x4, rout_y2))
        self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_x4, rout_y3))
        self.GEN.COM('add_polyline_end,attributes=no,symbol=%s,polarity=positive,bus_num_lines=0,bus_dist_by=pitch,'
                     'bus_distance=0,bus_reference=left' % line_sym)

        if layer == 'ww1':
            # 2019.11.11李家兴在ww1层增加四个防呆槽
            rout_xfd1 = rout_x4 - 5
            rout_yfd1 = rout_y2 + 145
            rout_yfd2 = rout_yfd1 - 7
            rout_yfd3 = rout_yfd2 - 7
            rout_yfd4 = rout_yfd1 + 20
            rout_yfd5 = rout_yfd1 + 20 + 7
            rout_yfd_list = [rout_yfd1, rout_yfd2, rout_yfd3, rout_yfd4, rout_yfd5]
            for rout_fd_y in rout_yfd_list:
                self.GEN.COM('add_polyline_strt')
                self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_x4, rout_fd_y))
                self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_xfd1, rout_fd_y))
                self.GEN.COM('add_polyline_end,attributes=no,symbol=%s,polarity=positive,bus_num_lines=0,'
                             'bus_dist_by=pitch,bus_distance=0,bus_reference=left' % line_sym)

        self.GEN.COM('add_arc,attributes=no,xc=%s,yc=%s,xs=%s,ys=%s,xe=%s,ye=%s,symbol=%s,polarity=positive,'
                     'direction=ccw' % (rout_x3, rout_y3, rout_x4, rout_y3, rout_x3, rout_y4, line_sym))

        self.GEN.COM('add_polyline_strt')
        self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_x3, rout_y4))
        self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_x2, rout_y4))
        self.GEN.COM('add_polyline_end,attributes=no,symbol=%s,polarity=positive,bus_num_lines=0,bus_dist_by=pitch,'
                     'bus_distance=0,bus_reference=left' % line_sym)
        self.GEN.COM('add_arc,attributes=no,xc=%s,yc=%s,xs=%s,ys=%s,xe=%s,ye=%s,symbol=%s,polarity=positive,'
                     'direction=ccw' % (rout_x2, rout_y3, rout_x2, rout_y4, rout_x1, rout_y3, line_sym))

        # --添加右边的防呆线
        self.GEN.COM('add_polyline_strt')
        self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_x4, rout_yfd))
        self.GEN.COM('add_polyline_xy,x=%s,y=%s' % (rout_xfd, rout_yfd))
        self.GEN.COM('add_polyline_end,attributes=no,symbol=%s,polarity=positive,bus_num_lines=0,bus_dist_by=pitch,'
                     'bus_distance=0,bus_reference=left' % line_sym)

        if layer != 'ww1':
            # --在没有license的情况下，通过添另属性的方式给锣带走刀
            self.GEN.COM('filter_reset,filter_name=popup')
            self.GEN.COM('filter_set,filter_name=popup,update_popup=no,feat_types=line\;arc')
            self.GEN.COM('filter_area_strt')
            self.GEN.COM(
                'filter_area_end,layer=,filter_name=popup,operation=select,area_type=none,inside_area=no,intersect_area=no')
            self.GEN.COM('cur_atr_reset')
            self.GEN.COM('cur_atr_set,attribute=.comp,option=right')
            self.GEN.COM('cur_atr_set,attribute=.pressure_foot,option=none')
            self.GEN.COM('cur_atr_set,attribute=.feed,option=none,int=25')
            self.GEN.COM('cur_atr_set,attribute=.rout_chain,option=none,int=1')
            self.GEN.COM('cur_atr_set,attribute=.rout_flag,option=none,int=0')
            self.GEN.COM('cur_atr_set,attribute=.speed,option=none,int=0')
            self.GEN.COM('cur_atr_set,attribute=.infeed_speed,option=none,int=0')
            self.GEN.COM('cur_atr_set,attribute=.retract_speed,option=none,int=0')
            self.GEN.COM('cur_atr_set,attribute=.depth,option=none,int=0,float=0')
            self.GEN.COM('sel_change_atr,mode=add')
            self.GEN.COM('cur_atr_reset')
            self.GEN.COM('filter_reset,filter_name=popup')

        self.GEN.AFFECTED_LAYER(layer, 'no')

    def del_hole_out_of_rout(self):
        """
        删除锣边外的孔
        :return:
        :rtype:
        """
        # --20200908李家兴依据story-view-1682添加
        # --将锣边上以及锣边外的融合铆钉孔,move到其它层
        tmp_content = self.JOB[6]
        lam_rout = self.parm.lam_rout
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        through_drl = self.parm.drl
        hdi_num = self.parm.hdi_num
        has_inn_pp = "no"
        info = self.GEN.DO_INFO('-t layer -e %s/panel/inn-pp -d EXISTS' % self.JOB)
        if info['gEXISTS'] == "yes":
            has_inn_pp = "yes"
        self.GEN.DELETE_LAYER('touch_rout')
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")

        # --当锣边锣到铆钉(inn-pp)时,依据story-view-2396添加提醒
        rout_touch_mao_pin_list = []
        rout_list = []
        if has_inn_pp == "yes":
            self.GEN.COM("affected_layer,name=inn-pp,mode=single,affected=yes")
            self.GEN.COM("filter_reset,filter_name=popup")
            self.GEN.COM('filter_set,filter_name=popup,update_popup=no,exclude_syms=r2050')
            if len(lam_rout) > 1:
                # --HDI板多次压合
                for i, tuple_info in enumerate(lam_rout, 1):
                    # --元组解包[('一压',540,616),('二压',536,612)]
                    layer = 'pnl_rout' + str(i)
                    compensate_layer = layer + "_cmp"
                    rout_list.append(layer)
                    self.GEN.COM('compensate_layer,source_layer=%s,dest_layer=%s,dest_layer_type=document' % (
                        layer, compensate_layer))
                    self.GEN.COM("sel_ref_feat,layers=%s,use=filter,mode=touch,pads_as=shape,f_types=line\;arc,"
                                 "polarity=positive\;negative,include_syms=,exclude_syms=" % compensate_layer)
                    count = self.GEN.GET_SELECT_COUNT()
                    if count > 0:
                        rout_touch_mao_pin_list.append(layer)
                    self.GEN.DELETE_LAYER(compensate_layer)
            else:
                # --一次压合通孔板
                layer = 'pnl_rout'
                if hdi_num > 0:
                    layer = 'pnl_rout1'
                compensate_layer = layer + "_cmp"
                rout_list.append(layer)
                self.GEN.COM('compensate_layer,source_layer=%s,dest_layer=%s,dest_layer_type=document' % (
                    layer, compensate_layer))
                self.GEN.COM("sel_ref_feat,layers=%s,use=filter,mode=touch,pads_as=shape,f_types=line\;arc,"
                             "polarity=positive\;negative,include_syms=,exclude_syms=" % compensate_layer)
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    rout_touch_mao_pin_list.append(layer)
                self.GEN.DELETE_LAYER(compensate_layer)
            self.GEN.COM("affected_layer,name=inn-pp,mode=single,affected=no")
        # === HDI 不需要此提示 2021.08.12 取消 ===
        # if len (rout_touch_mao_pin_list) > 0:
        #     msg_dict = {'type': 'critical',
        #                 'windowTitle': '错误',
        #                 'content': '%s\n锣边锣到inn-pp层，会伤铣刀!\n而且化金喷锡板铆钉位置上金上锡！\n请通知MI修改锣边尺寸！' % self.JOB}
        #     self.msg_array.append (msg_dict)

        self.GEN.COM("affected_layer,name=%s,mode=single,affected=yes" % through_drl)
        info = self.GEN.DO_INFO('-t layer -e %s/panel/out_rout -d EXISTS' % self.JOB)
        if info['gEXISTS'] == "yes":
            self.GEN.COM("delete_layer,layer=out_rout")
        rout_after_marginx = (profile_xmax - rout_x) * 0.5
        rout_after_marginy = (profile_ymax - rout_y) * 0.5
        rout_x1 = rout_after_marginx
        rout_x4 = profile_xmax - rout_after_marginx
        rout_y4 = profile_ymax - rout_after_marginy
        rout_y1 = profile_ymin + rout_after_marginy
        self.GEN.COM("filter_reset,filter_name=popup")
        if tmp_content in ['h', 'l']:
            self.GEN.COM("filter_set,filter_name=popup,update_popup=no,include_syms=r4000\;r6000")
        else:
            self.GEN.COM("filter_set,filter_name=popup,update_popup=no,include_syms=r2000")
        if has_inn_pp == "yes":
            self.GEN.COM("sel_ref_feat,layers=inn-pp,use=filter,mode=touch,pads_as=shape,f_types=pad\;text,polarity="
                         "positive\;negative,include_syms=r3600,exclude_syms=")
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                # --先move到out_rout层
                self.GEN.COM("sel_move_other,target_layer=out_rout,invert=no,dx=0,dy=0,size=0,x_anchor=0,y_anchor=0,"
                             "rotation=0,mirror=none")
            else:
                self.GEN.CREATE_LAYER('out_rout')

            self.GEN.COM("affected_layer,name=%s,mode=single,affected=no" % through_drl)
            self.GEN.COM("affected_layer,name=out_rout,mode=single,affected=yes")
            ref_layers = '\;'.join(rout_list)
            self.GEN.COM("sel_ref_feat,layers=%s,use=filter,mode=touch,pads_as=shape,f_types=line\;arc,"
                         "polarity=positive\;negative,include_syms=,exclude_syms=" % ref_layers)
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                # --接触到锣边的move到touch_rout
                self.GEN.COM("sel_move_other,target_layer=touch_rout,invert=no,dx=0,dy=0,size=0,x_anchor=0,"
                             "y_anchor=0,rotation=0,mirror=none")
            # --在锣边范围内的没有touch锣边的孔move回drl
            self.GEN.COM("filter_area_strt")
            self.GEN.COM("filter_area_xy,x=%s,y=%s" % (rout_x1, rout_y1))
            self.GEN.COM("filter_area_xy,x=%s,y=%s" % (rout_x4, rout_y4))
            self.GEN.COM(
                "filter_area_end,layer=,filter_name=popup,operation=select,area_type=rectangle,inside_area=yes,"
                "intersect_area=yes")
            self.GEN.COM("filter_reset,filter_name=popup")
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                # --组合孔在锣边外直接删除
                # self.GEN.COM("sel_delete")
                self.GEN.COM("sel_move_other,target_layer=%s,invert=no,dx=0,dy=0,size=0,x_anchor=0,y_anchor=0,"
                             "rotation=0,mirror=none" % through_drl)
        else:
            self.GEN.COM("filter_reset,filter_name=popup")

    def del_touched_fbk(self):
        """
        删除与其它孔touch或者与外层symbol touch到的防暴孔
        :return:
        :rtype:
        """
        #翟鸣 通知 这些位置的防爆孔正常加，人工判断移开还是删除。20231114 by lyh
        return
    
        # --删除防爆孔，排除干扰
        out_signal_array = self.parm.out_signal_array
        through_drl = self.parm.drl
        burry_list = self.parm.burry_list
        burry_start = self.parm.burry_start
        burry_end = self.parm.burry_end
        sub_outer = self.parm.sub_outer

        self.GEN.DELETE_LAYER('fb_kong')
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(through_drl, 'yes')
        self.GEN.FILTER_RESET()
        self.GEN.COM('filter_atr_set,filter_name=popup,condition=yes,attribute=.string,text=fbk')
        self.GEN.FILTER_SELECT()
        # --选中防爆孔并加大16mil
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.SEL_MOVE('fb_kong', size=406.4)
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('fb_kong', 'yes')
            ref_layers = '\;'.join(out_signal_array)
            self.GEN.SEL_REF_FEAT(ref_layers, 'touch', f_type='pad;text', exclude='rect*')
            # --删除与外层symbol touch到的防爆孔
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_DELETE()
            self.GEN.SEL_REF_FEAT(ref_layers, 'touch', f_type='pad;text', include='rect3981x45381xr190')
            # --删除与外层比例框 touch到的防爆孔
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_DELETE()
            # --加大到6mm后,touch到drl也需要删除
            self.GEN.COM('sel_change_sym,symbol=r6000,reset_angle=no')
            self.GEN.SEL_REF_FEAT(through_drl, 'touch')
            # --删除与外层symbol touch到的防爆孔
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_DELETE()
            # === 删除与外层钻靶pad touch到的防爆孔
            self.GEN.COM('sel_change_sym,symbol=r13000,reset_angle=no')
            ref_layers = '\;'.join(sub_outer)
            self.GEN.SEL_REF_FEAT(ref_layers, 'touch', f_type='pad;text', include='hdi1-b*t')
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_DELETE()
            # --还原防暴孔大小,并move回drl
            self.GEN.COM('sel_change_sym,symbol=r2000,reset_angle=no')
            self.GEN.FILTER_SELECT()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_COPY(through_drl)
            # === 2021.08.12 外层加防爆孔的套铜pad 与旧板边相同 ===
            self.GEN.FILTER_SELECT()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_COPY(out_signal_array[0], invert='yes', size='406.4')
            self.GEN.FILTER_SELECT()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_COPY(out_signal_array[1], invert='yes', size='406.4')
            # --删除档点
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('md1', 'yes')
            self.GEN.AFFECTED_LAYER('md2', 'yes')
            self.GEN.FILTER_RESET()
            self.GEN.COM('filter_atr_set,filter_name=popup,condition=yes,attribute=.string,text=fbk')
            self.GEN.SEL_REF_FEAT('fb_kong', 'disjoint', f_type='pad')
            # --删除与外层比例框 touch到的防爆孔
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_DELETE()
            self.GEN.CLEAR_LAYER()
            self.GEN.DELETE_LAYER('fb_kong')
        # === 处理埋孔中的防爆孔 ===
        for burry_index, cur_burry in enumerate(burry_list):
            self.GEN.DELETE_LAYER('fb_kong')
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER(cur_burry, 'yes')
            self.GEN.FILTER_RESET()
            self.GEN.COM('filter_atr_set,filter_name=popup,condition=yes,attribute=.string,text=fbk')
            self.GEN.FILTER_SELECT()
            # --选中防爆孔并加大16mil
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_MOVE('fb_kong', size=406.4)
                self.GEN.CLEAR_LAYER()
                self.GEN.AFFECTED_LAYER('fb_kong', 'yes')
                ref_layers = '%s\;%s' % (burry_start[burry_index], burry_end[burry_index])
                self.GEN.SEL_REF_FEAT(ref_layers, 'touch', f_type='pad;text', exclude='rect*')
                # --删除与埋孔对应层别symbol touch到的防爆孔
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.SEL_DELETE()
                self.GEN.SEL_REF_FEAT(ref_layers, 'touch', f_type='pad;text', include='rect3981x45381xr190')
                # --删除与外层比例框 touch到的防爆孔
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.SEL_DELETE()
                # --加大到6mm后,touch到drl也需要删除
                self.GEN.COM('sel_change_sym,symbol=r6000,reset_angle=no')
                self.GEN.SEL_REF_FEAT(cur_burry, 'touch')
                # --删除与孔 touch到的防爆孔
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.SEL_DELETE()
                self.GEN.COM('sel_change_sym,symbol=r13000,reset_angle=no')
                self.GEN.SEL_REF_FEAT(ref_layers, 'touch', f_type='pad;text', include='sh-dwbot;sh-dwtop')
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.SEL_DELETE()

                # --还原防暴孔大小,并move回drl
                self.GEN.COM('sel_change_sym,symbol=r1500,reset_angle=no')
                self.GEN.FILTER_SELECT()
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.SEL_COPY(cur_burry)
                self.GEN.CLEAR_LAYER()
                self.GEN.DELETE_LAYER('fb_kong')
                self.GEN.FILTER_RESET()

    def get_edit_list(self):
        """
        获取当前料号edit step列表
        :return: edit_list
        :rtype: list
        """
        edit_list = []
        editRegex = re.compile(r'^edit.*$')
        info = self.GEN.DO_INFO('-t job -e %s -m script -d STEPS_LIST' % self.JOB)
        for step in info['gSTEPS_LIST']:
            if editRegex.match(step):
                if step not in edit_list:
                    edit_list.append(step)
        return edit_list

    def get_opt_side(self):
        """
        金手指留一边用来夹边,此函数确定最佳夹边位置
        :return:
        :rtype:
        """
        opt_side = None
        # --金手指留一边用来夹边
        goldName = self.JOB[6:8]
        if goldName in ['gy', 'gr']:
            panel_x = self.parm.panel_x
            panel_y = self.parm.panel_y
            profile_ymax = self.parm.profile_ymax
            rout_y = self.parm.rout_y
            sr_xmin = self.parm.sr_xmin
            sr_xmax = self.parm.sr_xmax
            sr_ymin = self.parm.sr_ymin
            sr_ymax = self.parm.sr_ymax
            edit_list = self.get_edit_list()
            # --清除临时层别
            self.GEN.DELETE_LAYER('gf_line')
            self.GEN.DELETE_LAYER('gf_line_flt')
            # --打开edit挑选金手指引线
            for pcs in edit_list:
                self.GEN.OPEN_STEP(job=self.JOB, step=pcs)
                self.GEN.COM('units,type=mm')
                self.GEN.CLEAR_LAYER()
                # --通过.string=gf属性挑选金手指
                self.GEN.AFFECTED_LAYER('l1', 'yes')
                self.GEN.FILTER_RESET()
                self.GEN.FILTER_TEXT_ATTR('.string', 'gf')
                self.GEN.FILTER_SELECT()
                self.GEN.FILTER_RESET()
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.SEL_COPY('gf_line')
                else:
                    msg_box = msgBox()
                    msg_box.critical(self, '错误', '料号:%s 板内金手指未定义.string=gf属性，无法确定最佳夹边位置！' % self.JOB, QMessageBox.Ok)
                    sys.exit()
                # --关闭当前edit
                self.GEN.CLEAR_LAYER()
                self.GEN.CLOSE_STEP()
            self.GEN.OPEN_STEP(job=self.JOB, step='panel')
            self.GEN.COM('units,type=mm')
            self.GEN.CLEAR_LAYER()
            self.GEN.COM('flatten_layer,source_layer=%s,target_layer=%s' % ('gf_line', 'gf_line_flt'))
            self.GEN.DELETE_LAYER('gf_line')
            self.GEN.AFFECTED_LAYER('gf_line_flt', 'yes')
            # self.GEN.PAUSE("check gold line")

            # --初始最佳留边为短边顶部,右边不能夹边
            side_list = ['short_top', 'short_bot', 'long_left']
            for side in side_list:
                if side == 'short_top':
                    sel_xs = 0 - 2
                    sel_ys = sr_ymax - 1.6
                    sel_ye = panel_y + 2
                    sel_xe = panel_x + 2
                elif side == 'short_bot':
                    sel_xs = 0 - 2
                    sel_ys = 0 - 2
                    sel_ye = sr_ymin + 1.6
                    sel_xe = panel_x + 2
                elif side == 'long_left':
                    sel_xs = 0 - 2
                    sel_ys = 0 - 2
                    sel_ye = panel_y + 2
                    sel_xe = sr_xmin + 1.6
                self.GEN.COM('filter_area_strt')
                self.GEN.COM('filter_area_xy,x=%s,y=%s' % (sel_xs, sel_ys))
                self.GEN.COM('filter_area_xy,x=%s,y=%s' % (sel_xe, sel_ye))
                self.GEN.COM('filter_area_end,layer=,filter_name=popup,operation=select,area_type=rectangle,'
                             'inside_area=yes,intersect_area=yes')
                # self.GEN.PAUSE("check area select")
                count = self.GEN.GET_SELECT_COUNT()
                if count == 0:
                    opt_side = side
                    break
                else:
                    self.GEN.CLEAR_FEAT()
            if opt_side is None:
                # msg_box = msgBox()
                # msg_box.warning(self, '警告', '料号:%s 上、下、左三个方向均有金手指，只能默认夹短边！' % self.JOB, QMessageBox.Ok)
                msg_dict = {'type': 'warning',
                            'windowTitle': '警告',
                            'content': '料号:%s 上、下、左三个方向均有金手指，只能默认夹短边！' % self.JOB}
                self.msg_array.append(msg_dict)
                opt_side = 'short_top'
                sel_xs = 0 - 2
                sel_ys = panel_y - (profile_ymax - rout_y) * 0.5 - 20
                sel_ye = panel_y + 2
                sel_xe = panel_x + 2
                self.GEN.COM('filter_area_strt')
                self.GEN.COM('filter_area_xy,x=%s,y=%s' % (sel_xs, sel_ys))
                self.GEN.COM('filter_area_xy,x=%s,y=%s' % (sel_xe, sel_ye))
                self.GEN.COM('filter_area_end,layer=,filter_name=popup,operation=select,area_type=rectangle,'
                             'inside_area=yes,intersect_area=yes')
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    # msg_box = msgBox()
                    # msg_box.warning(self, '警告', '料号:%s 电镀夹边上短边,锣边距手指位的距离不足20MM！' % self.JOB, QMessageBox.Ok)
                    msg_dict = {'type': 'warning',
                                'windowTitle': '警告',
                                'content': '料号:%s 电镀夹边在短边,锣边距手指位的距离不足20MM！' % self.JOB}
                    self.msg_array.append(msg_dict)
            # self.GEN.DELETE_LAYER('gf_line_flt')
        return opt_side

    def goldBoard_cover_Cu(self):
        """
        化金板盖油
        :return:
        :rtype:
        """
        sh_site = self.parm.sh_site
        sel_jsz = self.parm.sel_jsz
        put_copper_md = self.parm.put_copper_md
        out_signal_array = self.parm.out_signal_array
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        goldName = self.JOB[6:8]
        add_hj_panel = self.parm.add_hj_panel
        add_first_plant = self.parm.add_first_plant
        silk_after_gold = self.parm.silk_after_gold
        if add_hj_panel == '否':
            # --只有化金板才需要盖油
            return
        # if sh_site == '胜宏一厂' or sel_jsz == '是':
        if add_first_plant == 'yes' or sel_jsz == '是':
            # 1.只要是一厂料号（包括胜宏一厂，样品一厂，一厂样品一次铜，一厂量产一次铜）都不用白油盖铜(因为一厂防焊盖了绿油)。
            # 2.金手指所有板边都不用白油盖铜。
            # 3.六厂二次铜板边follow一厂板边,所以也不用盖文字白油,参考料号HA4616GF034A1
            # --依据story-view-2366要求化金+镀金手指料号文字盖油
            if self.JOB[7] in ['y', 'r']:
                if put_copper_md == 'no':
                    # --档点不铺铜时,档点已经省油,不用文字重复省油
                    return
                else:
                    pass
            else:
                return
            # pass
        # --首先判断双面字符层是否存在,存在则用文字油墨盖
        routSpace_x = (panel_x - rout_x) / 2
        routSpace_y = (panel_y - rout_y) / 2
        coverLayers = []
        addPlace = ""
        cover_Cu = 'tmp_cover+++'
        # --定义油墨离开料边的距离 (需根据锣边后的尺寸进行判断)
        profile2cu = -1000
        # --定义盖的油墨需要超铜多少
        reSize = 254
        # --定义各对位图形套铜多少
        mark2surf = '-50'
        # --定义通孔掏铜多少,依据story-view-2366将些值由原来254改为了0
        drl2surf = '0'
        # --清除打开及影响层
        self.GEN.CLEAR_LAYER()
        self.GEN.COM('units,type=mm')
        # --删除垃圾层
        self.GEN.DELETE_LAYER(cover_Cu)
        # --判断需要加哪里
        if self.GEN.LAYER_EXISTS('c1', job=self.JOB, step='panel') == 'yes' and \
                self.GEN.LAYER_EXISTS('c2', job=self.JOB, step='panel') == 'yes':
            if silk_after_gold:
                # --化金在文字前，只能防焊盖油，不能盖文字油
                coverLayers = ['md1', 'md2', 'm1', 'm2']
                addPlace = 'md'
            else:
                coverLayers = ['c1', 'c2']
                addPlace = 'silk'
        else:
            coverLayers = ['md1', 'md2', 'm1', 'm2']
            addPlace = 'md'
        for index, layer in enumerate(out_signal_array, 1):
            self.GEN.WORK_LAYER(layer)
            self.GEN.FILTER_SET_POL('positive', 1)
            self.GEN.FILTER_SET_TYP('surface')
            self.GEN.FILTER_SELECT()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_COPY(cover_Cu)
            # --加选s1000的pad(板边有铺部分s1000的方形图形)
            self.GEN.FILTER_SET_INCLUDE_SYMS('s1000', 1)
            self.GEN.FILTER_SET_ATR_SYMS('.pattern_fill')
            self.GEN.FILTER_SELECT()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_COPY(cover_Cu)
            # --挑出r762的服务器模块外框线
            self.GEN.FILTER_RESET()
            self.GEN.FILTER_SET_TYP('line')
            self.GEN.FILTER_SET_INCLUDE_SYMS('r762')
            self.GEN.FILTER_TEXT_ATTR('.string', 'server_moudle')
            self.GEN.FILTER_SELECT()
            # --挑出所有Pad，并拷贝至另一层(不包含此图形，因为它本身就是落于铜皮上的)
            self.GEN.FILTER_RESET()
            self.GEN.FILTER_SET_TYP('pad')
            # --排除外框、检验标志、脚线、厂别等symbol
            self.GEN.COM(
                'filter_set,filter_name=popup,update_popup=no,exclude_syms=*outpg*\;sh-rout-con*\;*jybz*\;chris_sh*')
            self.GEN.FILTER_SELECT()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                pad_layer = '_pad%s_%s' % (index, cover_Cu)
                self.GEN.SEL_COPY(pad_layer)
                self.GEN.WORK_LAYER(pad_layer)
                # --inn孔对应的负片pad删除，防止文字白油入孔
                self.GEN.FILTER_SET_INCLUDE_SYMS('r4191\;r4141\;r3708', 1)
                self.GEN.FILTER_SET_TYP('pad')
                self.GEN.FILTER_SET_POL('negative')
                self.GEN.SEL_REF_FEAT('inn', 'include')
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.SEL_DELETE()
                self.GEN.FILTER_SET_INCLUDE_SYMS('r4191')
                self.GEN.SEL_REF_FEAT(layer, 'include', include='r0')
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.SEL_DELETE()
                # --打散后全部转成正极性
                self.GEN.COM('sel_polarity,polarity=positive')
                self.GEN.COM('sel_break')
                self.GEN.COM('sel_polarity,polarity=positive')
                # --全部转化为surface
                self.GEN.SEL_CONTOURIZE()
                # --打散，防止成为一整块
                self.GEN.COM("sel_decompose,overlap=yes")
                self.GEN.SEL_CONTOURIZE()
                self.GEN.SEL_COPY(cover_Cu)
        if self.GEN.LAYER_EXISTS(cover_Cu, job=self.JOB, step='panel') == 'yes':
            self.GEN.WORK_LAYER(cover_Cu)
            self.GEN.SEL_RESIZE(reSize)
        else:
            self.GEN.CREATE_LAYER(cover_Cu)
        # --从外住里铺铜，反扣回去，套掉多余的铜，再去板外,按锣边尺寸套除
        self.GEN.DELETE_LAYER('_clip_%s' % cover_Cu)
        self.GEN.CREATE_LAYER('_clip_%s' % cover_Cu)
        self.GEN.WORK_LAYER('_clip_%s' % cover_Cu)
        self.GEN.FILL_SUR_PARAMS()
        self.GEN.SR_FILL('positive', -10, -10, routSpace_x, routSpace_y)
        # 反极性Copy过去
        self.GEN.SEL_COPY(cover_Cu, 'yes')
        self.GEN.DELETE_LAYER('_clip_%s' % cover_Cu)
        self.GEN.WORK_LAYER(cover_Cu)
        self.GEN.SEL_CONTOURIZE()
        # --去除无法套除的板外图形
        margin = profile2cu - reSize
        self.GEN.CLIP_AREA(area='profile', inout='outside', margin=margin)

        # --金手指品字形拼版sr范围内clip掉,因为外层在sr范围内铺了铜条和dummy,上面步骤会copy外层铜皮和dummy到cover_Cu
        if goldName in ['gy', 'gr']:
            cut_copper_x1 = sr_xmin - 1.5
            cut_copper_y1 = sr_ymin - 1.5
            cut_copper_x2 = sr_xmax + 1.5
            cut_copper_y2 = sr_ymax + 1.5

            self.GEN.COM("clip_area_strt")
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x1, cut_copper_y1))
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x2, cut_copper_y2))
            self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                         "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")

        # --金手指留一边用来夹边
        if goldName in ['gy', 'gr']:
            opt_side = self.opt_side
            # --1.7mm保证可以切掉角线
            if opt_side == 'short_top':
                clip_xs = 0 - 2
                clip_ys = sr_ymax + 1.17
                clip_ye = panel_y + 2
                clip_xe = panel_x + 2
            elif opt_side == 'short_bot':
                clip_xs = 0 - 2
                clip_ys = 0 - 2
                clip_ye = sr_ymin - 1.17
                clip_xe = panel_x + 2
            elif opt_side == 'long_left':
                clip_xs = 0 - 2
                clip_ys = 0 - 2
                clip_ye = panel_y + 2
                clip_xe = sr_xmin - 1.17
            else:
                clip_xs = sr_xmax + 1.17
                clip_ys = 0 - 2
                clip_ye = panel_y + 2
                clip_xe = panel_x + 2
            self.GEN.AFFECTED_LAYER('gf_line_flt', 'no')
            self.GEN.WORK_LAYER(cover_Cu)
            self.GEN.COM("clip_area_strt")
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_xs, clip_ys))
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_xe, clip_ye))
            self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                         "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
            # self.GEN.PAUSE("check clip")

        for Lay in coverLayers:
            self.GEN.WORK_LAYER(cover_Cu)
            # --拷贝surface层
            surf_layer = '%s_surf_%s' % (Lay, cover_Cu)
            pad_layer = '%s_pad_%s' % (Lay, cover_Cu)
            md_mark = '%s_mdmark_%s' % (Lay, cover_Cu)
            self.GEN.SEL_COPY(surf_layer, 'no')
            # --当加于文字层时
            if addPlace == 'silk':
                # --拷贝字符层至指定层
                self.GEN.WORK_LAYER(Lay)
                self.GEN.SEL_COPY(pad_layer, 'no')
                # --全部将字符层的mark图形转为正片
                self.GEN.WORK_LAYER(pad_layer)
                # --全部转化为surface
                self.GEN.SEL_CONTOURIZE()
                # --打散，防止成为一整块
                self.GEN.COM("sel_decompose,overlap=yes")
                self.GEN.SEL_CONTOURIZE()
                # --反极性拷贝至surf_层,并按参数加大
                self.GEN.SEL_COPY(surf_layer, 'yes', size=mark2surf)
                # --打开drl层，并按参数加大反极性
                self.GEN.WORK_LAYER('drl')
                # --20200723李家兴添加，小于500um的钻孔入油无影响,story-view-1329
                self.GEN.FILTER_RESET()
                self.GEN.COM("filter_set,filter_name=popup,update_popup=no,include_syms=r501:r6000")
                self.GEN.FILTER_SELECT()
                self.GEN.FILTER_RESET()
                if self.GEN.GET_SELECT_COUNT() > 0:
                    self.GEN.SEL_COPY(surf_layer, 'yes', size=drl2surf)
                self.GEN.WORK_LAYER(surf_layer)
                self.GEN.SEL_CONTOURIZE()
                # --全部定义属性，以免区分
                self.GEN.CUR_ATR_SET('.bit', text='goldboard_cover_cu', reset=1)
                self.GEN.COM('sel_change_atr,mode=add')
                self.GEN.CUR_ART_RESET()
                # --文字层所有图形Move至此层
                self.GEN.WORK_LAYER(Lay)
                self.GEN.SEL_MOVE(surf_layer, 'no')
                # --拷贝至对应的正式层
                self.GEN.WORK_LAYER(surf_layer)
                self.GEN.SEL_COPY(Lay, 'no')
                # --20200723李家兴修改sh-dwsd2014修改为s3500进行盖油,story-view-1329
                self.GEN.FILTER_SET_INCLUDE_SYMS('sh-dwsd2014', 1)
                self.GEN.FILTER_SELECT()
                self.GEN.FILTER_RESET()
                if self.GEN.GET_SELECT_COUNT() > 0:
                    self.GEN.SEL_CHANEG_SYM('donut_s3500x2650')
                self.GEN.FILTER_SET_INCLUDE_SYMS('donut_s3500x2650', 1)
                self.GEN.FILTER_SELECT()
                self.GEN.FILTER_RESET()
                if self.GEN.GET_SELECT_COUNT() > 0:
                    self.GEN.SEL_COPY(Lay, 'no')
            elif addPlace == 'md':
                self.GEN.WORK_LAYER(Lay)
                # --除去surface以外的图形，全部移走备份
                self.GEN.FILTER_RESET()
                self.GEN.FILTER_SET_TYP('surface')
                self.GEN.FILTER_SELECT()
                # --20200820李家兴添加，不选防焊r254的框线
                self.GEN.FILTER_SET_INCLUDE_SYMS('r254', 1)
                self.GEN.FILTER_SET_TYP('line')
                self.GEN.FILTER_SELECT()
                self.GEN.FILTER_RESET()
                self.GEN.SEL_REVERSE()
                if int(self.GEN.GET_SELECT_COUNT()) > 0:
                    self.GEN.SEL_MOVE(md_mark, 'no')
                # --反极性surface拷贝至挡点层
                self.GEN.WORK_LAYER(surf_layer)
                self.GEN.SEL_CONTOURIZE()
                # --全部定义属性，以区分
                self.GEN.CUR_ATR_SET('.bit', text='goldboard_cover_cu', reset=1)
                self.GEN.COM('sel_change_atr,mode=add')
                self.GEN.CUR_ART_RESET()
                if Lay in ['md1', 'md2']:
                    # --20200820李家兴修改，档点不用负片套，而用正片补，防止上金
                    self.GEN.SEL_COPY(Lay, 'yes')
                else:
                    self.GEN.SEL_COPY(Lay, 'yes')
                if self.GEN.LAYER_EXISTS(md_mark, job=self.JOB, step='panel') == 'yes':
                    self.GEN.WORK_LAYER(md_mark)
                    self.GEN.SEL_COPY(Lay, 'no')
        self.GEN.DELETE_LAYER(cover_Cu)

    def innTouchDrl_check(self):
        # === 2021.09.17 周涌要求更改钻孔间距更改为 5mm——> 6.5mm 6.35为copy时的上限，直接加大6.5
        check_drl_dis = 6.5
        check_drl_enlarge = check_drl_dis * 2 * 1000
        through_drl = self.parm.drl
        self.GEN.CLEAR_LAYER()
        self.GEN.WORK_LAYER('inn')
        # --仅挑出r3200的孔加大并Copy(当有选择的物体时，进行COPY，并继续下面的操作，否则退出)
        self.GEN.FILTER_SET_INCLUDE_SYMS('r3100', 1)
        self.GEN.FILTER_SELECT()
        self.GEN.FILTER_RESET()
        if self.GEN.GET_SELECT_COUNT() > 0:
            self.GEN.SEL_COPY('__++__inn__++__', 'no', '0')
        else:
            # --正常退出
            return
        self.GEN.WORK_LAYER('__++__inn__++__', 1)
        self.GEN.SEL_RESIZE(check_drl_enlarge)
        # --当step中含有flip时，需要先释放关系，再进行Flatten,完了后，再锁定关系
        # --仅当WIndows下才执行，InCAM下可直接Flaten
        if platform.system() == "Windows":
            data = self.GEN.DO_INFO("-t matrix -e %s/matrix -d COL" % self.JOB, units='mm')
            for stpName in data['gCOLstep_name']:
                # --当存在阴阳step时
                if 'flip' in stpName:
                    self.GEN.OPEN_STEP(stpName, job=self.JOB)
                    self.GEN.COM("change_step_dependency,job=%s,step=%s,operation=release" % (self.JOB, stpName))
            # --还原STEP
            self.GEN.OPEN_STEP(self.STEP, job=self.JOB)
        # --flatten drl层，并touch
        self.GEN.COM("flatten_layer,source_layer=%s,target_layer=__++__drl__++__" % through_drl)
        # --仅当Windows下才执行，InCAM下可直接flatten
        if platform.system() == "Windows":
            data = self.GEN.DO_INFO("-t matrix -e %s/matrix -d COL" % self.JOB, units='mm')
            for stpName in data['gCOLstep_name']:
                # --当存在阴阳step时
                if 'flip' in stpName:
                    self.GEN.OPEN_STEP(stpName, job=self.JOB)
                    self.GEN.COM("change_step_dependency,job=%s,step=%s,operation=restore" % (self.JOB, stpName))
                    self.GEN.COM("update_dependent_step,job=%s,step=%s" % (self.JOB, stpName))
                    # self.GEN.COM("flip_step,job=%s,step=set,flipped_step=%s,new_layer_suffix=_flp,mode=anchor,"
                    #              "board_only=no" % ( self.JOB, stpName))
            # --还原STEP
            self.GEN.OPEN_STEP(self.STEP, job=self.JOB)
        self.GEN.WORK_LAYER('__++__drl__++__', 1)        
        # === 料号名加长更改为50个8，便于识别，同时预留涨缩字样需要长度 ===
        self.GEN.FILTER_RESET()
        #靶孔中心距板内孔6.5 板边孔去掉 20230629 by lyh
        self.GEN.SEL_REF_FEAT('drl', 'touch')
        if self.GEN.GET_SELECT_COUNT() > 0:
            self.GEN.SEL_DELETE()       
        
        #if "-lyh" in self.JOB:
            #self.GEN.PAUSE("dd")
        self.GEN.FILTER_RESET()        
        self.GEN.FILTER_SET_TYP('text')
        self.GEN.FILTER_SELECT()
        if int(self.GEN.GET_SELECT_COUNT()) == 1:
            self.GEN.COM('sel_change_txt,text=%s' % ('8' * 45))
        self.GEN.WORK_LAYER('__++__inn__++__', 1)
        self.GEN.WORK_LAYER('__++__drl__++__', 2)

        self.GEN.FILTER_RESET()
        self.GEN.SEL_REF_FEAT('__++__drl__++__', 'touch')
        if self.GEN.GET_SELECT_COUNT() > 0:
            self.GEN.WORK_LAYER('inn', 3)
            # msg_box = msgBox()
            # msg_box.critical(self, '警告', '%s : inn靶孔层5MM区域有碰到drl层的孔，程序结束后请检查 __++__inn__++__ 层！'
            #                  % self.JOB, QMessageBox.Ok)
            msg_dict = {'type': 'critical',
                        'windowTitle': '警告',
                        'content': '%s : inn靶孔层%s MM区域有碰到drl层的孔，程序结束后请检查 __++__inn__++__ 层！'
                                   % (self.JOB, check_drl_dis)}
            self.msg_array.append(msg_dict)
        else:
            self.GEN.DELETE_LAYER('__++__inn__++__')
            self.GEN.DELETE_LAYER('__++__drl__++__')

    def jobname_touch_bar_check(self):
        """
        料号名和靶相交检查
        :return:
        """
        job_signal_numbers = self.parm.job_signal_numbers
        # === 双面板不检查此项 ===
        if job_signal_numbers <= 2:
            return True

        through_drl = self.parm.drl
        burry_list = self.parm.burry_list
        burry_start = self.parm.burry_start
        burry_end = self.parm.burry_end

        drill_text_layer = '__drl_text__'
        self.GEN.DELETE_LAYER(drill_text_layer)
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(through_drl, 'yes')
        # === 料号名加长更改为50个8，便于识别，同时预留涨缩字样需要长度 ===
        self.GEN.FILTER_RESET()
        self.GEN.FILTER_SET_TYP('text')
        self.GEN.FILTER_SELECT()
        if int(self.GEN.GET_SELECT_COUNT()) == 1:
            self.GEN.SEL_COPY(drill_text_layer)
            self.GEN.AFFECTED_LAYER(through_drl, 'no')
            self.GEN.AFFECTED_LAYER(drill_text_layer, 'yes')
            self.GEN.COM('sel_change_txt,text=%s' % ('8' * 45))
        else:
            msg_dict = {'type': 'critical',
                        'windowTitle': '警告',
                        'content': '%s : 未正常在钻孔层：%s选择到料号名，未进行料号与标靶检查！'
                                   % (self.JOB, through_drl)}
            self.msg_array.append(msg_dict)
            return True
        self.GEN.CLEAR_LAYER()
        tmp_add_bar_sym = '__tmpallbarsym__'
        self.GEN.DELETE_LAYER(tmp_add_bar_sym)
        # === 内层pad参考层建立===
        self.GEN.COM('affected_filter,filter=(side=inner)')
        self.GEN.FILTER_RESET()
        self.GEN.FILTER_SET_TYP('pad\;text')
        self.GEN.FILTER_SET_INCLUDE_SYMS('hdi1-b*t;sh-ldi;hdi-dwpad')
        self.GEN.FILTER_SELECT()
        if int(self.GEN.GET_SELECT_COUNT()) == 0:
            self.GEN.CLEAR_LAYER()
            return True
        self.GEN.SEL_COPY(tmp_add_bar_sym)
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(drill_text_layer, 'yes')
        self.GEN.FILTER_RESET()
        self.GEN.SEL_REF_FEAT(tmp_add_bar_sym, 'touch')
        if self.GEN.GET_SELECT_COUNT() > 0:
            msg_dict = {'type': 'critical',
                        'windowTitle': '警告',
                        'content': '%s : 钻孔料号有碰到标靶，程序结束后请检查层别：%s、%s！' % (
                            self.JOB, drill_text_layer, tmp_add_bar_sym)}
            self.msg_array.append(msg_dict)
        else:
            self.GEN.DELETE_LAYER(drill_text_layer)
            self.GEN.DELETE_LAYER(tmp_add_bar_sym)

        # === 检查埋孔中的料号孔 ===
        for burry_index, cur_burry in enumerate(burry_list):
            burry_text_layer = '__%s_text__' % cur_burry
            self.GEN.DELETE_LAYER(burry_text_layer)
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER(cur_burry, 'yes')
            # === 料号名加长更改为50个8，便于识别，同时预留涨缩字样需要长度 ===
            self.GEN.FILTER_RESET()
            self.GEN.FILTER_SET_TYP('text')
            self.GEN.FILTER_SELECT()
            if int(self.GEN.GET_SELECT_COUNT()) == 1:
                self.GEN.SEL_COPY(burry_text_layer)
                self.GEN.AFFECTED_LAYER(cur_burry, 'no')
                self.GEN.AFFECTED_LAYER(burry_text_layer, 'yes')
                self.GEN.COM('sel_change_txt,text=%s' % ('8' * 45))
            else:
                msg_dict = {'type': 'critical',
                            'windowTitle': '警告',
                            'content': '%s : 未正常在钻孔层：%s选择到料号名，未进行料号与标靶检查！'
                                       % (self.JOB, cur_burry)}
                self.msg_array.append(msg_dict)
                return True
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER(burry_text_layer, 'yes')
            self.GEN.FILTER_RESET()
            ref_layers = '%s\;%s' % (burry_start[burry_index], burry_end[burry_index])
            self.GEN.SEL_REF_FEAT(ref_layers, 'touch', f_type='pad',
                                  include='sh-dwbot;sh-dwtop;s5080;sh-ldi;hdi-dwpad;hdi1-b*')
            # --删除与埋孔对应层别symbol touch到的防爆孔
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                msg_dict = {'type': 'critical',
                            'windowTitle': '警告',
                            'content': '%s : 钻孔料号有碰到标靶，程序结束后请检查层别：%s、%s！' % (
                                self.JOB, burry_text_layer, ref_layers)}
                self.msg_array.append(msg_dict)
            else:
                self.GEN.DELETE_LAYER(burry_text_layer)

        return True

    def TouchSRCheck(self):
        """
        检测内容物是否进入子排版
        :return:
        :rtype:
        """
        assist_layer = self.parm.assist_layer
        TmpErrLayer = []
        fill_steps = []
        SrTmpErrLayerSuffix = '_sr-err+'
        # --填充子排版
        self.GEN.DELETE_LAYER('create_copper')
        self.GEN.DELETE_LAYER('flat_copper')
        self.GEN.CREATE_LAYER('create_copper')
        info = self.GEN.DO_INFO('-t step -e %s/panel -m script -d SR -p step' % self.JOB)
        for step in info['gSRstep']:
            # --排除一些没有挖空的step
            # if step not in ['lp','2nd','fafa','szlp','fa']:
            if step not in ['drl', 'lp', '2nd', 'fafa', 'szlp', 'fa']:
                if step not in fill_steps and step not in self.parm.tail_hole_list:
                    fill_steps.append(step)
        for step in fill_steps:
            self.GEN.OPEN_STEP(step, job=self.JOB)
            self.GEN.CLEAR_LAYER()
            self.GEN.COM('units,type=mm')
            self.GEN.AFFECTED_LAYER('create_copper', 'yes')
            self.GEN.COM('fill_params,type=solid,origin_type=datum,solid_type=surface')
            self.GEN.COM("sr_fill,polarity=positive,step_margin_x=0,step_margin_y=0,step_max_dist_x=2540,"
                         "step_max_dist_y=2540,sr_margin_x=-2540,sr_margin_y=-2540,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                         "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
            self.GEN.CLEAR_LAYER()
            self.GEN.COM('editor_page_close')
        # --在panel中将填充的子排版flatten出来
        self.GEN.OPEN_STEP('panel', job=self.JOB)
        self.GEN.CLEAR_LAYER()
        flip_steps = []
        # --仅当Windows下才执行，InCAM下可直接flatten
        if platform.system() == "Windows":
            data = self.GEN.DO_INFO("-t matrix -e %s/matrix -d COL" % self.JOB, units='mm')
            for stpName in data['gCOLstep_name']:
                # --当存在阴阳step时
                if 'flip' in stpName:
                    flip_steps.append(stpName)
                    self.GEN.COM("change_step_dependency,job=%s,step=%s,operation=release" % (self.JOB, stpName))
        self.GEN.COM("flatten_layer,source_layer=create_copper,target_layer=flat_copper")
        if flip_steps:
            # --还原STEP
            for stpName in flip_steps:
                self.GEN.COM("change_step_dependency,job=%s,step=%s,operation=restore" % (self.JOB, stpName))
                self.GEN.COM("update_dependent_step,job=%s,step=%s" % (self.JOB, stpName))

        self.GEN.AFFECTED_LAYER('flat_copper', 'yes')
        # --监控范围内缩25um，保证误差
        self.GEN.COM('sel_resize,size=-50,corner_ctl=no')
        self.GEN.AFFECTED_LAYER('flat_copper', 'no')
        # --所有board层打影响层一起检查
        self.GEN.COM(
            'affected_filter,filter=(type=signal|power_ground|mixed|solder_mask|silk_screen|solder_paste|drill|rout&context=board)')
        # self.GEN.AFFECTED_LAYER('panel_map','yes')
        if len(assist_layer) > 0:
            for cur_ssist_layer in assist_layer:
                self.GEN.AFFECTED_LAYER(cur_ssist_layer, 'no')

        self.GEN.COM('get_affect_layer')
        layers = self.GEN.COMANS.split()
        self.GEN.SEL_REF_FEAT('flat_copper', 'touch')
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            for layer in layers:
                # --每一层DO_INFO,若没有选中物件,以下四个值都会是0
                info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -m script -d LIMITS -o select' % (self.JOB, layer))
                if info['gLIMITSxmin'] != '0' or info['gLIMITSymin'] != '0' or info['gLIMITSxmax'] != '0' or info[
                    'gLIMITSymax'] != '0':
                    TmpErrLayer.append(layer)
            self.GEN.CLEAR_LAYER()

            # --有touch的选中物件并copy到辅助层
            for layer in TmpErrLayer:
                tTmpErrLayer = layer + SrTmpErrLayerSuffix
                self.GEN.AFFECTED_LAYER(layer, 'yes')
                self.GEN.SEL_REF_FEAT('flat_copper', 'touch')
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.SEL_COPY(tTmpErrLayer)
                self.GEN.AFFECTED_LAYER(layer, 'no')
            self.GEN.CLEAR_LAYER()
        else:
            self.GEN.CLEAR_LAYER()
        # === 单独检测辅助层别 ===
        if len(assist_layer) > 0:
            for cur_ssist_layer in assist_layer:
                self.GEN.AFFECTED_LAYER(cur_ssist_layer, 'yes')
            self.GEN.COM('get_affect_layer')
            layers = self.GEN.COMANS.split()
            self.GEN.FILTER_RESET()
            self.GEN.FILTER_SET_TYP('pad;text;arc;line')
            self.GEN.SEL_REF_FEAT('flat_copper', 'touch')
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                for layer in layers:
                    # --每一层DO_INFO,若没有选中物件,以下四个值都会是0
                    info = self.GEN.DO_INFO(
                        '-t layer -e %s/panel/%s -m script -d LIMITS -o select' % (self.JOB, layer))
                    if info['gLIMITSxmin'] != '0' or info['gLIMITSymin'] != '0' or info['gLIMITSxmax'] != '0' or info[
                        'gLIMITSymax'] != '0':
                        TmpErrLayer.append(layer)
                self.GEN.CLEAR_LAYER()

                # --有touch的选中物件并copy到辅助层
                for layer in TmpErrLayer:
                    tTmpErrLayer = layer + SrTmpErrLayerSuffix
                    self.GEN.AFFECTED_LAYER(layer, 'yes')
                    self.GEN.SEL_REF_FEAT('flat_copper', 'touch')
                    count = self.GEN.GET_SELECT_COUNT()
                    if count > 0:
                        self.GEN.SEL_COPY(tTmpErrLayer)
                    self.GEN.AFFECTED_LAYER(layer, 'no')
                self.GEN.CLEAR_LAYER()
            else:
                self.GEN.CLEAR_LAYER()

        # --删除辅助层
        self.GEN.DELETE_LAYER('flat_copper')
        self.GEN.DELETE_LAYER('create_copper')
        if len(TmpErrLayer) > 0:
            # msg_box = msgBox()
            # msg_box.critical(self, '错误', '料号 %s : 检测到以下Layer:\n %s \n有内容物进板内,具体位置请查看对应的 %s 层, 请确认!'
            #                  % (self.JOB,TmpErrLayer,SrTmpErrLayerSuffix), QMessageBox.Ok)
            msg_dict = {'type': 'critical',
                        'windowTitle': '错误',
                        'content': '料号 %s : 检测到以下Layer:\n %s \n有内容物进板内,具体位置请查看对应的 %s 层, 请确认!'
                                   % (self.JOB, ','.join(TmpErrLayer), SrTmpErrLayerSuffix)}
            self.msg_array.append(msg_dict)
        else:
            # msg_box = msgBox()
            # msg_box.information(self, '完成', '%s panel脚本运行完成！\n未检测到有内容物进板内!' % self.JOB, QMessageBox.Ok)
            msg_dict = {'type': 'information',
                        'windowTitle': '完成',
                        'content': '%s panel脚本运行完成！\n未检测到有内容物进板内!' % self.JOB}
            self.msg_array.append(msg_dict)            
            
    def gold_open_touch_cu_check(self):
        """
        电金层开窗当XY均有金手指时，检测开窗边距板内铜是否大于20mm
        gold-c/gold-s
        :return:
        """
        sel_finger = self.parm.sel_finger
        g_direction = self.parm.g_direction
        # 因为现在更新不需要选择金手指方向，是按照开料尺寸 故只判断是的条件即可
        # 20230221 工艺要求恢复手指选择
        #if sel_finger != "是":
            #return
        
        if self.GEN.LAYER_EXISTS("gold-c", self.JOB, "panel") == "no" and \
           self.GEN.LAYER_EXISTS("gold-s", self.JOB, "panel") == "no":
            return
        
        if sel_finger == "是" and g_direction == "XY均有":
            pass
        else:
            return
        outer_layers = self.parm.out_signal_array
        top_layer = outer_layers[0]
        bot_layer = outer_layers[1]
        tmp_top_layer = '__tmp_%s_' % top_layer
        tmp_bot_layer = '__tmp_%s_' % bot_layer
        pnl_top_layer = '__pnltmp_%s_' % top_layer
        pnl_bot_layer = '__pnltmp_%s_' % bot_layer
        self.GEN.DELETE_LAYER(tmp_top_layer)
        self.GEN.DELETE_LAYER(tmp_bot_layer)
        self.GEN.DELETE_LAYER(pnl_top_layer)
        self.GEN.DELETE_LAYER(pnl_bot_layer)
        self.GEN.OPEN_STEP(job=self.JOB, step='edit')
        self.GEN.COM('units,type=mm')
        self.GEN.CLEAR_LAYER()
        self.GEN.COM('optimize_levels, layer = %s, opt_layer = %s, levels = 3' % (top_layer, tmp_top_layer))
        self.GEN.COM('optimize_levels, layer = %s, opt_layer = %s, levels = 3' % (bot_layer, tmp_bot_layer))
        self.GEN.CLOSE_STEP()
        self.GEN.OPEN_STEP(job=self.JOB, step='panel')
        self.GEN.CLEAR_LAYER()
        self.GEN.COM('flatten_layer,source_layer=%s,target_layer=%s' % (tmp_top_layer, pnl_top_layer))
        self.GEN.COM('flatten_layer,source_layer=%s,target_layer=%s' % (tmp_bot_layer, pnl_bot_layer))

        self.GEN.DELETE_LAYER(tmp_top_layer)
        self.GEN.DELETE_LAYER(tmp_bot_layer)

        # self.GEN.AFFECTED_LAYER(pnl_top_layer,'yes')
        # self.GEN.SEL_RESIZE('40000')
        if self.GEN.LAYER_EXISTS("gold-c", self.JOB, "panel") == "yes":
            self.GEN.AFFECTED_LAYER('gold-c', 'yes')
            self.GEN.FILTER_RESET()
            self.GEN.FILTER_SET_TYP('surface')
            self.GEN.FILTER_SELECT()
            if int(self.GEN.GET_SELECT_COUNT()) == 1:
                self.GEN.SEL_RESIZE('40000')
                self.GEN.SEL_REF_FEAT(pnl_top_layer, 'touch')
                if int(self.GEN.GET_SELECT_COUNT()) != 0:
                    msg_dict = {'type': 'warning',
                                'windowTitle': '警告',
                                'content': 'Top面镀金开窗距板内铜不足20mm'}
                    self.msg_array.append(msg_dict)
                else:
                    self.GEN.DELETE_LAYER(pnl_top_layer)
                self.GEN.SEL_RESIZE('-40000')
            else:
                msg_dict = {'type': 'warning',
                            'windowTitle': '警告',
                            'content': 'gold-c层别铜皮数量不是1'}
                self.msg_array.append(msg_dict)
                self.GEN.DELETE_LAYER(pnl_top_layer)
            self.GEN.AFFECTED_LAYER('gold-c', 'no')
            
        if self.GEN.LAYER_EXISTS("gold-s", self.JOB, "panel") == "yes":
            self.GEN.AFFECTED_LAYER('gold-s', 'yes')
            self.GEN.FILTER_RESET()
            self.GEN.FILTER_SET_TYP('surface')
            self.GEN.FILTER_SELECT()
            if int(self.GEN.GET_SELECT_COUNT()) == 1:
                self.GEN.SEL_RESIZE('40000')
                self.GEN.SEL_REF_FEAT(pnl_bot_layer, 'touch')
                if int(self.GEN.GET_SELECT_COUNT()) != 0:
                    msg_dict = {'type': 'warning',
                                'windowTitle': '警告',
                                'content': 'Bot面镀金开窗距板内铜不足20mm'}
                    self.msg_array.append(msg_dict)
                else:
                    self.GEN.DELETE_LAYER(pnl_bot_layer)
                self.GEN.SEL_RESIZE('-40000')
            else:
                msg_dict = {'type': 'warning',
                            'windowTitle': '警告',
                            'content': 'gold-s层别铜皮数量不是1'}
                self.msg_array.append(msg_dict)
                self.GEN.DELETE_LAYER(pnl_bot_layer)
            self.GEN.AFFECTED_LAYER('gold-s', 'no')

    def add_sm_md_eagle_pad(self):
        """
        防焊挡点做鹰眼pad套铜
        :return:
        """
        out_signal_array = self.parm.out_signal_array
        mini_led = self.parm.mini_led
        top_signal_layer = out_signal_array[0]
        bot_signal_layer = out_signal_array[1]
        info = {}
        top_x_list = [None]
        top_y_list = [None]
        bot_x_list = [None]
        bot_y_list = [None]

        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(top_signal_layer, 'yes')
        self.GEN.FILTER_RESET()
        self.GEN.FILTER_SET_TYP('pad')
        self.GEN.FILTER_SET_INCLUDE_SYMS("eagle-mark-dot")
        self.GEN.FILTER_SELECT()
        self.GEN.FILTER_RESET()

        if int(self.GEN.GET_SELECT_COUNT()) > 0:
            feature_line = self.GEN.INFO(
                "-t layer -e %s/%s/%s -d FEATURES -o select, units=mm" % (self.JOB, 'panel', top_signal_layer))
            SF = SplitFeature()
            features_dict = SF.parseFeatureInfo(feature_line)
            # print  features_dict
            top_x_list = [features_dict['pads'][i].x for i in range(len(features_dict['pads']))]
            top_y_list = [features_dict['pads'][i].y for i in range(len(features_dict['pads']))]
        self.GEN.CLEAR_LAYER()

        self.GEN.AFFECTED_LAYER(bot_signal_layer, 'yes')
        self.GEN.FILTER_RESET()
        self.GEN.FILTER_SET_TYP('pad')
        self.GEN.FILTER_SET_INCLUDE_SYMS("eagle-mark-dot")
        self.GEN.FILTER_SELECT()
        self.GEN.FILTER_RESET()

        if int(self.GEN.GET_SELECT_COUNT()) > 0:
            feature_line = self.GEN.INFO(
                "-t layer -e %s/%s/%s -d FEATURES -o select, units=mm" % (self.JOB, 'panel', bot_signal_layer))
            SF = SplitFeature()
            features_dict = SF.parseFeatureInfo(feature_line)
            # print  features_dict
            bot_x_list = [features_dict['pads'][i].x for i in range(len(features_dict['pads']))]
            bot_y_list = [features_dict['pads'][i].y for i in range(len(features_dict['pads']))]
        self.GEN.CLEAR_LAYER()
        sta = STATIC_SYM()
        pn_seven = self.JOB[6]
        # === V2.01 当LED板为OSP表面处理时，加防焊开窗及挡点 ===
        if mini_led or pn_seven in ['p']:
            add_pol = 'positive'
            add_sym_sm = 's3110'
            add_sym_dot = 's3160'
        else:
            add_pol = 'negative'
            add_sym_sm = 's3516'
            add_sym_dot = 's3516'

        info['档点c'] = sta.convert_to_dict(x_list=top_x_list, y_list=top_y_list, symbol=add_sym_dot, polarity=add_pol)
        info['防焊c'] = sta.convert_to_dict(x_list=top_x_list, y_list=top_y_list, symbol=add_sym_sm, polarity=add_pol)
        info['档点s'] = sta.convert_to_dict(x_list=bot_x_list, y_list=bot_y_list, symbol=add_sym_dot, polarity=add_pol)
        info['防焊s'] = sta.convert_to_dict(x_list=bot_x_list, y_list=bot_y_list, symbol=add_sym_sm, polarity=add_pol)

        sta.add_symbol(info)


class RECTANGLE(object):
    """
    每一个独立的symbol抽象成一个矩形，为了简单起见，圆pad也当成矩形
    """

    def __init__(self, symbol=None, xmin=0.0, ymin=0.0, xmax=0.0, ymax=0.0):
        # --为防止起始坐标和结束坐标互换，再次取值
        self.xmin = min(xmin, xmax)
        self.ymin = min(ymin, ymax)
        self.xmax = max(xmax, xmin)
        self.ymax = max(ymax, ymin)
        self.xc = self.xmin + (self.xmax - self.xmin) / 2
        self.yc = self.ymin + (self.ymax - self.ymin) / 2
        self.area = self.get_lenX() * self.get_lenY()
        self.symbol = symbol

    def __repr__(self):
        """
        字符串表示形式
        :return:
        :rtype:
        """
        return 'RECTANGLE(symbol="%s",xmin=%s,ymin=%s,xmax=%s,ymax=%s)' \
               % (self.symbol, self.xmin, self.ymin, self.xmax, self.ymax)

    def __eq__(self, other):
        """
        判断self和other是否相等，other==self,并不代表self==other,小的等于大的，但大的不等于小的，从而可以去掉小area
        :param other:
        :type other:
        :return:
        :rtype:
        """
        if self.xmin == other.xmin and self.xmax == other.xmax and self.ymin == other.ymin and self.ymax == other.ymax:
            return True
        elif math.fabs(self.xc - other.xc) < 0.1 and math.fabs(self.yc - other.yc) < 0.1 and self.area < other.area:
            # --同一位置添加的symbol,取area最大的避开
            return True
        elif other.xmin > self.xmin and other.xmax < self.xmax and other.ymin > self.ymin and other.ymax < self.ymax:
            # --self==other的情况
            return True
        elif self.xmin > other.xmin and self.xmax < other.xmax and self.ymin > other.ymin and self.ymax < other.ymax:
            # --other==self的情况
            return True
        else:
            return False
        
    def check_diff(self, other):
        """判断两个是否一样"""
        if self.symbol == other.symbol and self.xmin == other.xmin and self.xmax == other.xmax and self.ymin == other.ymin and self.ymax == other.ymax:
            return True
        
        return False

    def get_lenX(self):
        """
        攻取x方向的长度
        :return: 长度
        :rtype: float
        """
        return self.xmax - self.xmin

    def get_lenY(self):
        """
        攻取y方向的长度
        :return: 长度
        :rtype: float
        """
        return self.ymax - self.ymin

    def touch(self, other):
        """
        判断两个矩形是否相交
        :param other: 判断相交的另一个矩形obj
        :type other: RECTANGLE object
        :return: True or False
        :rtype: bool
        """
        # --定义当前矩形的左下角Ax1,Ay1和右上角Ax2,Ay2坐标
        lenAx = self.get_lenX()
        lenAy = self.get_lenY()
        # --定义other矩形的左下角Bx1,By1和右上角Bx2,By2坐标
        lenBx = other.get_lenX()
        lenBy = other.get_lenY()
        # --计算两个矩形坐标中的最大值、最小值
        min_x = min(self.xmin, other.xmin)
        min_y = min(self.ymin, other.ymin)
        max_x = max(self.xmax, other.xmax)
        max_y = max(self.ymax, other.ymax)
        # --判断两个矩形是否相交
        #if max(self.xmin, other.xmin) < min(self.xmax, other.xmax) and \
                #max(self.ymin, other.ymin) < min(self.ymax, other.ymax):
            #return True
        #else:
            #return False
            
        if max_x - min_x < lenAx + lenBx and max_y - min_y < lenAy + lenBy:
            # --x方向最大值最小值之差小于两个矩形x方向总长，且y方向最大值最小值之差也小于两个矩形y方向总长
            return True
        else:
            return False


class STATIC_SYM(object):
    """
    定义静态symbol类
    """

    def __init__(self, priority=None, avoidType='all'):
        self.JOB = os.environ.get('JOB', None)
        self.clearance = 0.2
        self.priority = priority
        self.GEN = genCOM.GEN_COM()
        self.avoidType = avoidType
        # --初始pad字典
        self.info_orig = {
            'x': 0,
            'y': 0,
            'nx': 1,
            'ny': 1,
            'dx': 0,
            'dy': 0,
            'angle': 0,
            'symbol': None,
            'mirror': 'no',
            'polarity': 'positive',
            'attribute': None,
        }
        # --初始line字典
        self.info_orig_line = {
            'xs': 0,
            'ys': 0,
            'xe': 1,
            'ye': 1,
            'symbol': None,
            'polarity': 'positive',
            'attribute': None,
        }
        # --初始text字典
        self.info_orig_text = {
            'x': 0,
            'y': 0,
            'text': '',
            'x_size': 1,
            'y_size': 1,
            'w_factor': 1,
            'angle': 0,
            'mirror': 'no',
            'polarity': 'positive',
            'fontname': 'standard',
            'attribute': None,
        }
        # --初始barcode字典
        self.info_orig_barcode = {
            'x': 0,
            'y': 0,
            'text': '',
            'angle': 0,
            'mirror': 'no',
            'polarity': 'positive',
            'attribute': None,
            'matrix': 'Minimal',
            'bar_type': 'ecc-200',
            'bar_background': 'no',
            'bar_add_string': 'no',
            'bar_height': 7,
            'type': 'barcode',
        }
        # --错误及警告信息收集数组
        self.msg_array = []

    def update_symbol(self, name):
        """
        更新symbol
        :return:
        :rtype:
        """
        info = self.GEN.DO_INFO('-t symbol -e %s/%s -m script -d EXISTS' % (self.JOB, name))
        if info['gEXISTS']:
            if platform.system() == "Linux" and PRODUCT is not None:
                self.GEN.COM('import_lib_item_to_job,src_category=symbols,src_profile=system,src_customer=,'
                             'dst_names=%s' % name)
            else:
                self.GEN.COM('copy_entity,type=symbol,source_job=genesislib,source_name=%s,dest_job=%s,dest_name=%s,'
                             'dest_database=' % (name, self.JOB, name))

    def get_sym_LIMITS(self, sym_name, sym_angle=0, mirror='no', x=0.0, y=0.0, return_type='area'):
        """
        获取symbol宽度和高度
        :return:
        :rtype:
        """
        if platform.system() == "Linux" and PRODUCT is not None:
            sym_path = '/incam/server/site_data/library/symbols'
        else:
            sym_path = "%s/fw/lib/symbols" % (os.environ.get('GENESIS_DIR', 'D:/genesis'))
        # --如果symbol路径不存在,则表示不是系统symbol,此处用绝对路径是下策,因为incam不存在genesislib,不能用DO_INFO来确定symbol
        sym_path = os.path.join(sym_path, sym_name)
        if not os.path.exists(sym_path):
            lenth, width = None, None
            if sym_name.startswith('s'):
                # --系统symbol如s3810等
                width = sym_name.strip('s')
                width = float(width) / 1000
                lenth = width
            elif sym_name.startswith('rect'):
                # --此处的rect5000x10000暂未考虑方向
                split_array = sym_name.strip('rect').split('x')
                if len(split_array) == 3:
                    lenth, width, _ = sym_name.strip('rect').split('x')
                else:
                    lenth, width = sym_name.strip('rect').split('x')
                width = float(width) / 1000
                lenth = float(lenth) / 1000
            elif sym_name.startswith('r'):
                if sym_name == 'r0':
                    return lenth, width
                # --系统symbol如r3175等
                width = sym_name.strip('r')
                width = float(width) / 1000
                lenth = width
            if return_type == 'area':
                return lenth, width
            else:
                xmin = x - lenth / 2
                xmax = x + lenth / 2
                ymin = y - width / 2
                ymax = y + width / 2
                if sym_angle in [0, 180]:
                    xmin = x - lenth / 2
                    xmax = x + lenth / 2
                    ymin = y - width / 2
                    ymax = y + width / 2
                elif sym_angle in [90, 270]:
                    # --旋转90度x,y互换
                    xmin = x - width / 2
                    xmax = x + width / 2
                    ymin = y - lenth / 2
                    ymax = y + lenth / 2
                        
                return xmin, ymin, xmax, ymax
        # --如果symbol不存在当前料号中,则从lib库中copy到当前料号
        info = self.GEN.DO_INFO('-t symbol -e %s/%s -m script -d EXISTS' % (self.JOB, sym_name))
        if info['gEXISTS'] == "no":
            self.update_symbol(sym_name)
        # --通过在当前料号DO_INFO获取长宽
        info = self.GEN.DO_INFO('-t symbol -e %s/%s -m script -d LIMITS' % (self.JOB, sym_name))
        if sym_angle != 0:
            # --旋转90度
            width = float(info['gLIMITSxmax']) - float(info['gLIMITSxmin'])
            lenth = float(info['gLIMITSymax']) - float(info['gLIMITSymin'])
        else:
            lenth = float(info['gLIMITSxmax']) - float(info['gLIMITSxmin'])
            width = float(info['gLIMITSymax']) - float(info['gLIMITSymin'])
        if return_type == 'area':
            return lenth, width
        else:
            if sym_angle == 0:
                if mirror == 'no':
                    xmin = x + float(info['gLIMITSxmin'])
                    ymin = y + float(info['gLIMITSymin'])
                    xmax = x + float(info['gLIMITSxmax'])
                    ymax = y + float(info['gLIMITSymax'])
                else:
                    xmin = x - float(info['gLIMITSxmax'])
                    ymin = y + float(info['gLIMITSymin'])
                    xmax = x - float(info['gLIMITSxmin'])
                    ymax = y + float(info['gLIMITSymax'])
            elif sym_angle == 90:
                # --旋转90度x,y互换
                if mirror == 'no':
                    xmin = x + float(info['gLIMITSymin'])
                    ymin = y - float(info['gLIMITSxmax'])
                    xmax = x + float(info['gLIMITSymax'])
                    ymax = y - float(info['gLIMITSxmin'])
                else:
                    xmin = x - float(info['gLIMITSymax'])
                    ymin = y - float(info['gLIMITSxmax'])
                    xmax = x - float(info['gLIMITSymin'])
                    ymax = y - float(info['gLIMITSxmin'])
            elif sym_angle == 180:
                # --旋转180度xmax和xmin互换,ymax和ymin互换
                if mirror == 'no':
                    xmin = x - float(info['gLIMITSxmax'])
                    ymin = y - float(info['gLIMITSymax'])
                    xmax = x - float(info['gLIMITSxmin'])
                    ymax = y - float(info['gLIMITSymin'])
                else:
                    xmin = x + float(info['gLIMITSxmin'])
                    ymin = y - float(info['gLIMITSymax'])
                    xmax = x + float(info['gLIMITSxmax'])
                    ymax = y - float(info['gLIMITSymin'])
            elif sym_angle == 270:
                # --旋转270度x,y互换
                if mirror == 'no':
                    xmin = x - float(info['gLIMITSymax'])
                    ymin = y + float(info['gLIMITSxmin'])
                    xmax = x - float(info['gLIMITSymin'])
                    ymax = y + float(info['gLIMITSxmax'])
                else:
                    xmin = x + float(info['gLIMITSymin'])
                    ymin = y + float(info['gLIMITSxmin'])
                    xmax = x + float(info['gLIMITSymax'])
                    ymax = y + float(info['gLIMITSxmax'])
            else:
                # msg_box = msgBox()
                # msg_box.critical(self, '错误', 'symbol添加角度错误,只能是0,90,180,270,\n当前symbol角度为:%s' % sym_angle,
                #                  QMessageBox.Ok)
                msg_dict = {'type': 'critical',
                            'windowTitle': '错误',
                            'content': 'symbol添加角度错误,只能是0,90,180,270,\n当前symbol角度为:%s' % sym_angle}
                self.msg_array.append(msg_dict)
                # --因为考虑到socket运行模式,所以不能直接调用sys.exit(),而是向上抛出异常，供上一级捕获
                raise SystemExit
                # sys.exit()
            return xmin, ymin, xmax, ymax

    def get_rectangles(self, sym_name, sym_angle=0, mirror='no', type='pad', x=0.0, y=0.0, xs=None, ys=None, xe=None,
                       ye=None):
        """
        获取symbol的矩形列表，包括复合symbol，如chris_innnew_b1等
        :return: RECTANGLE矩形object
        :rtype: object
        """
        rect_list = []
        if type == 'line':
            width = sym_name.strip('r|s')
            width = float(width) / 1000
            if xs < xe:
                xmin = xs - width / 2 - self.clearance
                xmax = xe + width / 2 + self.clearance
            else:
                xmin = xe - width / 2 - self.clearance
                xmax = xs + width / 2 + self.clearance
            if ys < ye:
                ymin = ys - width / 2 - self.clearance
                ymax = ye + width / 2 + self.clearance
            else:
                ymin = ye - width / 2 - self.clearance
                ymax = ys + width / 2 + self.clearance
            rect = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
            rect_list.append(rect)
        elif sym_name in ['chris_innnew1_a', 'chris_innnew1_b']:
            # --小多普要避开的四个光学点，返回两个矩形
            xmin = x - 275.5 - 4 - self.clearance
            xmax = x - 275.5 + 4 + self.clearance
            # --上光学点
            ymin = y + 90 - 4 - self.clearance
            ymax = y + 110 + 4 + self.clearance
            rect1 = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
            # --下光学点
            ymin = y - 110 - 4 - self.clearance
            ymax = y - 90 + 4 + self.clearance
            rect2 = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
            rect_list.extend([rect1, rect2])
        elif sym_name in ['chris-dp-po-top', 'chris-dp-po-bot']:
            # --大多普需要避开的两个光学点，在左长边,光学点宽14mm,中心距symbol中心9mm
            xmin = x + 9 - 7 - self.clearance
            xmax = x + 9 + 7 + self.clearance
            # --上光学点
            ymin = y + 75.6135 - 7 - self.clearance
            ymax = y + 75.6135 + 7 + self.clearance
            rect1 = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
            # --下光学点
            ymin = y - 76.3865 - 7 - self.clearance
            ymax = y - 76.3865 + 7 + self.clearance
            rect2 = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
            rect_list.extend([rect1, rect2])
        elif sym_name in ['sh-outpganew', 'sh-outpgbnew', 'chris-outpganew3', 'chris-outpgbnew3', 'sh-outpganew3',
                          'sh-outpgbnew3']:
            # --外层菲林框不产生避开区域
            pass
        elif sym_name in ['laser3-sh', 'laser2-sh', 'laser5-sh', 'laser-sm-sh']:
            # --响度测试pad不产生避开区域,panel_map中有rect17280x8380避开区域
            pass
        else:
            # --其它的单个独立的symbol
            lenth, width = self.get_sym_LIMITS(sym_name)
            if lenth is None and width is None:
                # --排除是0的情况
                pass
            else:
                xmin, ymin, xmax, ymax = self.get_sym_LIMITS(sym_name, sym_angle=sym_angle, mirror=mirror, x=x, y=y,
                                                             return_type='limits')
                xmin = xmin - self.clearance
                xmax = xmax + self.clearance
                ymin = ymin - self.clearance
                ymax = ymax + self.clearance
                rect = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
                rect_list.append(rect)
        return rect_list

    def convert_to_dict(self, x_list=None, y_list=None, xe_list=None, ye_list=None, x_size=None, y_size=None,
                        symbol=None, text=None, polarity=None, angle=None, mirror=None, fontname=None,
                        nx=None, ny=None, dx=None, dy=None, w_factor=None, attribute=None, bar_type=None,
                        matrix=None, bar_background=None, bar_add_string=None, bar_height=None, type=None):
        """
        根据提供的坐标、symbol、极性等信息，生成字典
        :return: info_list字典的列表
        :rtype:
        """
        if x_list is None or y_list is None:
            return []
        info_list = []
        for i, (x, y) in enumerate(zip(x_list, y_list)):
            if xe_list and ye_list:
                # --线
                info_dict = dict(self.info_orig_line)
                info_dict['xs'] = x
                info_dict['ys'] = y
                xe = xe_list[i]
                ye = ye_list[i]
                info_dict['xe'] = xe
                info_dict['ye'] = ye
            else:
                if text:
                    # --文字
                    if bar_type:
                        # === 二维码
                        info_dict = dict(self.info_orig_barcode)
                    else:
                        info_dict = dict(self.info_orig_text)
                else:
                    # --pad
                    info_dict = dict(self.info_orig)
                info_dict['x'] = x
                info_dict['y'] = y
            if x_size:
                if isinstance(x_size, MutableSequence):
                    # --如果提供的symbol是一个列表
                    info_dict['x_size'] = x_size[i]
                else:
                    # --如果提供的symbol是字符串
                    info_dict['x_size'] = x_size
            if y_size:
                if isinstance(y_size, MutableSequence):
                    # --如果提供的symbol是一个列表
                    info_dict['y_size'] = y_size[i]
                else:
                    # --如果提供的symbol是字符串
                    info_dict['y_size'] = y_size
            if text:
                if isinstance(text, MutableSequence):
                    # --如果提供的symbol是一个列表
                    info_dict['text'] = text[i]
                else:
                    # --如果提供的symbol是字符串
                    info_dict['text'] = text
            if symbol:
                if isinstance(symbol, MutableSequence):
                    # --如果提供的symbol是一个列表
                    info_dict['symbol'] = symbol[i]
                else:
                    # --如果提供的symbol是字符串
                    info_dict['symbol'] = symbol
            if polarity:
                if isinstance(polarity, MutableSequence):
                    # --如果提供的polarity是一个列表
                    info_dict['polarity'] = polarity[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['polarity'] = polarity
            if angle:
                if isinstance(angle, MutableSequence):
                    # --如果提供的angle是一个列表
                    info_dict['angle'] = angle[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['angle'] = angle
            if mirror:
                if isinstance(mirror, MutableSequence):
                    # --如果提供的mirror是一个列表
                    info_dict['mirror'] = mirror[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['mirror'] = mirror
            if attribute:
                if isinstance(attribute, MutableSequence):
                    # --如果提供的attribute是一个列表
                    info_dict['attribute'] = attribute[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['attribute'] = attribute
            if nx:
                if isinstance(nx, MutableSequence):
                    # --如果提供的nx是一个列表
                    info_dict['nx'] = nx[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['nx'] = nx
            if ny:
                if isinstance(ny, MutableSequence):
                    # --如果提供的ny是一个列表
                    info_dict['ny'] = ny[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['ny'] = ny
            if dx:
                if isinstance(dx, MutableSequence):
                    # --如果提供的dx是一个列表
                    info_dict['dx'] = dx[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['dx'] = dx
            if dy:
                if isinstance(dy, MutableSequence):
                    # --如果提供的dy是一个列表
                    info_dict['dy'] = dy[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['dy'] = dy
            if w_factor:
                if isinstance(w_factor, MutableSequence):
                    # --如果提供的dy是一个列表
                    info_dict['w_factor'] = w_factor[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['w_factor'] = w_factor
            if fontname:
                if isinstance(fontname, MutableSequence):
                    # --如果提供的dy是一个列表
                    info_dict['fontname'] = fontname[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['fontname'] = fontname
            # === 二维码相关
            if bar_type:
                if isinstance(fontname, MutableSequence):
                    # --如果提供的bar_type是一个列表
                    info_dict['bar_type'] = bar_type[i]
                else:
                    # --如果提供的bar_type是字符串
                    info_dict['bar_type'] = bar_type
            if matrix:
                if isinstance(matrix, MutableSequence):
                    # --如果提供的matrix是一个列表
                    info_dict['matrix'] = matrix[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['matrix'] = matrix
            if bar_background:
                if isinstance(bar_background, MutableSequence):
                    # --如果提供的bar_background是一个列表
                    info_dict['bar_background'] = bar_background[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['bar_background'] = bar_background
            if bar_add_string:
                if isinstance(bar_add_string, MutableSequence):
                    # --如果提供的bar_add_string是一个列表
                    info_dict['bar_add_string'] = bar_add_string[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['bar_add_string'] = bar_add_string
            if bar_height:
                if isinstance(bar_height, MutableSequence):
                    # --如果提供的bar_height是一个列表
                    info_dict['bar_height'] = bar_height[i]
                else:
                    # --如果提供的polarity是字符串
                    info_dict['bar_height'] = bar_height
            info_list.append(info_dict)
        return info_list

    def get_sym_info(self):
        """
        获取symbol添加时的坐标中心
        :return: 字典的列表，保持symbol有序添加
        :rtype:
        """
        info_list = []
        info_list.append(self.info_orig)
        info_dict = {
            '钻孔': info_list,
        }
        return info_dict

    def add_symbol(self, info=None):
        """
        添加单个symbol
        :return: symbol_area当前symbol所占用的区域
        :rtype: list
        """
        symbol_area = []
        if info is None:
            info = self.get_sym_info()
        for layer_type, coord_list in info.items():
            sub_loop = defaultdict(list)
            self.GEN.CLEAR_LAYER()
            if layer_type == '外层':
                self.GEN.COM('affected_filter,filter=(type=signal|power_ground&context=board&side=top|bottom)')
            elif layer_type == '外层c':
                self.GEN.COM('affected_filter,filter=(type=signal|power_ground&context=board&side=top)')
            elif layer_type == '外层s':
                self.GEN.COM('affected_filter,filter=(type=signal|power_ground&context=board&side=bottom)')
            elif layer_type == '次外层':
                sub_outer = self.parm.sub_outer
                if len(sub_outer):
                    self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % sub_outer[0])
                    self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % sub_outer[1])
            elif layer_type == '次外层c':
                sub_outer = self.parm.sub_outer
                if len(sub_outer):
                    self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % sub_outer[0])
            elif layer_type == '次外层s':
                sub_outer = self.parm.sub_outer
                if len(sub_outer):
                    self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % sub_outer[1])
            elif layer_type == '防焊':
                self.GEN.COM('affected_filter,filter=(type=solder_mask&context=board&side=top|bottom)')
            elif layer_type == '防焊c':
                self.GEN.COM('affected_filter,filter=(type=solder_mask&context=board&side=top)')
            elif layer_type == '防焊s':
                self.GEN.COM('affected_filter,filter=(type=solder_mask&context=board&side=bottom)')
            elif layer_type == '文字':
                self.GEN.COM('affected_filter,filter=(type=silk_screen&context=board&side=top|bottom)')
            elif layer_type == '文字c':
                self.GEN.COM('affected_filter,filter=(type=silk_screen&context=board&side=top)')
                if self.__class__.__name__ in ['silk_color', 'cycle_symbol']:
                    self.GEN.AFFECTED_LAYER('xlxm-c', 'no')
            elif layer_type == '文字s':
                self.GEN.COM('affected_filter,filter=(type=silk_screen&context=board&side=bottom)')
                if self.__class__.__name__ in ['silk_color', 'cycle_symbol']:
                    self.GEN.AFFECTED_LAYER('xlxm-s', 'no')
            elif layer_type == '非一次文字':
                self.GEN.COM('affected_filter,filter=(type=silk_screen&context=board&side=top|bottom)')
                self.GEN.COM('get_affect_layer')
                cur_layers = self.GEN.COMANS.split()
                # if len(cur_layers) == 0:
                # === silk_array 为未添加二次文字前的结果（少层），取消此种判断 ===
                # for layer_name in self.parm.silk_array:
                for layer_name in cur_layers:
                    if layer_name in ['c1', 'c2', 'c1-1', 'c2-1', 'cc', 'cc2']:
                        self.GEN.AFFECTED_LAYER(layer_name, 'no')
            elif layer_type == '内层':
                self.GEN.COM('affected_filter,filter=(type=signal|power_ground&context=board&side=inner)')
            elif layer_type == '内层c':
                fill_array = self.parm.fill_array
                out_signal_array = self.parm.out_signal_array
                for fill_hash in fill_array:
                    layer_name = fill_hash.layer_name
                    layer_side = fill_hash.layer_side
                    if not layer_name in out_signal_array and layer_side == "正":
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
            elif layer_type == '内层s':
                fill_array = self.parm.fill_array
                out_signal_array = self.parm.out_signal_array
                for fill_hash in fill_array:
                    layer_name = fill_hash.layer_name
                    layer_side = fill_hash.layer_side
                    if not layer_name in out_signal_array and layer_side == "反":
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
            elif layer_type == '纯内层':
                fill_array = self.parm.fill_array
                out_signal_array = self.parm.out_signal_array
                for fill_hash in fill_array:
                    layer_name = fill_hash.layer_name
                    layer_side = fill_hash.layer_side
                    layer_mode = fill_hash.layer_mode
                    if not layer_name in out_signal_array and layer_mode == "inn":
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
            elif layer_type == '纯内层c':
                fill_array = self.parm.fill_array
                out_signal_array = self.parm.out_signal_array
                for fill_hash in fill_array:
                    layer_name = fill_hash.layer_name
                    layer_side = fill_hash.layer_side
                    layer_mode = fill_hash.layer_mode
                    if not layer_name in out_signal_array and layer_side == "正" and layer_mode == "inn":
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
            elif layer_type == '纯内层s':
                fill_array = self.parm.fill_array
                out_signal_array = self.parm.out_signal_array
                for fill_hash in fill_array:
                    layer_name = fill_hash.layer_name
                    layer_side = fill_hash.layer_side
                    layer_mode = fill_hash.layer_mode
                    if not layer_name in out_signal_array and layer_side == "反" and layer_mode == "inn":
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
            elif layer_type == '次外层':
                fill_array = self.parm.fill_array
                out_signal_array = self.parm.out_signal_array
                for fill_hash in fill_array:
                    layer_name = fill_hash.layer_name
                    layer_side = fill_hash.layer_side
                    layer_mode = fill_hash.layer_mode
                    if not layer_name in out_signal_array and layer_mode == "sec":
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
            elif layer_type == '基板c':
                fill_array = self.parm.fill_array
                JB_layers = self.parm.JB_layers
                for fill_hash in fill_array:
                    layer_name = fill_hash.layer_name
                    layer_side = fill_hash.layer_side
                    if layer_name in JB_layers and layer_side == "正":
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
            elif layer_type == '基板s':
                fill_array = self.parm.fill_array
                JB_layers = self.parm.JB_layers
                for fill_hash in fill_array:
                    layer_name = fill_hash.layer_name
                    layer_side = fill_hash.layer_side
                    if layer_name in JB_layers and layer_side == "反":
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
            elif layer_type == '埋孔内层':
                fill_array = self.parm.fill_array
                # blind_burry_list = self.parm.blind_burry_list
                # blind_burry_start = self.parm.blind_burry_start
                # blind_burry_end = self.parm.blind_burry_end
                burry_list = self.parm.burry_list
                burry_start = self.parm.burry_start
                burry_end = self.parm.burry_end
                for i, layer in enumerate(burry_list):
                    Blind_Reg = re.compile(r'^b([0-9][0-9]?)-?([0-9][0-9]?)$')
                    Blind_obj = Blind_Reg.match(layer)
                    if Blind_obj:
                        # --考虑到两次埋孔，所以加了个index,坐标顺序是按blind_burry_list的顺序压入数组的，不担心会错乱
                        layer_start = int(burry_start[i][1:])
                        layer_end = int(burry_end[i][1:])
                        for fill_hash in fill_array:
                            layer_name = fill_hash.layer_name
                            layer_id = int(layer_name.strip('.fz').split('-')[0][1:])
                            if layer_id >= layer_start and layer_id <= layer_end:
                                self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
                                sub_loop[i].append(layer_name)
            elif layer_type == '机械盲孔内层':
                fill_array = self.parm.fill_array
                out_signal_array = self.parm.out_signal_array
                jx_drill_list = self.parm.jx_drill_list
                jx_drill_start = self.parm.jx_drill_start
                jx_drill_end = self.parm.jx_drill_end
                for i, layer in enumerate(jx_drill_list):
                    # --考虑到两次埋孔，所以加了个index,坐标顺序是按jx_drill_list的顺序压入数组的，不担心会错乱
                    layer_start = int(jx_drill_start[i][1:])
                    layer_end = int(jx_drill_end[i][1:])
                    for fill_hash in fill_array:
                        layer_name = fill_hash.layer_name
                        if layer_name in out_signal_array:
                            # --机械盲孔外层不加pad
                            continue
                        # --考虑辅助层
                        layer_id = int(layer_name.strip('.fz').split('-')[0][1:])
                        if layer_id >= layer_start and layer_id <= layer_end:
                            self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
                            sub_loop[i].append(layer_name)
            elif layer_type == '化金':
                if self.GEN.LAYER_EXISTS('gold-c', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=gold-c,mode=single,affected=yes')
                if self.GEN.LAYER_EXISTS('gold-s', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=gold-s,mode=single,affected=yes')
            elif layer_type == '印选化油':
                arraylist_layer = ["linek-c", "linek-s","linek-c-1","linek-s-1","linek-c-2","linek-s-2"]
                for layer in arraylist_layer:                    
                    if self.GEN.LAYER_EXISTS(layer, job=self.JOB, step='panel') == 'yes':
                        self.GEN.COM('affected_layer,name={0},mode=single,affected=yes'.format(layer))
                        
            elif layer_type == '印选化油c':
                arraylist_layer = ["linek-c", "linek-s","linek-c-1","linek-s-1","linek-c-2","linek-s-2"]
                for layer in arraylist_layer:
                    if "linek-c" not in layer:
                        continue
                    if self.GEN.LAYER_EXISTS(layer, job=self.JOB, step='panel') == 'yes':
                        self.GEN.COM('affected_layer,name={0},mode=single,affected=yes'.format(layer))

            elif layer_type == '印选化油s':
                arraylist_layer = ["linek-c", "linek-s","linek-c-1","linek-s-1","linek-c-2","linek-s-2"]
                for layer in arraylist_layer:
                    if "linek-s" not in layer:
                        continue
                    if self.GEN.LAYER_EXISTS(layer, job=self.JOB, step='panel') == 'yes':
                        self.GEN.COM('affected_layer,name={0},mode=single,affected=yes'.format(layer))
                        
            elif layer_type == '化金c':
                if self.GEN.LAYER_EXISTS('gold-c', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=gold-c,mode=single,affected=yes')
            elif layer_type == '化金s':
                if self.GEN.LAYER_EXISTS('gold-s', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=gold-s,mode=single,affected=yes')
            elif layer_type == '选化':
                if self.GEN.LAYER_EXISTS('sgt-c', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=sgt-c,mode=single,affected=yes')
                if self.GEN.LAYER_EXISTS('sgt-s', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=sgt-s,mode=single,affected=yes')
            elif layer_type == '选化c':
                if self.GEN.LAYER_EXISTS('sgt-c', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=sgt-c,mode=single,affected=yes')
            elif layer_type == '选化s':
                if self.GEN.LAYER_EXISTS('sgt-s', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=sgt-s,mode=single,affected=yes')
            elif layer_type == '蚀刻引线':
                if self.GEN.LAYER_EXISTS('etch-c', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=etch-c,mode=single,affected=yes')
                if self.GEN.LAYER_EXISTS('etch-s', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=etch-s,mode=single,affected=yes')
            elif layer_type == '蚀刻引线c':
                if self.GEN.LAYER_EXISTS('etch-c', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=etch-c,mode=single,affected=yes')
            elif layer_type == '蚀刻引线s':
                if self.GEN.LAYER_EXISTS('etch-s', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=etch-s,mode=single,affected=yes')
            elif layer_type == '碳油':
                if self.GEN.LAYER_EXISTS('ty-c', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=ty-c,mode=single,affected=yes')
                if self.GEN.LAYER_EXISTS('ty-s', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=ty-s,mode=single,affected=yes')
            elif layer_type == '碳油c':
                if self.GEN.LAYER_EXISTS('ty-c', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=ty-c,mode=single,affected=yes')
            elif layer_type == '碳油s':
                if self.GEN.LAYER_EXISTS('ty-s', job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=ty-s,mode=single,affected=yes')
            elif layer_type == '档点':
                self.GEN.COM('affected_layer,name=md1,mode=single,affected=yes')
                self.GEN.COM('affected_layer,name=md2,mode=single,affected=yes')
            elif layer_type == '档点c':
                self.GEN.COM('affected_layer,name=md1,mode=single,affected=yes')
            elif layer_type == '档点s':
                self.GEN.COM('affected_layer,name=md2,mode=single,affected=yes')
            elif layer_type == '通孔':
                through_drl = self.parm.drl
                self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % through_drl)
            elif layer_type == '铝片':
                if self.GEN.LAYER_EXISTS('lp', job=self.JOB, step='panel') == 'yes':
                    # --防焊塞孔方式为不塞孔、树脂塞孔时,lp层已经被删除，此处加上限制条件防止报错
                    self.GEN.COM('affected_layer,name=lp,mode=single,affected=yes')
                if self.GEN.LAYER_EXISTS('sz.lp', job=self.JOB, step='panel') == 'yes':
                    # --防焊塞孔方式为不塞孔、树脂塞孔时,lp层已经被删除，此处加上限制条件防止报错
                    self.GEN.COM('affected_layer,name=sz.lp,mode=single,affected=yes')
            elif layer_type == '树脂导气':
                if self.GEN.LAYER_EXISTS('sz...dq', job=self.JOB, step='panel') == 'yes':
                    # --防焊塞孔方式为不塞孔、树脂塞孔时,lp层已经被删除，此处加上限制条件防止报错
                    self.GEN.COM('affected_layer,name=sz...dq,mode=single,affected=yes')
            elif layer_type == 'inn':
                self.GEN.COM('affected_layer,name=inn,mode=single,affected=yes')
            elif layer_type == '埋孔':
                for i, layer in enumerate(self.parm.burry_list):
                    Blind_Reg = re.compile(r'^b([0-9][0-9]?)-?([0-9][0-9]?)$')
                    Blind_obj = Blind_Reg.match(layer)
                    if Blind_obj:
                        # --考虑到两次埋孔，所以加了个index,坐标顺序是按blind_burry_list的顺序压入数组的，不担心会错乱
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer)
                        sub_loop[i].append(layer)
            elif layer_type == '埋孔铝片':
                for i, layer in enumerate(self.parm.burry_list):
                    Blind_Reg = re.compile(r'^b([0-9][0-9]?)-?([0-9][0-9]?)$')
                    Blind_obj = Blind_Reg.match(layer)
                    if Blind_obj:
                        # --考虑到两次埋孔，所以加了个index,坐标顺序是按blind_burry_list的顺序压入数组的，不担心会错乱
                        lp_layer = 'sz' + '-'.join(Blind_obj.groups()) + '.lp'
                        if self.GEN.LAYER_EXISTS(lp_layer, job=self.JOB, step='panel') == 'yes':
                            self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % lp_layer)
                            sub_loop[i].append(lp_layer)
            elif layer_type == '埋孔导气':
                for i, layer in enumerate(self.parm.burry_list):
                    Blind_Reg = re.compile(r'^b([0-9][0-9]?)-?([0-9][0-9]?)$')
                    Blind_obj = Blind_Reg.match(layer)
                    if Blind_obj:
                        # --考虑到两次埋孔，所以加了个index,坐标顺序是按blind_burry_list的顺序压入数组的，不担心会错乱
                        dq_layer = 'sz' + '-'.join(Blind_obj.groups()) + '...dq'
                        if self.GEN.LAYER_EXISTS(dq_layer, job=self.JOB, step='panel') == 'yes':
                            self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % dq_layer)
                            sub_loop[i].append(dq_layer)
            elif layer_type == '埋孔inn':
                for i, layer in enumerate(self.parm.burry_list):
                    Blind_Reg = re.compile(r'^b([0-9][0-9]?)-?([0-9][0-9]?)$')
                    Blind_obj = Blind_Reg.match(layer)
                    if Blind_obj:
                        # --考虑到两次埋孔，所以加了个index,坐标顺序是按blind_burry_list的顺序压入数组的，不担心会错乱
                        inn_layer = 'inn' + ''.join(Blind_obj.groups())
                        if self.GEN.LAYER_EXISTS(inn_layer, job=self.JOB, step='panel') == 'yes':
                            self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % inn_layer)
                            sub_loop[i].append(inn_layer)
            elif layer_type == '机械盲孔':
                jx_drill_list = self.parm.jx_drill_list
                for i, layer in enumerate(jx_drill_list):
                    Machine_Reg = re.compile(r'^m([0-9][0-9]?)-?([0-9][0-9]?)$')
                    Machine_obj = Machine_Reg.match(layer)
                    if Machine_obj:
                        # --考虑到两次埋孔，所以加了个index,坐标顺序是按blind_burry_list的顺序压入数组的，不担心会错乱
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer)
                        sub_loop[i].append(layer)
            elif layer_type == '机械盲孔铝片':
                jx_drill_list = self.parm.jx_drill_list
                for i, layer in enumerate(jx_drill_list):
                    Machine_Reg = re.compile(r'^m([0-9][0-9]?)-?([0-9][0-9]?)$')
                    Machine_obj = Machine_Reg.match(layer)
                    if Machine_obj:
                        # --考虑到两次埋孔，所以加了个index,坐标顺序是按blind_burry_list的顺序压入数组的，不担心会错乱
                        lp_layer = 'lp' + ''.join(Machine_obj.groups())
                        if self.GEN.LAYER_EXISTS(lp_layer, job=self.JOB, step='panel') == 'yes':
                            self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % lp_layer)
                            sub_loop[i].append(lp_layer)
            elif layer_type == '机械盲孔inn':
                jx_drill_list = self.parm.jx_drill_list
                for i, layer in enumerate(jx_drill_list):
                    Machine_Reg = re.compile(r'^m([0-9][0-9]?)-?([0-9][0-9]?)$')
                    Machine_obj = Machine_Reg.match(layer)
                    if Machine_obj:
                        # --考虑到两次埋孔，所以加了个index,坐标顺序是按blind_burry_list的顺序压入数组的，不担心会错乱
                        inn_layer = layer = 'm' + '-'.join(Machine_obj.groups()) + ".inn"
                        if self.GEN.LAYER_EXISTS(inn_layer, job=self.JOB, step='panel') == 'yes':
                            self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % inn_layer)
                            sub_loop[i].append(inn_layer)
            elif layer_type == '辅助层':
                assist_layer = self.parm.assist_layer
                for layer in assist_layer:
                    self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer)
            elif layer_type == '辅助层c':
                assist_layer = self.parm.assist_layer
                assist_side = self.parm.assist_side
                for layer, side in zip(assist_layer, assist_side):
                    if side == "正":
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer)
            elif layer_type == '辅助层s':
                assist_layer = self.parm.assist_layer
                assist_side = self.parm.assist_side
                for layer, side in zip(assist_layer, assist_side):
                    if side == "反":
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer)
            #增加避开区域临时层 用来单独计算避开区域 20221123 by lyh
            elif '避开区域' in layer_type:
                if self.GEN.LAYER_EXISTS("bk_area_tmp", job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=bk_area_tmp,mode=single,affected=yes')                
            else:
                # --外型层w等,不方便归类的层别，直接传入层别名作为layer_type
                if self.GEN.LAYER_EXISTS(layer_type, job=self.JOB, step='panel') == 'yes':
                    self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_type)

            # --如果没有影响层，直接进入下一轮循环
            self.GEN.COM('get_affect_layer')
            layers = self.GEN.COMANS.split()
            if len(layers) == 0:
                continue

            index = 0
            cls_name = self.__class__.__name__
            for i, info_dict in enumerate(coord_list):
                rectangles = []
                if info_dict.has_key('xs'):
                    # --添加线
                    xs = info_dict['xs']
                    ys = info_dict['ys']
                    xe = info_dict['xe']
                    ye = info_dict['ye']
                    symbol = info_dict['symbol']
                    polarity = info_dict['polarity']
                    attribute = info_dict['attribute']
                    text = None
                elif info_dict.has_key('bar_type'):
                    # === 添加二维码
                    x = info_dict['x']
                    y = info_dict['y']
                    text = info_dict['text']
                    x_size = 5
                    y_size = 5
                    w_factor = 2
                    angle = info_dict['angle']
                    mirror = info_dict['mirror']
                    polarity = info_dict['polarity']
                    attribute = info_dict['attribute']
                    fontname = 'standard'
                    symbol = None
                    matrix = info_dict['matrix']
                    bar_type = info_dict['bar_type']
                    bar_background = info_dict['bar_background']
                    bar_add_string = info_dict['bar_add_string']
                    bar_height = info_dict['bar_height']
                elif info_dict.has_key('text'):
                    # --添加文字
                    x = info_dict['x']
                    y = info_dict['y']
                    text = info_dict['text']
                    x_size = info_dict['x_size']
                    y_size = info_dict['y_size']
                    w_factor = info_dict['w_factor']
                    angle = info_dict['angle']
                    mirror = info_dict['mirror']
                    polarity = info_dict['polarity']
                    attribute = info_dict['attribute']
                    fontname = info_dict['fontname']
                    symbol = None
                else:
                    # --添加pad
                    x = info_dict['x']
                    y = info_dict['y']
                    nx = info_dict['nx']
                    ny = info_dict['ny']
                    dx = info_dict['dx']
                    dy = info_dict['dy']
                    angle = info_dict['angle']
                    symbol = info_dict['symbol']
                    mirror = info_dict['mirror']
                    polarity = info_dict['polarity']
                    attribute = info_dict['attribute']
                    text = None
                if symbol or text:
                    with_attribute = 'no'
                    if attribute is not None:
                        # --加r0的时候，其它symbolg不需要属性
                        with_attribute = 'yes'
                        self.GEN.COM('cur_atr_reset')
                        attribute_list = attribute.split(';')
                        for attr in attribute_list:
                            # --比如钻字，可能会另多个属性
                            self.GEN.COM('cur_atr_set,attribute=%s' % attr)
                    if sub_loop.has_key(index) and i > 4:
                        # --此条件主要针对机械盲孔料号，m12;m9/10需要防呆的情况
                        layer_list = sub_loop[index]
                        self.GEN.CLEAR_LAYER()
                        for layer in layer_list:
                            self.GEN.AFFECTED_LAYER(layer, 'yes')
                        index += 1
                    if info_dict.has_key('xs'):
                        # --添加线
                        self.GEN.COM('add_line,attributes=%s,xs=%s,ys=%s,xe=%s,ye=%s,symbol=%s,polarity=%s,'
                                     'bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left'
                                     % (with_attribute, xs, ys, xe, ye, symbol, polarity))
                        # --获取当前symbol所占用的矩形面积
                        if not self.avoidType is None:
                            rectangles = self.get_rectangles(symbol, type='line', xs=xs, ys=ys, xe=xe, ye=ye)
                        symbol_area.extend(rectangles)
                    elif info_dict.has_key('bar_type'):
                        self.GEN.COM('add_text,attributes=%s,type=barcode,x=%s,y=%s,text=%s,'
                                     'x_size=%s,y_size=%s,w_factor=%s,polarity=%s,angle=%s,mirror=%s,'
                                     'fontname=standard,bar_type=%s,bar_char_set=full_ascii,bar128_code=none,'
                                     'matrix=%s,bar_checksum=no,bar_background=%s,bar_add_string=%s,'
                                     'bar_add_string_pos=top,bar_marks=no,bar_width=0.2032,bar_height=%s,ver=1'
                                     % (with_attribute, x, y, text, x_size, y_size, w_factor, polarity, angle, mirror,
                                        bar_type, matrix, bar_background, bar_add_string, bar_height))
                    elif info_dict.has_key('text'):
                        # --添加文字
                        self.GEN.COM('add_text,attributes=%s,type=string,x=%s,y=%s,text=%s,'
                                     'x_size=%s,y_size=%s,w_factor=%s,polarity=%s,angle=%s,mirror=%s,'
                                     'fontname=%s,bar_type=UPC39,bar_char_set=full_ascii,bar128_code=none,'
                                     'bar_checksum=no,bar_background=yes,bar_add_string=yes,bar_add_string_pos=top,'
                                     'bar_width=0.2032,bar_height=5.08,ver=1'
                                     % (with_attribute, x, y, text, x_size, y_size, w_factor, polarity, angle, mirror,
                                        fontname))
                    else:
                        self.GEN.COM('add_pad,attributes=%s,x=%s,y=%s,symbol=%s,polarity=%s,angle=%s,mirror=%s,'
                                     'nx=%s,ny=%s,dx=%s,dy=%s,xscale=1,yscale=1'
                                     % (with_attribute, x, y, symbol, polarity, angle, mirror, nx, ny, dx, dy))
                        # --获取当前symbol所占用的矩形面积
                        if not self.avoidType is None:
                            rectangles = self.get_rectangles(symbol, sym_angle=angle, mirror=mirror, x=x, y=y)
                        symbol_area.extend(rectangles)
                    if attribute is not None:
                        # --加r0的时候，其它symbol不需要属性
                        self.GEN.COM('cur_atr_reset')
            self.GEN.COM('affected_layer,mode=all,affected=no')
        return symbol_area

    def update_rect(self, x, y, this_rect):
        """
        通过传入的x,y中心重新生rectangle
        :param x:
        :param y:
        :return: RECTANGLE实例
        :rtype:
        """
        sym_name = this_rect.symbol
        xmin = x - this_rect.get_lenX() / 2
        ymin = y - this_rect.get_lenY() / 2
        xmax = x + this_rect.get_lenX() / 2
        ymax = y + this_rect.get_lenY() / 2
        this_rect = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
        return this_rect

    def touch_same_direct(self, this_rect, avoid_same_direct=None):
        """
        检查是否与same_direct其它rect重叠
        :return:
        :rtype:
        """
        # --this_rect内缩0.01mm,防止误touch
        this_rect.xmin += 0.01
        this_rect.xmax -= 0.01
        this_rect.ymin += 0.01
        this_rect.ymax -= 0.01
        for other_rect in avoid_same_direct:
            if this_rect.touch(other_rect):
                return True
        return False

    def optimize_static(self, sym_name, x_org=0.0, y_org=0.0, area_xmin=None, area_ymin=None, area_xmax=None,
                        area_ymax=None, mirror_y_area='no', move_down='no'):
        """
        避开特定symbol，仅做平移
        :return: x,y移动后的坐标
        :rtype:
        """
        # --当前symbol所占用area定义
        this_rect = self.get_rectangles(sym_name, x=x_org, y=y_org)[0]
        # --get_rectangles时会加大单边0.5mm song 2021.09.13 ———> 0.2
        additional = 0.1 + self.clearance
        move_hor = False
        move_ver = False
        same_key = 'ymin'
        if area_xmin is None and area_xmax is None:
            area_xmin = this_rect.xmin + self.clearance
            area_xmax = this_rect.xmax - self.clearance
            move_ver = True
            if this_rect.ymin - area_ymin > area_ymax - this_rect.ymax:
                same_key = 'ymax'
        if area_ymin is None and area_ymax is None:
            area_ymin = this_rect.ymin + self.clearance
            area_ymax = this_rect.ymax - self.clearance
            move_hor = True

        if self.__class__.__name__ == 'pin_donut':
            same_key = 'xmax'
        # --当前symbol可移动范围,范围适当加大一点,以包含移动后的this_rect
        area_rect = RECTANGLE(symbol=sym_name, xmin=area_xmin - additional, ymin=area_ymin - additional,
                              xmax=area_xmax + additional, ymax=area_ymax + additional)
        # --其它需要避开的矩形区域,必须通过list创建副本，否则会重复
        other_rectangles = list(self.avoidArea[self.avoidType])
        if self.avoidType != 'all':
            # --如果为inner或者outer时，也要避开all
            other_rectangles.extend(self.avoidArea['all'])
        else:
            # --如果为all时,也要避开inner和outer
            other_rectangles.extend(self.avoidArea['inner'])
            other_rectangles.extend(self.avoidArea['outer'])
        # --从所有的rect中挑出与当前可移动区域相关的rect
        avoid_rectangles = []
        for other_rect in other_rectangles:
            # === 上坐标下翻，V1.07更改 ===
            if mirror_y_area == 'yes' and other_rect.ymin > self.parm.panel_y * 0.5:
                # print "before", other_rect
                other_rect = RECTANGLE(symbol=other_rect.symbol, xmin=other_rect.xmin,
                                       ymin=(self.parm.panel_y - other_rect.ymin),
                                       xmax=other_rect.xmax, ymax=(self.parm.panel_y - other_rect.ymax))
                # print "after", other_rect
            if area_rect.touch(other_rect):
                if other_rect not in avoid_rectangles:
                    if self.__class__.__name__ in ['sh_dwsd']:
                        # --HDI切片孔及试钻孔、长边sh-sec、右下角层别标示不需要避开热溶块和铆钉孔
                        if other_rect.symbol not in ['chris-rjpad']:
                            avoid_rectangles.append(other_rect)
                    elif self.__class__.__name__ in ['pin_donut']:
                        # === 左下角四角防呆孔仅避开靶位孔 ===
                        if re.match('hdi1-b[as](t|\d)|(s5080|s5082)', other_rect.symbol):
                            avoid_rectangles.append(other_rect)
                        else:
                            print other_rect.symbol
                    else:
                        # --再次去重,加快运行速度
                        avoid_rectangles.append(other_rect)
        # === 增加排序
        if same_key == 'ymax':
            avoid_rectangles = list(reversed(sorted(avoid_rectangles, key=attrgetter(same_key))))
        else:
            avoid_rectangles = sorted(avoid_rectangles, key=attrgetter(same_key))

        # --初始赋值x,y为传入的值x_org,y_org
        x, y = x_org, y_org
        # --定义pre_rect,主要用来确认移动后是否与上次rect冲突
        for avoid_rect in avoid_rectangles:
            # # --调试用,查看this_rect与avoid_rect是否touch以及与avoid_same_direct中的rect是否touch
            # if self.__class__.__name__ == 'pin_donut':
            #     print "mirror_y_area",mirror_y_area
            #     print 'self.parm.panel_y',self.parm.panel_y
            #     print "avoid_rectangles",avoid_rectangles
            #     print 'area_rect',area_rect
            #     pprint(avoid_rectangles)
            #     print "this_rect",this_rect
            #     print "avoid_rect",avoid_rect
            #     print "this_rect.touch(avoid_rect)",this_rect.touch(avoid_rect)
            #     print "self.touch_same_direct(this_rect,avoid_same_direct=avoid_rectangles)",\
            #         self.touch_same_direct(this_rect,avoid_same_direct=avoid_rectangles)
            #     self.GEN.PAUSE("check touch")
            # --touch到avoid_rect或者移动之后touch到avoid_same_origin,都需要重新移动到合适的位置
            if this_rect.touch(avoid_rect) or self.touch_same_direct(this_rect, avoid_same_direct=avoid_rectangles):
                if move_hor:
                    # --水平移动
                    move_L = this_rect.xc - (avoid_rect.xmin - this_rect.get_lenX() / 2)
                    move_R = avoid_rect.xmax + this_rect.get_lenX() / 2 - this_rect.xc

                    # --外层ccd，防焊ccd尽量向左移，靠近板角取值 pin_donut 向右移
                    if (move_L > move_R and self.__class__.__name__ not in ['sh_dwsd',
                                                                            'out_ccd']) or self.__class__.__name__ in [
                        'pin_donut'] or avoid_rect.xmin - this_rect.get_lenX() / 2 < area_rect.xmin:
                        # --向右移
                        x = avoid_rect.xmax + this_rect.get_lenX() / 2
                        # self.GEN.PAUSE("move right")
                    else:
                        # --向左移
                        x = avoid_rect.xmin - this_rect.get_lenX() / 2
                        # self.GEN.PAUSE("move left")
                if move_ver:
                    # --底部的symbol向上移
                    move_D = this_rect.yc - (avoid_rect.ymin - this_rect.get_lenY() / 2)
                    move_U = avoid_rect.ymax + this_rect.get_lenY() / 2 - this_rect.yc
                    if (
                            move_D > move_U or avoid_rect.ymin - this_rect.get_lenY() / 2 < area_rect.ymin) and move_down == 'no':
                        # --向上移
                        y = avoid_rect.ymax + this_rect.get_lenY() / 2
                    else:
                        # --向下移
                        y = avoid_rect.ymin - this_rect.get_lenY() / 2
                # --更新矩形区域
                this_rect = self.update_rect(x, y, this_rect)
            else:
                # --没有touch的时候,并且前次移动后没有touch到其它symbol,不需要再继续移动
                # self.GEN.PAUSE("not touch")
                pass
        return x, y

class DYNAMIC_SYM(STATIC_SYM):
    """
    定义动态symbol类,继承自静态symbol类
    """

    def __init__(self, frozen_json=None, priority=None, avoidArea=None, avoidType='all'):
        self.parm = frozen_json
        self.priority = priority
        self.avoidArea = avoidArea
        self.avoidType = avoidType
        self.warn_content_list = []
        self.get_opt_position = False
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def optimize_coord(self, sym_name=None, sym_angle=0, mirror='no', type='pad', x=0.0, y=0.0, xs=None, ys=None,
                       xe=None, ye=None, move_other=False, area_xmin=None, area_ymin=None, area_xmax=None,
                       area_ymax=None, same_key=None, other_key=None, four_corner2ll='no'):
        """
        优化坐标，使不与其它symbol冲突
        :return:
        :rtype:
        """
        # --当前symbol所占用area定义
        this_rect = self.get_rectangles(sym_name, sym_angle=sym_angle, mirror=mirror, type=type,
                                        x=x, y=y, xs=xs, ys=ys, xe=xe, ye=ye)[0]
        # --get_rectangles时会加大单边0.5mm
        additional = 0.1 + 0.5
        if area_xmin is None and area_xmax is None:
            area_xmin = this_rect.xmin + 0.5
            area_xmax = this_rect.xmax - 0.5
        if area_ymin is None and area_ymax is None:
            area_ymin = this_rect.ymin + 0.5
            area_ymax = this_rect.ymax - 0.5
        # --当前symbol可移动范围,范围适当加大一点,以包含移动后的this_rect
        area_rect = RECTANGLE(symbol=sym_name, xmin=area_xmin - additional, ymin=area_ymin - additional,
                              xmax=area_xmax + additional, ymax=area_ymax + additional)
        # --如果定义的可移动范围,比symbol的范围大,则代表可以向相对垂直方向移动
        if area_rect.get_lenY() > area_rect.get_lenX():
            if area_xmax - area_xmin - this_rect.get_lenX() > -0.99:
                move_other = True
        if area_rect.get_lenX() > area_rect.get_lenY():
            if area_ymax - area_ymin - this_rect.get_lenY() > -0.99:
                move_other = True

        # --其它需要避开的矩形区域,必须通过list创建副本，否则会重复
        other_rectangles = list(self.avoidArea[self.avoidType])
        if self.avoidType != 'all':
            # --如果为inner或者outer时，也要避开all
            other_rectangles.extend(self.avoidArea['all'])
        else:
            # --如果为all时,也要避开inner和outer
            other_rectangles.extend(self.avoidArea['inner'])
            other_rectangles.extend(self.avoidArea['outer'])

        # --从所有的rect中挑出与当前可移动区域相关的rect
        avoid_rectangles = []
        for other_rect in other_rectangles:
            # === 上坐标下翻，V2.00更改 四角坐标归集到左下角===
            if four_corner2ll == 'yes':
                if other_rect.ymin > self.parm.panel_y * 0.5:
                    if other_rect.xmin > self.parm.panel_x * 0.5:
                        # print "before", other_rect
                        other_rect = RECTANGLE(symbol=other_rect.symbol,
                                               xmin=(self.parm.panel_x - other_rect.xmin),
                                               ymin=(self.parm.panel_y - other_rect.ymin),
                                               xmax=(self.parm.panel_x - other_rect.xmax),
                                               ymax=(self.parm.panel_y - other_rect.ymax))
                    else:
                        # print "before", other_rect
                        other_rect = RECTANGLE(symbol=other_rect.symbol,
                                               xmin=other_rect.xmin,
                                               ymin=(self.parm.panel_y - other_rect.ymin),
                                               xmax=other_rect.xmax,
                                               ymax=(self.parm.panel_y - other_rect.ymax))
                elif other_rect.ymin < self.parm.panel_y * 0.5:
                    if other_rect.xmin > self.parm.panel_x * 0.5:
                        other_rect = RECTANGLE(symbol=other_rect.symbol,
                                               xmin=(self.parm.panel_x - other_rect.xmin),
                                               ymin=other_rect.ymin,
                                               xmax=(self.parm.panel_x - other_rect.xmax),
                                               ymax=other_rect.ymax)

            elif four_corner2ll == 'down':
                if other_rect.ymin < self.parm.panel_y * 0.5:
                    if other_rect.xmin > self.parm.panel_x * 0.5:
                        other_rect = RECTANGLE(symbol=other_rect.symbol,
                                               xmin=(self.parm.panel_x - other_rect.xmin),
                                               ymin=other_rect.ymin,
                                               xmax=(self.parm.panel_x - other_rect.xmax),
                                               ymax=other_rect.ymax)
        
            if self.__class__.__name__ in ['hdi_slice', 'out_ccd']:
                # === 切片孔避让备用靶,备用靶单边加大5mm进行避让 ===增加避让常规标靶
                if re.match(r'^hdi1-by', other_rect.symbol):
                    other_rect = RECTANGLE(symbol='s15000', xmin=(other_rect.xmin - 5), ymin=(other_rect.ymin - 5),
                                           xmax=(other_rect.xmax + 5), ymax=(other_rect.ymax + 5))
                if re.match(r'rect\d+\.?\dx5080', other_rect.symbol):
                    other_rect = RECTANGLE(symbol=other_rect.symbol, xmin=(other_rect.xmin - 6.5),
                                           ymin=(other_rect.ymin - 6.5),
                                           xmax=(other_rect.xmax + 6.5), ymax=(other_rect.ymax + 6.5))
                if re.match("r3175", other_rect.symbol):
                    # print(other_rect)
                    other_rect = RECTANGLE(symbol=other_rect.symbol, xmin=(other_rect.xmin - 6.5),
                                           ymin=(other_rect.ymin - 6.5),
                                           xmax=(other_rect.xmax + 6.5), ymax=(other_rect.ymax + 6.5))                    
            if area_rect.touch(other_rect):                    
                # if other_rect not in avoid_rectangles:
                if not any(other_rect.check_diff(obj) for obj in avoid_rectangles):
                    if self.__class__.__name__ in ['hdi_slice', 'sz_hole', 'sh_sec', 'add_four_lengnew', 'ldi_stamp']:
                        # --HDI切片孔及试钻孔、长边sh-sec、右下角层别标示不需要避开热溶块和铆钉孔
                        # if other_rect.symbol not in ['chris-rjpad','sh-mdk-t']:
                        if other_rect.symbol not in ['chris-rjpad']:
                            avoid_rectangles.append(other_rect)
                    elif self.__class__.__name__ in ['same_circle']:
                        # --同心圆不需要避开rm_rh_sym圆pad
                        if other_rect.symbol not in ['rm_rh_sm']:
                            avoid_rectangles.append(other_rect)
                    elif self.__class__.__name__ in ['sh_bj', 'sh_sh']:
                        # --外层ccd对位孔不需要避开内层靶距symbol和sh-sh,参考x留边较小的料号484/439a1
                        if other_rect.symbol not in ['sh-dwtop2013']:
                            avoid_rectangles.append(other_rect)
                    elif self.__class__.__name__ in ['out_ccd']:
                        if other_rect.symbol not in ['rect30000x2500', "sh-wx", "sh-kn2013"]:
                            avoid_rectangles.append(other_rect)                        
                    else:
                        # --再次去重,加快运行速度
                        avoid_rectangles.append(other_rect)

        # --对挑出的需要避开的区域进行排序
        avoid_same_direct = []
        # --如果symbol只能平移,定义avoid_other_direct为area范围
        avoid_other_direct = [area_rect]
        if area_ymin >= self.parm.sr_ymax:
            if area_xmin < self.parm.panel_x / 2:
                # --top短边左侧
                if same_key is None:
                    same_key = 'xmax'
                if other_key is None:
                    other_key = 'ymax'
                avoid_same_direct = sorted(avoid_rectangles, key=attrgetter(same_key))
                if move_other:
                    # --如果symbol可以向相对垂直方向移动
                    avoid_other_direct = sorted(avoid_rectangles, key=attrgetter(other_key))
            else:
                # --top短边右侧
                if same_key is None:
                    same_key = 'xmin'
                if other_key is None:
                    other_key = 'ymax'
                avoid_same_direct = list(reversed(sorted(avoid_rectangles, key=attrgetter(same_key))))
                if move_other:
                    # --如果symbol可以向相对垂直方向移动
                    avoid_other_direct = sorted(avoid_rectangles, key=attrgetter(other_key))
        elif area_ymax <= self.parm.sr_ymin:
            if area_xmin < self.parm.panel_x / 2:
                # --bot短边左侧
                if same_key is None:
                    same_key = 'xmax'
                if other_key is None:
                    other_key = 'ymin'
                avoid_same_direct = sorted(avoid_rectangles, key=attrgetter(same_key))
                if move_other:
                    # --如果symbol可以向相对垂直方向移动
                    avoid_other_direct = list(reversed(sorted(avoid_rectangles, key=attrgetter(other_key))))
            else:
                # --bot短边右侧
                if same_key is None:
                    same_key = 'xmin'
                if other_key is None:
                    other_key = 'ymin'
                avoid_same_direct = list(reversed(sorted(avoid_rectangles, key=attrgetter(same_key))))
                if move_other:
                    # --如果symbol可以向相对垂直方向移动
                    avoid_other_direct = list(reversed(sorted(avoid_rectangles, key=attrgetter(other_key))))
        elif area_xmin >= self.parm.sr_xmax:
            if area_ymax > self.parm.panel_y / 2:
                # --right长边上
                if same_key is None:
                    same_key = 'ymin'
                if other_key is None:
                    other_key = 'xmax'
                avoid_same_direct = list(reversed(sorted(avoid_rectangles, key=attrgetter(same_key))))
                if move_other:
                    # --如果symbol可以向相对垂直方向移动
                    avoid_other_direct = sorted(avoid_rectangles, key=attrgetter(other_key))
            else:
                # --right长边下
                if same_key is None:
                    same_key = 'ymax'
                if other_key is None:
                    other_key = 'xmax'
                avoid_same_direct = sorted(avoid_rectangles, key=attrgetter(same_key))
                if move_other:
                    # --如果symbol可以向相对垂直方向移动
                    avoid_other_direct = sorted(avoid_rectangles, key=attrgetter(other_key))
        elif area_xmax <= self.parm.sr_xmin:
            if area_ymax > self.parm.panel_y / 2:
                # --left长边上
                if same_key is None:
                    same_key = 'ymin'
                if other_key is None:
                    other_key = 'xmin'
                avoid_same_direct = list(reversed(sorted(avoid_rectangles, key=attrgetter(same_key))))
                if move_other:
                    # --如果symbol可以向相对垂直方向移动
                    avoid_other_direct = list(reversed(sorted(avoid_rectangles, key=attrgetter(other_key))))
            else:
                # --left长边下
                if same_key is None:
                    same_key = 'ymax'
                if other_key is None:
                    other_key = 'xmin'
                avoid_same_direct = sorted(avoid_rectangles, key=attrgetter(same_key))
                if move_other:
                    # --如果symbol可以向相对垂直方向移动
                    avoid_other_direct = list(reversed(sorted(avoid_rectangles, key=attrgetter(other_key))))
        else:
            if same_key is None:
                same_key = 'xmin_ymin'
            if other_key is None:
                other_key = 'ymin_xmin'
            avoid_same_direct = sorted(avoid_rectangles, key=attrgetter('xmin', 'ymin'))
            if move_other:
                # --如果symbol可以向相对垂直方向移动
                avoid_other_direct = sorted(avoid_rectangles, key=attrgetter('ymin', 'xmin'))

        # --相对于平移,另一个方向只需要坐标列表即可
        avoid_other_coord = []
        for rect in avoid_other_direct:
            coord = getattr(rect, other_key, None)
            if coord is not None:
                if coord not in avoid_other_coord:
                    avoid_other_coord.append(coord)
                    
        #print(avoid_rectangles, area_rect, other_key)
        #print(this_rect)
        #for a in avoid_same_direct:
            #print(a)
        
        # # --调试用,查看需要避开的rect及同方向需要避开的rect
        #if self.__class__.__name__ == 'out_ccd':
            #print "x",x
            #print "y",y
            #print "same_key",same_key
            #print "other_key",other_key
            ## print "other_rectangles"
            ## pprint(other_rectangles)
            #print "area_rect"
            #pprint(area_rect)
            #print "this_rect"
            #pprint(this_rect)
            #print "avoid_same_direct"
            #pprint(avoid_same_direct)
            #print "avoid_other_coord"
            #pprint(avoid_other_coord)
            #if "-lyh" in job.name:
                #self.GEN.CLEAR_LAYER()
                #self.GEN.AFFECTED_LAYER("bk_area", "yes")
                #for a in avoid_same_direct:
                    #self.GEN.ADD_PAD((a.xmin+a.xmax) *0.5, (a.ymin+a.ymax) *0.5, a.symbol)
            #self.GEN.PAUSE("check avoid_same_direct")

        # --修正坐标,所有坐标只做平移，短边移x坐标，长边只移y坐标
        x_org, y_org = x, y

        # --对pre_area和new_area赋初值
        pre_area_rect = area_rect
        pre_area_xmin = new_area_xmin = area_xmin - additional
        pre_area_xmax = new_area_xmax = area_xmax + additional
        pre_area_ymin = new_area_ymin = area_ymin - additional
        pre_area_ymax = new_area_ymax = area_ymax + additional
        for i, other_coord in enumerate(avoid_other_coord):
            if other_key == 'xmax':
                # --长边右侧的symbol
                if i > 0:
                    new_area_xmin = pre_area_xmax
                new_area_xmax = other_coord
            elif other_key == 'xmin':
                # --长边左侧的symbol
                new_area_xmin = other_coord
                if i > 0:
                    new_area_xmax = pre_area_xmin
            elif other_key == 'ymax':
                # --短边顶部的symbol
                if i > 0:
                    new_area_ymin = pre_area_ymax
                new_area_ymax = other_coord
            elif other_key == 'ymin':
                # --短边底部的symbol
                new_area_ymin = other_coord
                if i > 0:
                    new_area_ymax = pre_area_ymin
            # --重置pre_area为本次area
            pre_area_xmin = new_area_xmin
            pre_area_xmax = new_area_xmax
            pre_area_ymin = new_area_ymin
            pre_area_ymax = new_area_ymax
            # --重新生成新的可移动区域,范围适当加大一点,以包含移动后的this_rect
            new_area_rect = RECTANGLE(symbol=sym_name, xmin=new_area_xmin, ymin=new_area_ymin,
                                      xmax=new_area_xmax, ymax=new_area_ymax)
            pre_area_rect = new_area_rect
            x, y, this_rect = self.move_same_direct(sym_name, x, y, this_rect, new_area_rect, same_key,
                                                    avoid_same_direct=avoid_same_direct)
            
            # print("--------------->3", this_rect)
            # --判断是否有超过范围
            if this_rect in [area_rect] and not self.touch_same_direct(this_rect, avoid_same_direct=avoid_same_direct):
                # print("--------------->1", this_rect)
                # --在范围内,而且不与范围内任何一个矩形touch,则可以返回
                self.get_opt_position = True                
                return x, y
            else:
                # --一次平移没法搞定,需要向相对垂直方向移动,再在此方向上做平移
                x, y, this_rect = self.move_other_direct(this_rect, new_area_rect, other_key, same_key,
                                                         avoid_other_coord=other_coord)
        # --再次检测是否在范围内,若超出范围，再要提示，symbol无法自动避开
        if not this_rect in [area_rect]:
            # --TODO symbol无法避开,平移横移均达不到要求,不做任何移动,x,y还原为初始坐标
            x, y = x_org, y_org
            if self.__class__.__name__ == 'drl_moudle' and (y_org > self.parm.sr_ymax or y_org < self.parm.sr_ymin):
                # --drl模块在右下角、右上角时,不需要提醒,移到长边右下角后如果再无处安置再提醒
                pass
            elif self.__class__.__name__ == 'ldi_stamp' and y_org < self.parm.sr_ymin:
                # --ldi_stamp模块在短边底部时,不需要提醒,移到长边右侧后如果再无处安置再提醒,参考484/439a1移到长边
                pass
            elif self.__class__.__name__ == 'silk_color' and y_org > self.parm.profile_ymax * 0.5:
                # --文字颜色如果在右侧长边上部放不下，直接移到右侧长边下部，不需要提醒
                pass
            else:
                # msg_box = msgBox()
                # msg_box.critical(self, '警告', 'symbol : %s无法避开,平移横移均达不到要求！' % self.__class__.__name__, QMessageBox.Ok)
                warn_content = 'symbol : %s无法避开,平移横移均达不到要求！' % self.__class__.__doc__
                if warn_content not in self.warn_content_list:
                    msg_dict = {'type': 'critical',
                                'windowTitle': '警告',
                                'content': 'symbol : %s无法避开,平移横移均达不到要求！' % self.__class__.__doc__}
                    if self.__class__.__name__ == 'drl_moudle':
                        msg_dict['content'] = '尾孔模块无法避开其它symbol,需要手动移开并clip外层、防焊、档点层!'
                    self.warn_content_list.append(warn_content)
                    self.msg_array.append(msg_dict)
        # --此时返回最原始的坐标,未做任何移动
        # print("--------------->2", this_rect)
        return x, y

    def optimize_coord_find_area_rect(self, sym_name=None, sym_angle=0, mirror='no', type='pad', x=0.0, y=0.0, xs=None, ys=None,
                                      xe=None, ye=None, move_other=False, area_xmin=None, area_ymin=None, area_xmax=None,
                                      area_ymax=None, same_key=None, other_key=None,move_fx="X", move_x_step=1, move_y_step=1,
                                      four_corner2ll='no', return_rect="no",include_rect=None, step=None, to_feature_size=-0.18):
        """
        优化坐标，使不与其它symbol冲突
        :return:
        :rtype:
        """
        # --当前symbol所占用area定义
        this_rect = self.get_rectangles(sym_name, sym_angle=sym_angle, mirror=mirror, type=type,
                                        x=x, y=y, xs=xs, ys=ys, xe=xe, ye=ye)[0]
        # --get_rectangles时会加大单边0.5mm
        additional = 0.1 + 0.5
        if area_xmin is None and area_xmax is None:
            area_xmin = this_rect.xmin + 0.5
            area_xmax = this_rect.xmax - 0.5
        if area_ymin is None and area_ymax is None:
            area_ymin = this_rect.ymin + 0.5
            area_ymax = this_rect.ymax - 0.5
        # --当前symbol可移动范围,范围适当加大一点,以包含移动后的this_rect
        area_rect = RECTANGLE(symbol=sym_name, xmin=area_xmin - additional, ymin=area_ymin - additional,
                              xmax=area_xmax + additional, ymax=area_ymax + additional)
        # --如果定义的可移动范围,比symbol的范围大,则代表可以向相对垂直方向移动
        if area_rect.get_lenY() > area_rect.get_lenX():
            if area_xmax - area_xmin - this_rect.get_lenX() > -0.99:
                move_other = True
        if area_rect.get_lenX() > area_rect.get_lenY():
            if area_ymax - area_ymin - this_rect.get_lenY() > -0.99:
                move_other = True

        # --其它需要避开的矩形区域,必须通过list创建副本，否则会重复
        other_rectangles = list(self.avoidArea[self.avoidType])
        if self.avoidType != 'all':
            # --如果为inner或者outer时，也要避开all
            # if self.__class__.__name__ not in ['yh_measure_pad']:                
            other_rectangles.extend(self.avoidArea['all'])
        else:
            # --如果为all时,也要避开inner和outer
            other_rectangles.extend(self.avoidArea['inner'])
            other_rectangles.extend(self.avoidArea['outer'])
        
        #新增传递进来需剔除的区域 20221125 by lyh
        if include_rect:
            other_rectangles.extend(include_rect)            
            
        # --从所有的rect中挑出与当前可移动区域相关的rect
        avoid_rectangles = []
        for other_rect in other_rectangles:
            # === 上坐标下翻，V2.00更改 四角坐标归集到左下角===
            if four_corner2ll == 'yes':                    
                # 测试
                if "-lyh" in self.JOB and step is not None:                    
                    if other_rect.symbol == "s3750":
                        step.addRectangle(other_rect.xmin, other_rect.ymin, other_rect.xmax, other_rect.ymax)
                        
                    if step is not None and not include_rect:
                        step.addRectangle(other_rect.xmin, other_rect.ymin, other_rect.xmax, other_rect.ymax)
                        step.addRectangle(area_rect.xmin, area_rect.ymin, area_rect.xmax, area_rect.ymax)
                    
                if other_rect.ymin > self.parm.panel_y * 0.5:
                    if other_rect.xmin > self.parm.panel_x * 0.5:
                        # print "before", other_rect
                        other_rect = RECTANGLE(symbol=other_rect.symbol,
                                               xmin=(self.parm.panel_x - other_rect.xmin),
                                               ymin=(self.parm.panel_y - other_rect.ymin),
                                               xmax=(self.parm.panel_x - other_rect.xmax),
                                               ymax=(self.parm.panel_y - other_rect.ymax))
                    else:
                        # print "before", other_rect
                        other_rect = RECTANGLE(symbol=other_rect.symbol,
                                               xmin=other_rect.xmin,
                                               ymin=(self.parm.panel_y - other_rect.ymin),
                                               xmax=other_rect.xmax,
                                               ymax=(self.parm.panel_y - other_rect.ymax))
                elif other_rect.ymin < self.parm.panel_y * 0.5:
                    if other_rect.xmin > self.parm.panel_x * 0.5:
                        other_rect = RECTANGLE(symbol=other_rect.symbol,
                                               xmin=(self.parm.panel_x - other_rect.xmin),
                                               ymin=other_rect.ymin,
                                               xmax=(self.parm.panel_x - other_rect.xmax),
                                               ymax=other_rect.ymax)
                if "-lyh" in self.JOB and step is not None:       
                    if other_rect.symbol == "s3750":
                        step.addRectangle(other_rect.xmin, other_rect.ymin, other_rect.xmax, other_rect.ymax)   
                    if step is not None and not include_rect:
                        step.addRectangle(other_rect.xmin, other_rect.ymin, other_rect.xmax, other_rect.ymax)                
        
            if self.__class__.__name__ in ['hdi_slice', 'out_ccd', 'text_drl_hole']:
                # === 切片孔避让备用靶,备用靶单边加大5mm进行避让 ===增加避让常规标靶
                if re.match(r'^hdi1-by', other_rect.symbol):
                    other_rect = RECTANGLE(symbol='s15000', xmin=(other_rect.xmin - 5), ymin=(other_rect.ymin - 5),
                                           xmax=(other_rect.xmax + 5), ymax=(other_rect.ymax + 5))
                if re.match(r'rect\d+\.?\dx5080', other_rect.symbol):
                    other_rect = RECTANGLE(symbol=other_rect.symbol, xmin=(other_rect.xmin - 6.5),
                                           ymin=(other_rect.ymin - 6.5),
                                           xmax=(other_rect.xmax + 6.5), ymax=(other_rect.ymax + 6.5))
                    
            if area_rect.touch(other_rect):                
                # if other_rect not in avoid_rectangles:
                if self.__class__.__name__ in ['hdi_slice', 'sz_hole', 'sh_sec', 'add_four_lengnew', 'ldi_stamp']:
                    # --HDI切片孔及试钻孔、长边sh-sec、右下角层别标示不需要避开热溶块和铆钉孔
                    # if other_rect.symbol not in ['chris-rjpad','sh-mdk-t']:
                    if other_rect.symbol not in ['chris-rjpad']:
                        avoid_rectangles.append(other_rect)
                elif self.__class__.__name__ in ['same_circle']:
                    # --同心圆不需要避开rm_rh_sym圆pad
                    if other_rect.symbol not in ['rm_rh_sm']:
                        avoid_rectangles.append(other_rect)
                elif self.__class__.__name__ in ['sh_bj', 'sh_sh']:
                    # --外层ccd对位孔不需要避开内层靶距symbol和sh-sh,参考x留边较小的料号484/439a1
                    if other_rect.symbol not in ['sh-dwtop2013']:
                        avoid_rectangles.append(other_rect)
                else:
                    # --再次去重,加快运行速度
                    avoid_rectangles.append(other_rect)
                                   

        # --对挑出的需要避开的区域进行筛选并排序
        avoid_same_direct = []
        for rect in avoid_rectangles:
            if rect.touch(area_rect):
                avoid_same_direct.append(rect)
                
        # --修正坐标,所有坐标只做平移，短边移x坐标，长边只移y坐标
        #if "-lyh" in self.JOB and step is not None:       
            #for other_rect in avoid_same_direct:
                #step.addRectangle(other_rect.xmin, other_rect.ymin, other_rect.xmax, other_rect.ymax)           
        
        # 确定移动方向 step步长负数为从大到小移动 正数为从小到大移动
        new_area_x = (area_xmin, area_xmax, move_x_step)
        if move_x_step < 0:
            new_area_x = (area_xmax, area_xmin, move_x_step)
    
        new_area_y = (area_ymin, area_ymax, move_y_step)
        if move_y_step < 0:
            new_area_y = (area_ymax, area_ymin, move_y_step)
        
        #print avoid_same_direct
        #print area_rect
        area_rect = RECTANGLE(symbol=sym_name, xmin=area_xmin, ymin=area_ymin,
                              xmax=area_xmax, ymax=area_ymax)
        
        find_rect_area = []
        
        if move_fx == "Y":
            for x in numpy.arange(*new_area_x):
                for y in numpy.arange(*new_area_y):
                    new_this_rect = self.get_rectangles(sym_name, sym_angle=sym_angle,x=x,y=y)[0]
                    new_this_rect.xmin = new_this_rect.xmin - to_feature_size
                    new_this_rect.ymin = new_this_rect.ymin - to_feature_size
                    new_this_rect.xmax = new_this_rect.xmax + to_feature_size
                    new_this_rect.ymax = new_this_rect.ymax + to_feature_size
                    
                    #if "-lyh" in self.JOB and step is not None:       
                        #step.addRectangle(new_this_rect.xmin, new_this_rect.ymin, new_this_rect.xmax, new_this_rect.ymax)                       
                    
                    if new_this_rect in [area_rect]:                    
                        for avoid_rect in avoid_same_direct:
                            if avoid_rect.touch(new_this_rect):
                                break
                        else:
                            find_rect_area.append([x, y, new_this_rect])
                            avoid_same_direct.append(new_this_rect)
        else:
            for y in numpy.arange(*new_area_y):
                for x in numpy.arange(*new_area_x):
                    new_this_rect = self.get_rectangles(sym_name, sym_angle=sym_angle,x=x,y=y)[0]
                    new_this_rect.xmin = new_this_rect.xmin - to_feature_size
                    new_this_rect.ymin = new_this_rect.ymin - to_feature_size
                    new_this_rect.xmax = new_this_rect.xmax + to_feature_size
                    new_this_rect.ymax = new_this_rect.ymax + to_feature_size
                    
                    if new_this_rect in [area_rect]:                    
                        for avoid_rect in avoid_same_direct:
                            if avoid_rect.touch(new_this_rect):
                                break
                        else:
                            find_rect_area.append([x, y, new_this_rect])
                            avoid_same_direct.append(new_this_rect)            
                    
        return find_rect_area                


    def move_other_direct(self, this_rect, area_rect, other_key, same_key, avoid_other_coord=None):
        """
        相对垂直方向移动
        :return: x,y移动后的坐标
        :rtype:
        """
        # --获取当前this_rect的最大最小值
        xmin = this_rect.xmin
        xmax = this_rect.xmax
        ymin = this_rect.ymin
        ymax = this_rect.ymax
        x, y, sym_name = this_rect.xc, this_rect.yc, this_rect.symbol
        # --重建this_rect,平移方向做平移回到起点位置
        if same_key == 'ymin':
            # --长边顶部
            ymax = area_rect.ymax - 0.1
            ymin = ymax - this_rect.get_lenY()
        elif same_key == 'ymax':
            # --长边底部
            ymin = area_rect.ymin + 0.1
            ymax = ymin + this_rect.get_lenY()
        elif same_key == 'xmin':
            # --短边右侧
            xmax = area_rect.xmax - 0.1
            xmin = xmax - this_rect.get_lenX()
        elif same_key == 'xmax':
            # --短边左侧
            xmin = area_rect.xmin + 0.1
            xmax = xmin + this_rect.get_lenX()
        # --更新矩形区域
        this_rect = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
        # --x,y为this_rect的中心
        x, y = this_rect.xc, this_rect.yc

        # --相对垂直方向的移动
        if other_key == 'xmax':
            # --长边右侧的symbol向右移
            x = avoid_other_coord + this_rect.get_lenX() / 2
        elif other_key == 'xmin':
            # --长边左侧的symbol向左移
            x = avoid_other_coord - this_rect.get_lenX() / 2
        elif other_key == 'ymax':
            # --短边顶部的symbol向上移
            y = avoid_other_coord + this_rect.get_lenY() / 2
        elif other_key == 'ymin':
            # --短边底部的symbol向下移
            y = avoid_other_coord - this_rect.get_lenY() / 2
        # --更新矩形区域
        this_rect = self.update_rect(x, y, this_rect)
        return x, y, this_rect

    def update_rect(self, x, y, this_rect):
        """
        通过传入的x,y中心重新生rectangle
        :param x:
        :param y:
        :return: RECTANGLE实例
        :rtype:
        """
        sym_name = this_rect.symbol
        xmin = x - this_rect.get_lenX() / 2
        ymin = y - this_rect.get_lenY() / 2
        xmax = x + this_rect.get_lenX() / 2
        ymax = y + this_rect.get_lenY() / 2
        this_rect = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
        return this_rect

    def get_touch_rect(self, other_rectangles, area_rect):
        """
        根据提供的区域找出touch的rect
        :return:
        :rtype:
        """
        touch_rectangles = []
        for other_rect in other_rectangles:
            if area_rect.touch(other_rect):
                if not any(other_rect.check_diff(obj) for obj in touch_rectangles):
                    # --再次去重,加快运行速度
                    touch_rectangles.append(other_rect)
        return touch_rectangles

    def touch_same_direct(self, this_rect, avoid_same_direct=None):
        """
        检查是否与same_direct其它rect重叠
        :return:
        :rtype:
        """
        # --this_rect内缩0.01mm,防止误touch
        this_rect.xmin += 0.01
        this_rect.xmax -= 0.01
        this_rect.ymin += 0.01
        this_rect.ymax -= 0.01
        for other_rect in avoid_same_direct:
            if this_rect.touch(other_rect):
                return True
        return False

    def move_same_direct(self, sym_name, x_org, y_org, this_rect, area_rect, same_key, avoid_same_direct=None):
        """
        同方向移动
        :return: x,y移动后的坐标
        :rtype:
        """
        avoid_same_origin = avoid_same_direct
        # --重新定义area_rect,总的area_rect可以包括多个小的area_rect
        avoid_same_direct = self.get_touch_rect(avoid_same_direct, area_rect)
        # --初始赋值x,y为传入的值x_org,y_org
        #print(avoid_same_direct)
        #print(avoid_same_origin)
        x, y = x_org, y_org
        # --定义pre_rect,主要用来确认移动后是否与上次rect冲突
        pre_rect = RECTANGLE(symbol=sym_name, xmin=0, ymin=0, xmax=0, ymax=0)
        for avoid_rect in avoid_same_direct:
            # --调试用,查看this_rect与avoid_rect是否touch以及与avoid_same_direct中的rect是否touch
            #if self.__class__.__name__ == 'out_ccd':
                #print "this_rect",this_rect
                #print "avoid_rect",avoid_rect
                #print "this_rect.touch(avoid_rect)",this_rect.touch(avoid_rect)
                #print "self.touch_same_direct(this_rect,avoid_same_direct=avoid_same_origin)",\
                    #self.touch_same_direct(this_rect,avoid_same_direct=avoid_same_origin)
                #self.GEN.PAUSE("check touch")
            # --touch到avoid_rect或者移动之后touch到avoid_same_origin,都需要重新移动到合适的位置
            if this_rect.touch(avoid_rect) or self.touch_same_direct(this_rect, avoid_same_direct=avoid_same_origin):
                if same_key == 'xmax':
                    # --左侧的symbol向右移
                    move_direct = 'R'
                    move_L = this_rect.xc - (avoid_rect.xmin - this_rect.get_lenX() / 2)
                    move_R = avoid_rect.xmax + this_rect.get_lenX() / 2 - this_rect.xc
                    if move_L < move_R:
                        xmin = this_rect.xmin - move_L
                        xmax = this_rect.xmax - move_L
                        ymin = this_rect.ymin
                        ymax = this_rect.ymax
                        tmp_rect = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
                        if not tmp_rect.touch(pre_rect) and tmp_rect in [area_rect]:
                            # --向左移动较小而且移动之后不与前一个RECT接触,则可以向左移
                            move_direct = 'L'
                    if move_direct == 'R':
                        # --向右移
                        x = avoid_rect.xmax + this_rect.get_lenX() / 2
                    else:
                        # --向左移
                        x = avoid_rect.xmin - this_rect.get_lenX() / 2
                elif same_key == 'xmin':
                    # --右侧的symbol向左移
                    move_direct = 'L'
                    move_L = this_rect.xc - (avoid_rect.xmin - this_rect.get_lenX() / 2)
                    move_R = avoid_rect.xmax + this_rect.get_lenX() / 2 - this_rect.xc
                    if move_R < move_L:
                        xmin = this_rect.xmin + move_R
                        xmax = this_rect.xmax + move_R
                        ymin = this_rect.ymin
                        ymax = this_rect.ymax
                        tmp_rect = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
                        if not tmp_rect.touch(pre_rect) and tmp_rect in [area_rect]:
                            # --向左移动较小而且移动之后不与前一个RECT接触,则可以向左移
                            move_direct = 'R'
                    if move_direct == 'L':
                        # --向左移
                        x = avoid_rect.xmin - this_rect.get_lenX() / 2
                    else:
                        # --向右移
                        x = avoid_rect.xmax + this_rect.get_lenX() / 2
                elif same_key == 'ymax':
                    # --底部的symbol向上移
                    move_direct = 'U'
                    move_D = this_rect.yc - (avoid_rect.ymin - this_rect.get_lenY() / 2)
                    move_U = avoid_rect.ymax + this_rect.get_lenY() / 2 - this_rect.yc
                    if move_D < move_U:
                        ymin = this_rect.ymin - move_D
                        ymax = this_rect.ymax - move_D
                        xmin = this_rect.xmin
                        xmax = this_rect.xmax
                        tmp_rect = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
                        if not tmp_rect.touch(pre_rect) and tmp_rect in [area_rect]:
                            # --向左移动较小而且移动之后不与前一个RECT接触,则可以向左移
                            move_direct = 'D'
                    if move_direct == 'U':
                        # --向上移
                        y = avoid_rect.ymax + this_rect.get_lenY() / 2
                    else:
                        # --向下移
                        y = avoid_rect.ymin - this_rect.get_lenY() / 2
                    # --调试用,查看移动方向及移动距离
                    # if self.__class__.__name__ == 'copper_rate':
                    #     print "move_direct",move_direct
                    #     print "same_key",same_key
                    #     self.GEN.PAUSE("check move_direct")
                elif same_key == 'ymin':
                    # --顶部的symbol向下移
                    move_direct = 'D'
                    move_D = this_rect.yc - (avoid_rect.ymin - this_rect.get_lenY() / 2)
                    move_U = avoid_rect.ymax + this_rect.get_lenY() / 2 - this_rect.yc
                    if move_U < move_D:
                        ymin = this_rect.ymin + move_U
                        ymax = this_rect.ymax + move_U
                        xmin = this_rect.xmin
                        xmax = this_rect.xmax
                        tmp_rect = RECTANGLE(symbol=sym_name, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
                        if not tmp_rect.touch(pre_rect) and tmp_rect in [area_rect]:
                            # --向左移动较小而且移动之后不与前一个RECT接触,则可以向左移
                            move_direct = 'U'
                    if move_direct == 'D':
                        # --向下移
                        y = avoid_rect.ymin - this_rect.get_lenY() / 2
                    else:
                        # --向上移
                        y = avoid_rect.ymax + this_rect.get_lenY() / 2
                    # --调试用,查看移动方向及移动距离
                    # if self.__class__.__name__ == 'silk_color':
                    #     print "move_direct",move_direct
                    #     print "same_key",same_key
                    #     self.GEN.PAUSE("check move_direct")
                # --更新矩形区域
                this_rect = self.update_rect(x, y, this_rect)
                # --此次避让区域作为下次参考
                pre_rect = avoid_rect
            else:
                # --没有touch的时候,并且前次移动后没有touch到其它symbol,不需要再继续移动
                # self.GEN.PAUSE("not touch")
                pass
            # --此次避让区域作为下次参考
            pre_rect = avoid_rect
        return x, y, this_rect


class corner_line_and_hole(STATIC_SYM):
    """
    角线和干膜孔
    """

    def __init__(self, frozen_json=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        put_copper_md = self.parm.put_copper_md
        dry_sym = "r" + str(self.parm.dry_hole * 1000)
        dry_md_sgt = "r" + str(self.parm.dry_hole * 1000 + 508)
        dry_md = 'dry_md'
        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin

        sm_conner_ymax = sr_ymax + 1
        sm_conner_xmax = sr_xmax + 1
        sm_conner_ymin = sr_ymin - 1
        sm_conner_xmin = sr_xmin - 1

        # --20201030梁涛要求修改孔坐标到圆pad中心
        global get_x_dis
        global get_y_dis
        dry_hole_x1 = sm_conner_xmin - 0.2446
        dry_hole_x2 = sm_conner_xmax + 0.2446
        dry_hole_y1 = sm_conner_ymin - 0.2446
        dry_hole_y2 = sm_conner_ymax + 0.2446
        get_x_dis = dry_hole_x2 - dry_hole_x1
        get_y_dis = dry_hole_y2 - dry_hole_y1
        get_x_dis = '%.1f' % get_x_dis
        get_y_dis = '%.1f' % get_y_dis

        # --坐标list
        line_x_list = [sm_conner_xmin, sm_conner_xmin, sm_conner_xmax, sm_conner_xmax]
        line_y_list = [sm_conner_ymin, sm_conner_ymax, sm_conner_ymax, sm_conner_ymin]
        # --注意干膜孔是以线属性添加的
        hole_x_list = [dry_hole_x1, dry_hole_x1, dry_hole_x2, dry_hole_x2]
        hole_y_list = [dry_hole_y1, dry_hole_y2, dry_hole_y2, dry_hole_y1]
        angle_list = [0, 90, 180, 270]
        # --20210226依刘文东要求取消防焊角线,防止上金
        info = {
            '内层': self.convert_to_dict(x_list=line_x_list, y_list=line_y_list, angle=angle_list, symbol='sh-con2'),
            '辅助层': self.convert_to_dict(x_list=line_x_list, y_list=line_y_list, angle=angle_list, symbol='sh-con2'),
            '外层': self.convert_to_dict(x_list=line_x_list, y_list=line_y_list, angle=angle_list, symbol='sh-con2'),
            # 翟鸣通知 脚线阻焊不开窗 20230727 by lyh
            # '防焊': self.convert_to_dict(x_list=line_x_list, y_list=line_y_list, angle=angle_list, symbol='sh-con2'),
            # === 周涌 2021.09.09 限位孔也要加挡点 ，单边大10mil ===
            '档点': self.convert_to_dict(x_list=hole_x_list, y_list=hole_y_list, angle=angle_list, symbol=dry_md_sgt),
            # '通孔': self.convert_to_dict (x_list=hole_x_list, y_list=hole_y_list, xe_list=hole_x_list,
            #                             ye_list=hole_y_list,
            #                             symbol=dry_sym),
            # === 周涌 2021.08.31 纠错，限位孔应跑出为pad，不应为线 ===
            #'通孔': self.convert_to_dict(x_list=hole_x_list, y_list=hole_y_list, symbol=dry_sym),
        }
        # 限位孔由0.452修改为0.46，与料号孔合刀 http://192.168.2.120:82/zentao/story-view-5187.html 20230316 by lyh
        # 此处加成线 输出时会自动与料号孔合刀
        if self.parm.xianwei_hole_same_to_jobname_hole == "YES":
            info['通孔'] = self.convert_to_dict (x_list=hole_x_list, y_list=hole_y_list, xe_list=hole_x_list,
                                                ye_list=hole_y_list,
                                                symbol=dry_sym)
        else:
            info['通孔'] = self.convert_to_dict(x_list=hole_x_list, y_list=hole_y_list, symbol=dry_sym)
            
        if put_copper_md == 'no':
            # --档点不铺铜时,D+20正极性copy到档点
            # --20210226依刘文东要求取消此框线，防止上金
            # info['档点'] = self.convert_to_dict(x_list=hole_x_list,y_list=hole_y_list,xe_list=hole_x_list,
            #                                   ye_list=hole_y_list, symbol=dry_md)
            pass
        # --选化D+20套负片
        # info['选化'] = self.convert_to_dict (x_list=hole_x_list, y_list=hole_y_list, xe_list=hole_x_list,
        #                                    ye_list=hole_y_list, symbol=dry_md_sgt, polarity='negative')

        info['选化'] = self.convert_to_dict(x_list=line_x_list, y_list=line_y_list, symbol=dry_md, angle=angle_list,
                                          polarity='negative')
        return info


class Tin_spray(STATIC_SYM):
    """
    喷锡挂孔,喷锡挂板孔
    """

    def __init__(self, frozen_json=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        top_after_margin = self.parm.top_after_margin
        left_after_margin = self.parm.left_after_margin
        tmp_content = self.JOB[6]
        job_signal_numbers = self.parm.job_signal_numbers
        hdi_num = self.parm.hdi_num
        lj_board_fd = self.parm.lj_board_fd
        put_copper_out = self.parm.put_copper_out
        put_copper_md = self.parm.put_copper_md

        other_sym_x1 = sr_xmin - 3.5
        other_sym_x2 = sr_xmax + 3.5
        other_sym_y1 = sr_ymin - 3.5
        other_sym_y2 = sr_ymax + 3.5
        other_sym_cx = profile_xmax * 0.5
        other_sym_cy = profile_ymax * 0.5

        if tmp_content in ['h', 'l']:
            if job_signal_numbers == 4:
                if top_after_margin < 7:
                    other_sym_cx = profile_xmax * 0.5 - 10
                    other_sym_cy = profile_ymax * 0.5 - 10
                else:
                    other_sym_cx = profile_xmax * 0.5 - 10
                    other_sym_cy = profile_ymax * 0.5 - 10
                if top_after_margin < 6:
                    other_sym_y1 = sr_ymin - 1.5
                    other_sym_y2 = sr_ymax + 1.5
                else:
                    other_sym_y1 = sr_ymin - 2.5875
                    other_sym_y2 = sr_ymax + 2.5875
                if left_after_margin < 6:
                    other_sym_x1 = sr_xmin - 1.5
                    other_sym_x2 = sr_xmax + 1.5
                else:
                    other_sym_x1 = sr_xmin - 2.5875
                    other_sym_x2 = sr_xmax + 2.5875
            other_sym_x_list = [other_sym_cx, other_sym_cx, other_sym_x1, other_sym_x2]
            other_sym_y_list = [other_sym_y2, other_sym_y1, other_sym_cy, other_sym_cy]
            if put_copper_out == "no":
                symbol_pol = 'negative'
            else:
                symbol_pol = 'positive'
            info['外层'] = self.convert_to_dict(x_list=other_sym_x_list, y_list=other_sym_y_list, symbol='r4191',
                                              polarity=symbol_pol)
            info['防焊'] = self.convert_to_dict(x_list=other_sym_x_list, y_list=other_sym_y_list, symbol='r3683')

            info['通孔'] = self.convert_to_dict(x_list=other_sym_x_list, y_list=other_sym_y_list, symbol='r3175')
            if put_copper_md == 'no':
                # --档点不铺铜时,D+20正极性copy到档点
                info['档点'] = self.convert_to_dict(x_list=other_sym_x_list, y_list=other_sym_y_list, symbol='r3683')
            # --选化D+20套负片
            info['选化'] = self.convert_to_dict(x_list=other_sym_x_list, y_list=other_sym_y_list, symbol='r3683',
                                              polarity='negative')
            # === V2.00 取消，实际不需要这个点 ===
            # if hdi_num >= 1 and lj_board_fd == 'no':
            #     # --双面板,三靶均有加多一个r0,此处针对HDI板在底部加多一个r0
            #     info['外层'].extend (self.convert_to_dict (x_list=[other_sym_cx], y_list=[other_sym_y1], symbol='r0',
            #                                              attribute='.out_flag,int=226'))
            #     info['文字'] = self.convert_to_dict (x_list=[other_sym_cx], y_list=[other_sym_y1], symbol='r0',
            #                                        attribute='.out_flag,int=226')
            return info
        else:
            # === 非喷锡板不加挂孔 === http://192.168.2.120:82/zentao/story-view-2496.html
            return info
        
class calc_bk_fd_hole_area(DYNAMIC_SYM):
    """
    1.计算出vcut防呆监测孔的区域 供后面程序自动避开此孔 20221123 by lyh
    2.避开右下角一个阻焊固定对位靶点 代码位置：silk_dw_x2 = sr_xmax - 40.64 - other_fd_h  暂时取消
    2.避开右上角一个阻焊固定对位靶点 代码位置：silk_dw_fdx2 = sr_xmax - 43.64 + right_fd_h  暂时取消
    """
    priority = 0.1

    def __init__(self, frozen_json=None, avoidArea=None, priority=priority):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        DO_INFO获取pad坐标
        :return:
        :rtype:
        """
        info = {}
        sel_vut = self.parm.sel_vut
        other_fd_h = self.parm.right_fd_h
        right_fd_h = self.parm.right_fd_h
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        #info['避开区域silk_dw_x2'] = self.convert_to_dict(x_list=[sr_xmax - 40.64 - other_fd_h ],
                                                              #y_list=[sr_ymin - 2 - 1.2],
                                                              #symbol='r4000')
        #info['避开区域silk_dw_fdx2'] = self.convert_to_dict(x_list=[sr_xmax - 43.64 + right_fd_h ],
                                                              #y_list=[sr_ymax + 2 + 1.2],
                                                              #symbol='r4000')        
        jobname = self.JOB        
        stepname = "panel"
        job = gClasses.Job(jobname)
        step = gClasses.Step(job, stepname)
        step.open()
        step.COM("units,type=mm")
        step.removeLayer("bk_area_tmp")
        step.createLayer("bk_area_tmp")         
        
        if sel_vut == '否':           
            return info
        
        worklayer = "vcut"        
        if step.isLayer(worklayer):
            step.removeLayer(worklayer+"_tmp_lyh")
            step.flatten_layer(worklayer, worklayer+"_tmp_lyh")
            layer_cmd = gClasses.Layer(step, worklayer+"_tmp_lyh")
            feat_out = layer_cmd.featCurrent_LayerOut(units="mm")["lines"]
            step.removeLayer(worklayer+"_tmp_lyh")
            
            step.removeLayer("bk_area_tmp")
            step.createLayer("bk_area_tmp")
            #计算四周的vcut线 延伸出来的区域为避开区域
            all_x = [obj.xs for obj in feat_out]
            all_x += [obj.xe for obj in feat_out]
            all_y = [obj.ys for obj in feat_out]
            all_y += [obj.ye for obj in feat_out]
            min_x = min(all_x)
            max_x = max(all_x)
            min_y = min(all_y)
            max_y = max(all_y)
            
            i = 0
            for obj in feat_out:                
                i += 1
                x_list = 0
                y_list = 0
                if obj.angle in [0, 180]:
                    # 左侧  
                    if obj.xe < min_x + 5 or \
                       obj.xs < min_x + 5:                        
                        x_list = min([obj.xe, obj.xs]) - 1.5
                        y_list = obj.ye
                    # 右侧
                    if obj.xe > max_x - 5 or \
                       obj.xs > max_x - 5:
                        x_list = max([obj.xe, obj.xs]) + 1.5
                        y_list = obj.ye
                        
                elif obj.angle in [90, 270]:
                    # 下侧
                    if obj.ye < min_y + 5 or \
                       obj.ys < min_y + 5:                        
                        x_list = obj.xe
                        y_list = min([obj.ye, obj.ys]) - 1.5
                    # 上侧
                    if obj.ye > max_y - 5 or \
                       obj.ys > max_y - 5:                        
                        x_list = obj.xe
                        y_list = max([obj.ye, obj.ys]) + 1.5
                else:
                    continue
                
                if not x_list and not y_list:
                    continue

                info['避开区域{0}'.format(i)] = self.convert_to_dict(x_list=[x_list], y_list=[y_list], symbol='r1000.15')
        
        return info
            

class add_v_cut(DYNAMIC_SYM):
    """
    添加v_cut测试孔,vcut测试孔是固定的,但是因为要避开其它孔，尤其是服务器模块孔,所以放到最后添加,并改成DYNAMIC
    """
    priority = 17

    def __init__(self, frozen_json=None, avoidArea=None, priority=17):
        self.parm = frozen_json
        self.priority = priority
        # self.avoidType = None
        # --需要考虑避开后面的添加的drl_moudle模块避开vcut定位孔
        self.avoidType = 'outer'
        self.touch_hole = 'no'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        DO_INFO获取pad坐标
        :return:
        :rtype:
        """
        info = {}
        sel_vut = self.parm.sel_vut
        if sel_vut == '否':
            return info
        put_copper_out = self.parm.put_copper_out
        put_copper_md = self.parm.put_copper_md
        flow_content = self.parm.flow_content
        add_first_plant = self.parm.add_first_plant
        self.get_pad_coord()
        if self.touch_hole == 'yes':
            # msg_box = msgBox()
            # msg_box.critical(self, '警告', 'Vcut 孔与其他的孔有重叠，请检查！', QMessageBox.Ok)
            msg_dict = {'type': 'critical',
                        'windowTitle': '警告',
                        'content': 'Vcut 孔与其他的孔有重叠，请检查！'}
            self.msg_array.append(msg_dict)
        info = self.GEN.INFO('-t layer -e %s/panel/add_vcut_dw -m script -d FEATURES' % self.JOB)
        self.GEN.DELETE_LAYER('add_vcut_dw')
        padRegex = re.compile(r'^#P')
        vcut_dw_x = []
        vcut_dw_y = []
        vcut_dw_drl = []
        vcut_dw_out = []
        vcut_dw_sm = []
        for line in info:
            if re.match(padRegex, line):
                columns = line.strip().split()
                x = float('%.3f' % float(columns[1]))
                y = float('%.3f' % float(columns[2]))
                sym = columns[3]
                size = float(sym[1:])
                vcut_dw_x.append(x)
                vcut_dw_y.append(y)
                vcut_dw_drl.append(sym)
                if put_copper_out == "yes" and flow_content == '一次铜':
                    # --一次铜铺铜板边,加大30mil
                    vcut_dw_out.append('r%s' % (size + 762))
                else:
                    # --正常加大12mil
                    vcut_dw_out.append('r%s' % (size + 304.8))
                # --防焊加大10mil
                vcut_dw_sm.append('r%s' % (size + 254))
        info = self.GEN.INFO('-t layer -e %s/panel/add_vcut -m script -d FEATURES' % self.JOB)
        self.GEN.DELETE_LAYER('add_vcut')
        vcut_fd_x = []
        vcut_fd_y = []
        vcut_fd_drl = []
        vcut_fd_out = []
        vcut_fd_sm = []
        for line in info:
            if re.match(padRegex, line):
                columns = line.strip().split()
                x = float('%.2f' % float(columns[1]))
                y = float('%.2f' % float(columns[2]))
                sym = columns[3]
                size = float(sym[1:])
                vcut_fd_x.append(x)
                vcut_fd_y.append(y)
                vcut_fd_drl.append(sym)
                # --外层D+20套或者补pad
                vcut_fd_out.append('r%s' % (size + 508))
                # --防焊加大10mil
                vcut_fd_sm.append('r%s' % (size + 254))
        # --为防止与DO_INFO的info冲突,重新定义info为字典
        info = {}
        attribute_pth = '.string,text=vcut_dw;.drill,option=plated,int=226'
        attribute_via = '.string,text=vcut_fd;.drill,option=via,int=226'
        info['通孔'] = self.convert_to_dict(x_list=vcut_dw_x, y_list=vcut_dw_y, symbol='r3175', attribute=attribute_pth)
        info['通孔'].extend(
            self.convert_to_dict(x_list=vcut_fd_x, y_list=vcut_fd_y, symbol=vcut_fd_drl, attribute=attribute_via))
        if put_copper_md == 'no':
            # --档点不铺铜时,D+20正极性copy到档点
            info['档点'] = self.convert_to_dict(x_list=vcut_dw_x, y_list=vcut_dw_y, symbol='r3683',
                                              attribute=attribute_pth)
            # --symbol D+20正好与外层等大
            info['档点'].extend(
                self.convert_to_dict(x_list=vcut_fd_x, y_list=vcut_fd_y, symbol=vcut_fd_out, attribute=attribute_via))
        # --选化D+20套负片
        info['选化'] = self.convert_to_dict(x_list=vcut_dw_x, y_list=vcut_dw_y, symbol='r3683', polarity='negative',
                                          attribute=attribute_pth)
        info['选化'].extend(
            self.convert_to_dict(x_list=vcut_fd_x, y_list=vcut_fd_y, symbol=vcut_fd_out, polarity='negative',
                                 attribute=attribute_via))

        # --外层
        if add_first_plant == "yes" or flow_content == '二次铜':
            # === 2021.08.24 周涌要求维持旧板边规则，vcut孔二次铜时外层套铜
            vcut_dw_pol = 'negative'
            vcut_fd_pol = 'negative'
        else:
            # --为防止上金，二三四五六厂vcut定位孔全部做成NPTH
            vcut_dw_pol = 'negative'
            vcut_fd_pol = 'negative'
        info['外层'] = self.convert_to_dict(x_list=vcut_dw_x, y_list=vcut_dw_y, symbol=vcut_dw_out, polarity=vcut_dw_pol,
                                          attribute=attribute_pth)
        info['外层'].extend(
            self.convert_to_dict(x_list=vcut_fd_x, y_list=vcut_fd_y, symbol=vcut_fd_out, polarity=vcut_fd_pol,
                                 attribute=attribute_via))

        info['防焊'] = self.convert_to_dict(x_list=vcut_dw_x, y_list=vcut_dw_y, symbol=vcut_dw_sm,
                                          attribute=attribute_pth)
        info['防焊'].extend(
            self.convert_to_dict(x_list=vcut_fd_x, y_list=vcut_fd_y, symbol=vcut_fd_sm, attribute=attribute_via))
        return info

    def add_vcut_dw_pad(self, loop_num=0, add_cut_x=None, add_cut_y=None, add_cut_x1=None, add_cut_y1=None, nx=0, ny=0):
        """
        添加vcut对位pad
        :return:
        :rtype:
        """
        through_drl = self.parm.drl
        add_vcut_ok = 'no'
        for i in range(loop_num):
            self.GEN.DELETE_LAYER('add_vcut_dw')
            self.GEN.CREATE_LAYER('add_vcut_dw')
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('add_vcut_dw', 'yes')
            self.GEN.COM('cur_atr_reset')
            self.GEN.COM('cur_atr_set,attribute=.drill,option=plated,int=226')
            if vcut_num_x > 0 and vcut_num_y == 0:
                # --只有竖着的vcut
                self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r3175,polarity=positive,angle=0,mirror=no,'
                             'nx=1,ny=%s,dx=0,dy=100000,xscale=1,yscale=1' % (add_cut_x, add_cut_y1, ny))
            if vcut_num_y > 0 and vcut_num_x == 0:
                # --只有横着的vcut
                add_cut_x = add_cut_x1 - (nx - 1) * 100
                self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r3175,polarity=positive,angle=0,mirror=no,'
                             'nx=%s,ny=1,dx=100000,dy=0,xscale=1,yscale=1' % (add_cut_x, add_cut_y, nx))
            # --删除防爆孔，排除干扰
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER(through_drl, 'yes')
            self.GEN.FILTER_RESET()
            self.GEN.COM('filter_atr_set,filter_name=popup,condition=yes,attribute=.string,text=fbk')
            self.GEN.FILTER_SELECT()
            # --选中防爆孔并加大20mil
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.COM('sel_resize,size=508,corner_ctl=no')
            self.GEN.COM('sel_ref_feat,layers=add_vcut_dw,use=filter,mode=touch,pads_as=shape,'
                         'f_types=line\;pad\;surface\;arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=')
            # --删除与vcut定位孔touch到的防爆孔
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                #翟鸣 通知 这些位置的防爆孔正常加，人工判断移开还是删除。20231114 by lyh
                # self.GEN.SEL_DELETE()
                pass
            # --还原防暴孔大小
            self.GEN.FILTER_SELECT()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.COM('sel_resize,size=-508,corner_ctl=no')
            self.GEN.FILTER_RESET()
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('add_vcut_dw', 'yes')
            # --加大50mil不能touch通孔
            # self.GEN.COM('sel_resize,size=1270,corner_ctl=no')
            self.GEN.COM('sel_ref_feat,layers=%s,use=filter,mode=touch,pads_as=shape,'
                         'f_types=line\;pad\;surface\;arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=' % through_drl)
            # self.GEN.PAUSE("touch")
            count = self.GEN.GET_SELECT_COUNT()
            if count == 0:
                # self.GEN.COM('sel_resize,size=-1270,corner_ctl=no')
                # self.GEN.PAUSE("ok")
                add_vcut_ok = "yes"
                break
            if add_vcut_ok == 'no':
                # self.GEN.COM('sel_resize,size=-1270,corner_ctl=no')
                # self.GEN.PAUSE("bak")
                if vcut_num_x > 0 and vcut_num_y == 0:
                    # --只有竖着的vcut
                    add_cut_y1 = add_cut_y1 + 1
                if vcut_num_y > 0 and vcut_num_x == 0:
                    # --只有横着的vcut
                    add_cut_x1 = add_cut_x1 - 1
        # --横竖都有vcut时,不用循环
        if vcut_num_y > 0 and vcut_num_x > 0:
            self.GEN.DELETE_LAYER('add_vcut_dw')
            self.GEN.CREATE_LAYER('add_vcut_dw')
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('add_vcut_dw', 'yes')
            # --横竖都有vcut
            self.GEN.COM("add_pad,attributes=yes,x=%s,y=%s,symbol=r3175,polarity=positive,angle=0,mirror=no,"
                         "nx=1,ny=%s,dx=0,dy=100000,xscale=1,yscale=1" % (add_cut_x, add_cut_y, ny))
            add_cut_x1 = add_cut_x - nx * 100
            self.GEN.COM("add_pad,attributes=yes,x=%s,y=%s,symbol=r3175,polarity=positive,angle=0,mirror=no,"
                         "nx=%s,ny=1,dx=100000,dy=0,xscale=1,yscale=1" % (add_cut_x1, add_cut_y, nx))
            # --删除防爆孔，排除干扰
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER(through_drl, 'yes')
            self.GEN.FILTER_RESET()
            self.GEN.COM('filter_atr_set,filter_name=popup,condition=yes,attribute=.string,text=fbk')
            self.GEN.FILTER_SELECT()
            # --选中防爆孔并加大20mil
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.COM('sel_resize,size=508,corner_ctl=no')
            self.GEN.COM('sel_ref_feat,layers=add_vcut_dw,use=filter,mode=touch,pads_as=shape,'
                         'f_types=line\;pad\;surface\;arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=')
            # --删除与vcut定位孔touch到的防爆孔
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                #翟鸣 通知 这些位置的防爆孔正常加，人工判断移开还是删除。20231114 by lyh
                # self.GEN.SEL_DELETE()
                pass
            # --还原防暴孔大小
            self.GEN.FILTER_SELECT()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.COM('sel_resize,size=-508,corner_ctl=no')
            self.GEN.FILTER_RESET()
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('add_vcut_dw', 'yes')
            self.GEN.COM('sel_ref_feat,layers=%s,use=filter,mode=touch,pads_as=shape,'
                         'f_types=line\;pad\;surface\;arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=' % through_drl)
            count = self.GEN.GET_SELECT_COUNT()
            if count == 0:
                add_vcut_ok = "yes"
        if add_vcut_ok == 'no':
            self.touch_hole = "yes"
        self.GEN.CLEAR_LAYER()

    def add_vcut_fd_pad(self):
        """
        添加vcut防呆pad
        :return:
        :rtype:
        """
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        sr_xmin = self.parm.sr_xmin
        through_drl = self.parm.drl
        # --添加层偏对位点
        self.GEN.DELETE_LAYER('add_vcut')
        self.GEN.CREATE_LAYER('add_vcut')
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('add_vcut', 'yes')
        pn_seven = self.JOB[6]
        pn_eight = self.JOB[7]
        if vcut_num_x > 0 and vcut_num_y == 0:
            # --只有竖着的vcut
            # --第七码是e的为化金+碳油流程,2021.2.17刘文东要求添加
            if pn_seven in ['g', 'o', 'e'] or pn_eight in ['y', 'r', 'l']:
                cp_hole_y1 = vcut_check_hole_y1
                cp_hole_y2 = vcut_check_hole_y2
            else:
                cp_hole_y1 = sr_ymin - 1.5
                cp_hole_y2 = sr_ymax + 1.5
            for i in range(vcut_num_x):
                self.GEN.COM('cur_atr_reset')
                self.GEN.COM('cur_atr_set,attribute=.drill,option=via,int=226')
                # --只有竖着的vcut
                self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r%s,polarity=positive,angle=0,mirror=no,'
                             'nx=1,ny=1,dx=0,dy=100000,xscale=1,yscale=1' % (
                                 vcut_x_list[i], cp_hole_y1, vcut_check_hole))
                self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r%s,polarity=positive,angle=0,mirror=no,'
                             'nx=1,ny=1,dx=0,dy=100000,xscale=1,yscale=1' % (
                                 vcut_x_list[i], cp_hole_y2, vcut_check_hole))
        if vcut_num_y > 0 and vcut_num_x == 0:
            # --只有横着的vcut
            # --第七码是e的为化金+碳油流程,2021.2.17刘文东要求添加
            if pn_seven in ['g', 'o', 'e'] or pn_eight in ['y', 'r', 'l']:
                cp_hole_x1 = vcut_check_hole_x1
                cp_hole_x2 = vcut_check_hole_x2
            else:
                cp_hole_x1 = sr_xmin - 1.5
                cp_hole_x2 = sr_xmax + 1.5
            for i in range(vcut_num_y):
                self.GEN.COM('cur_atr_reset')
                self.GEN.COM('cur_atr_set,attribute=.drill,option=via,int=226')
                # --只有横着的vcut
                self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r%s,polarity=positive,angle=0,mirror=no,'
                             'nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1' % (
                                 cp_hole_x1, vcut_y_list[i], vcut_check_hole))
                self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r%s,polarity=positive,angle=0,mirror=no,'
                             'nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1' % (
                                 cp_hole_x2, vcut_y_list[i], vcut_check_hole))
        if vcut_num_y > 0 and vcut_num_x > 0:
            # --横竖都有vcut
            # --第七码是e的为化金+碳油流程,2021.2.17刘文东要求添加
            if pn_seven in ['g', 'o', 'e'] or pn_eight in ['y', 'r', 'l']:
                cp_hole_x1 = vcut_check_hole_x1
                cp_hole_x2 = vcut_check_hole_x2
                pass
            else:
                cp_hole_x1 = sr_xmin - 1.5
                cp_hole_x2 = sr_xmax + 1.5
                pass
            for i in range(vcut_num_y):
                self.GEN.COM('cur_atr_reset')
                self.GEN.COM('cur_atr_set,attribute=.drill,option=via,int=226')
                # --横着的vcut
                self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r%s,polarity=positive,angle=0,mirror=no,'
                             'nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1' % (
                                 cp_hole_x1, vcut_y_list[i], vcut_check_hole))
                self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r%s,polarity=positive,angle=0,mirror=no,'
                             'nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1' % (
                                 cp_hole_x2, vcut_y_list[i], vcut_check_hole))
            # --第七码是e的为化金+碳油流程,2021.2.17刘文东要求添加
            if pn_seven in ['g', 'o', 'e'] or pn_eight in ['y', 'r', 'l']:
                cp_hole_y1 = vcut_check_hole_y1
                cp_hole_y2 = vcut_check_hole_y2
            else:
                cp_hole_y1 = sr_ymin - 1.5
                cp_hole_y2 = sr_ymax + 1.5
            for i in range(vcut_num_x):
                self.GEN.COM('cur_atr_reset')
                self.GEN.COM('cur_atr_set,attribute=.drill,option=via,int=226')
                # --竖着的vcut
                self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r%s,polarity=positive,angle=0,mirror=no,'
                             'nx=1,ny=1,dx=0,dy=100000,xscale=1,yscale=1' % (
                                 vcut_x_list[i], cp_hole_y1, vcut_check_hole))
                self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r%s,polarity=positive,angle=0,mirror=no,'
                             'nx=1,ny=1,dx=0,dy=100000,xscale=1,yscale=1' % (
                                 vcut_x_list[i], cp_hole_y2, vcut_check_hole))
        # --先将vcut防呆孔加大20mil
        self.GEN.COM('sel_resize,size=508,corner_ctl=no')
        # --判断是否重叠(不能与drl和inn中的孔相重)
        self.GEN.COM('sel_ref_feat,layers=%s\;inn,use=filter,mode=touch,pads_as=shape,f_types=line\;pad\;surface\;'
                     'arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=' % through_drl)
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM('sel_delete')
        # --还原vcut防呆孔大小
        self.GEN.COM('sel_resize,size=-508,corner_ctl=no')
        # --判断是否与外层对位pad冲突
        self.GEN.DELETE_LAYER('add_vcut_avoid')
        self.GEN.CREATE_LAYER('add_vcut_avoid')
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('l1', 'yes')
        self.GEN.FILTER_RESET()
        self.GEN.COM('filter_set,filter_name=popup,update_popup=no,include_syms=sh-dwsig2014\;sh_silk_autodw')
        self.GEN.FILTER_SELECT()
        self.GEN.FILTER_RESET()
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.SEL_COPY('add_vcut_avoid')
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('add_vcut_avoid', 'yes')
            self.GEN.SEL_CONTOURIZE()
            self.GEN.COM('sel_resize,size=-508,corner_ctl=no')
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('add_vcut', 'yes')
            self.GEN.COM('sel_ref_feat,layers=add_vcut_avoid,use=filter,mode=touch,pads_as=shape,f_types=line\;pad\;'
                         'surface\;arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=')
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.COM('sel_delete')
        self.GEN.DELETE_LAYER('add_vcut_avoid')
        self.GEN.CLEAR_LAYER()

    def get_pad_coord(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        job_signal_numbers = self.parm.job_signal_numbers
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        split_pth = self.parm.split_pth
        global vcut_check_hole
        global vcut_x_list
        global vcut_y_list
        global vcut_num_x
        global vcut_num_y
        global vcut_check_hole_x1
        global vcut_check_hole_x2
        global vcut_check_hole_y1
        global vcut_check_hole_y2
        if split_pth >= 0.8 and split_pth <= 1.2:
            vcut_check_hole = split_pth * 1000
        else:
            vcut_check_hole = 1000
        info = self.GEN.DO_INFO('-t layer -e %s/panel/vcut -d EXISTS' % self.JOB)
        if info['gEXISTS'] == 'yes':
            self.GEN.DELETE_LAYER('vcut_flat')
            self.GEN.CLEAR_LAYER()
            self.GEN.COM('flatten_layer,source_layer=vcut,target_layer=vcut_flat')
            vcut_x_list = []
            vcut_y_list = []
            info = self.GEN.INFO('-t layer -e %s/panel/vcut_flat -m script -d FEATURES' % self.JOB)
            self.GEN.DELETE_LAYER('vcut_flat')
            lineRegex = re.compile(r'^#L')
            for line in info:
                if re.match(lineRegex, line):
                    columns = line.strip().split()
                    file_x1 = float('%.0f' % float(columns[1]))
                    file_x2 = float('%.0f' % float(columns[3]))
                    file_x3 = float('%.0f' % float(columns[2]))
                    file_x4 = float('%.0f' % float(columns[4]))
                    dif_value_x = math.fabs(file_x1 - file_x2)
                    dif_value_y = math.fabs(file_x3 - file_x4)
                    add_x_vcut_pad = 'no'
                    if dif_value_x < dif_value_y:
                        add_x_vcut_pad = "yes"
                        if dif_value_x >= 2:
                            # msg_box = msgBox()
                            # msg_box.critical(self, '警告', 'Vcut线画的不值，请确认是否影响V-cut！', QMessageBox.Ok)
                            msg_dict = {'type': 'critical',
                                        'windowTitle': '警告',
                                        'content': 'Vcut线画的不直，请确认是否影响V-cut！'}
                            self.msg_array.append(msg_dict)
                    else:
                        if dif_value_y >= 2:
                            # msg_box = msgBox()
                            # msg_box.critical(self, '警告', 'Vcut线画的不值，请确认是否影响V-cut！', QMessageBox.Ok)
                            msg_dict = {'type': 'critical',
                                        'windowTitle': '警告',
                                        'content': 'Vcut线画的不直，请确认是否影响V-cut！'}
                            self.msg_array.append(msg_dict)
                    if add_x_vcut_pad == 'yes':
                        vcut_tmp = float('%.2f' % float(columns[1]))
                        if vcut_tmp not in vcut_x_list:
                            vcut_x_list.append(vcut_tmp)
                    else:
                        vcut_tmp = float('%.2f' % float(columns[2]))
                        if vcut_tmp not in vcut_y_list:
                            vcut_y_list.append(vcut_tmp)
            vcut_num_x = len(vcut_x_list)
            vcut_num_y = len(vcut_y_list)
            if job_signal_numbers == 2:
                vcut_check_hole_x1 = 3
                vcut_check_hole_x2 = profile_xmax - 3
                vcut_check_hole_y1 = profile_ymin + 3
                vcut_check_hole_y2 = profile_ymax - 3
            else:
                vcut_check_hole_x1 = (profile_xmax - rout_x) * 0.5 + 3
                vcut_check_hole_x2 = profile_xmax - (profile_xmax - rout_x) * 0.5 - 3
                vcut_check_hole_y1 = profile_ymin + (profile_ymax - rout_y) * 0.5 + 3
                vcut_check_hole_y2 = profile_ymax - (profile_ymax - rout_y) * 0.5 - 3
            if vcut_num_x > 0 and vcut_num_y == 0:
                # --只有竖着的vcut
                # --TODO 求出最右侧vcut中心x坐标
                vcut_min_x = max(vcut_x_list)
                if job_signal_numbers >= 4:
                    # --最新规则四层板锣边follow六层板
                    # --20210118新规则,所有板层,以开料尺寸做拼版
                    vcut_max_x = profile_xmax - (profile_xmax - rout_x) * 0.5
                    vcut_y = profile_ymin + (profile_ymax - rout_y) * 0.5
                else:
                    vcut_max_x = profile_xmax
                    vcut_y = profile_ymin
                # --TODO vcut定位孔加在右长边中心,定位长边中心x坐标
                margin_center_x = (vcut_max_x - sr_xmax) * 0.5 + sr_xmax
                # --TODO 定位孔到最右侧vcut必须>8mm
                dis_vcut = margin_center_x - vcut_min_x
                if dis_vcut > 8:
                    add_cut_x = margin_center_x
                    # self.GEN.PAUSE("add_cut_x")
                else:
                    add_cut_x = margin_center_x + 8 - dis_vcut
                # --TODO 再次计算add_cut_x,其实没必要,fd_cut_dis永远是小于8
                fd_cut_dis = vcut_max_x - add_cut_x
                if fd_cut_dis < 8:
                    add_cut_x = add_cut_x
                else:
                    add_cut_x = vcut_max_x - 7
                    # self.GEN.PAUSE("reset add_cut_x")
                add_cut_y1 = vcut_y + 3.5
                add_cut_y2 = vcut_y + 8
                # --从下到上开始添加.
                loop_num = int(add_cut_y2 - add_cut_y1) + 1
                dis_panel_y = profile_ymax - vcut_y - add_cut_y1
                vcut_num = int(dis_panel_y / 100) + 1
                self.add_vcut_dw_pad(loop_num=loop_num, add_cut_x=add_cut_x, add_cut_y1=add_cut_y1, ny=vcut_num)
                self.add_vcut_fd_pad()
                # self.GEN.PAUSE("add_vcut_fd_pad")

            if vcut_num_y > 0 and vcut_num_x == 0:
                # --只有横着的vcut
                vcut_min_y = min(vcut_y_list)
                if job_signal_numbers >= 4:
                    # --最新规则四层板锣边follow六层板
                    # --20210118新规则,所有板层,以开料尺寸做拼版
                    vcut_max_y = (profile_ymax - rout_y) * 0.5
                    vcut_x = profile_xmax - (profile_xmax - rout_x) * 0.5
                else:
                    vcut_max_y = profile_ymin
                    vcut_x = profile_xmax
                # --留边的一半，加上单边锣带的大小
                margin_center_y = (sr_ymin - vcut_max_y) * 0.5 + vcut_max_y
                # --TODO 定位孔到最下面vcut必须>8mm
                dis_vcut = vcut_min_y - margin_center_y
                if dis_vcut > 8:
                    add_cut_y = margin_center_y
                else:
                    add_cut_y = margin_center_y - (8 - dis_vcut)
                # --TODO 再次计算add_cut_y,其实没必要,add_cut_ydis永远是小于8
                add_cut_ydis = add_cut_y - vcut_max_y
                if add_cut_ydis < 8:
                    add_cut_y = add_cut_y
                else:
                    add_cut_y = 7 + vcut_max_y
                add_cut_x1 = vcut_x - 3.5
                add_cut_x2 = vcut_x - 8
                if job_signal_numbers >= 4:
                    # --最新规则四层板锣边follow六层板
                    # --20210118新规则,所有板层,以开料尺寸做拼版
                    len_vcut = add_cut_x1 - (profile_xmax - rout_x) * 0.5
                else:
                    len_vcut = add_cut_x1
                # --从左到右开始添加.
                loop_num = int(add_cut_x1 - add_cut_x2) + 1
                vcut_num = int(len_vcut / 100) + 1
                self.add_vcut_dw_pad(loop_num=loop_num, nx=vcut_num, add_cut_y=add_cut_y, add_cut_x1=add_cut_x1)
                self.add_vcut_fd_pad()

            if vcut_num_y > 0 and vcut_num_x > 0:
                # --横竖都有vcut
                # --TODO 求出最右侧vcut中心x坐标
                vcut_min_x = max(vcut_x_list)
                if job_signal_numbers >= 4:
                    # --最新规则四层板锣边follow六层板
                    # --20210118新规则,所有板层,以开料尺寸做拼版
                    vcut_max_x = profile_xmax - (profile_xmax - rout_x) * 0.5
                    vcut_y = profile_ymin + (profile_ymax - rout_y) * 0.5
                else:
                    vcut_max_x = profile_xmax
                    vcut_y = profile_ymin
                vcut_max_x = vcut_max_x - 4
                add_cut_xc = vcut_min_x
                add_cut_y = (sr_ymin - vcut_y) * 0.5 + vcut_y
                fd_cut_dis = add_cut_y - vcut_y
                if fd_cut_dis < 8:
                    add_cut_y = add_cut_y
                else:
                    add_cut_y = vcut_y + 7

                vcut_min_y = min(vcut_y_list)
                add_y_fd_dis = vcut_min_y - add_cut_y
                if add_y_fd_dis < 8:
                    add_cut_y = add_cut_y - (8 - add_y_fd_dis)
                else:
                    add_cut_y = add_cut_y
                if job_signal_numbers >= 4:
                    # --最新规则四层板锣边follow六层板
                    # --20210118新规则,所有板层,以开料尺寸做拼版
                    vcut_max_y = profile_ymin + (profile_ymax - rout_y) * 0.5
                    vcut_x = profile_xmax - (profile_xmax - rout_x) * 0.5
                else:
                    vcut_max_y = profile_ymin
                    vcut_x = profile_xmax
                vcut_max_y = vcut_max_y + 4
                vcut_min_y = vcut_min_y - 8 - 3.175 * 0.5

                add_cut_x = (vcut_x - sr_xmax) * 0.5 + sr_xmax
                vcut_xy_dis = add_cut_x - add_cut_xc
                if vcut_xy_dis < 9.6:
                    add_cut_x = add_cut_x + 9.6 - vcut_xy_dis
                fd_vcut_dis1 = vcut_x - add_cut_x
                if fd_vcut_dis1 > 3:
                    add_cut_x = add_cut_x
                else:
                    add_cut_x = add_cut_x - 1.6

                vcut_numy = int((profile_ymax - add_cut_y - vcut_y) / 100) + 1
                vcut_numx = int((add_cut_x - (profile_xmax - vcut_x)) / 100) + 1
                vcut_numx1 = vcut_numx - 1
                self.add_vcut_dw_pad(add_cut_x=add_cut_x, add_cut_y=add_cut_y, nx=vcut_numx1, ny=vcut_numy)
                self.add_vcut_fd_pad()
        else:
            # msg_box = msgBox()
            # msg_box.critical(self, '警告', 'Vcut层不存在，请创建vcut层！', QMessageBox.Ok)
            msg_dict = {'type': 'critical',
                        'windowTitle': '警告',
                        'content': 'Vcut层不存在，请创建vcut层！'}
            self.msg_array.append(msg_dict)
            # --因为考虑到socket运行模式,所以不能直接调用sys.exit(),而是向上抛出异常，供上一级捕获
            raise SystemExit
            # sys.exit()


class add_pxfb_hole(DYNAMIC_SYM):
    """
    添加喷锡防爆孔,在添加drl和2nd尾孔模块之后,在输出残铜率之前
    """
    priority = 20

    def __init__(self, frozen_json=None, avoidArea=None, priority=20):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = None
        self.touch_hole = 'no'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        DO_INFO获取pad坐标
        :return:
        :rtype:
        """
        info = {}
        pn_seven = self.JOB[6]
        put_copper_out = self.parm.put_copper_out
        job_signal_numbers = self.parm.job_signal_numbers
        flow_content = self.parm.flow_content
        if pn_seven not in ['h', 'l']:
            # --仅限喷锡板
            return info
        if job_signal_numbers <= 2:
            # --双面板不加
            return info
        # === V2.02 HDI无此条件 ===
        # if flow_content == '一次铜':
        #     # --一次铜不加喷锡防爆孔
        #     return info
        self.add_fangbao_hole()
        info = self.GEN.INFO('-t layer -e %s/panel/add_pxfb -m script -d FEATURES' % self.JOB)
        self.GEN.DELETE_LAYER('add_pxfb')
        padRegex = re.compile(r'^#P')
        pxfb_x = []
        pxfb_y = []
        pxfb_drl = []
        pxfb_out = []
        pxfb_out_pol = []
        pxfb_sm = []
        pxfb_md = []
        for line in info:
            if re.match(padRegex, line):
                columns = line.strip().split()
                x = float('%.1f' % float(columns[1]))
                y = float('%.1f' % float(columns[2]))
                sym = columns[3]
                size = float(sym[1:])
                pxfb_x.append(x)
                pxfb_y.append(y)
                pxfb_drl.append(sym)
                if put_copper_out == "yes":
                    # --一次铜铺铜板边,加大30mil
                    pxfb_out.append('r%s' % (size + 762))
                    pxfb_out_pol.append('positive')
                else:
                    # --正常加大20mil
                    pxfb_out.append('r%s' % (size + 508))
                    pxfb_out_pol.append('negative')
                # --防焊D+8,单边4mil
                pxfb_sm.append('r%s' % (size + 203.2))
                # --档点D+6,单边3mil
                pxfb_md.append('r%s' % (size + 152.4))
        # --为防止与DO_INFO的info冲突,重新定义info为字典
        info = {}
        attribute_pxfb = '.string,text=pxfb;.drill,option=non_plated,int=226'
        info['通孔'] = self.convert_to_dict(x_list=pxfb_x, y_list=pxfb_y, symbol='r1000', attribute=attribute_pxfb)
        info['外层'] = self.convert_to_dict(x_list=pxfb_x, y_list=pxfb_y, symbol=pxfb_out, polarity=pxfb_out_pol,
                                          attribute=attribute_pxfb)
        info['防焊'] = self.convert_to_dict(x_list=pxfb_x, y_list=pxfb_y, symbol=pxfb_sm, polarity='positive',
                                          attribute=attribute_pxfb)
        info['档点'] = self.convert_to_dict(x_list=pxfb_x, y_list=pxfb_y, symbol=pxfb_md, polarity='positive',
                                          attribute=attribute_pxfb)
        return info

    def add_fangbao_hole(self):
        """
        添加喷锡防爆孔
        :return:
        :rtype:
        """
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        sr_xmin = self.parm.sr_xmin
        through_drl = self.parm.drl

        px_v_x = sr_xmin
        px_v_y1 = sr_ymax + 2.5
        px_v_y2 = sr_ymin - 2.5
        px_h_y = sr_ymin
        px_h_x1 = sr_xmax + 2.5
        px_h_x2 = sr_xmin - 2.5

        # x_nums = int ((sr_xmax - sr_xmin) / 10) + 1
        # y_nums = int ((sr_ymax - sr_ymin) / 10) + 1
        x_nums = int((sr_xmax - sr_xmin) / 5) + 1
        y_nums = int((sr_ymax - sr_ymin) / 5) + 1

        # --避开drl、2nd模块孔、服务器模块孔
        self.GEN.CLEAR_LAYER()
        self.GEN.DELETE_LAYER('pxfb_avoid')
        self.GEN.CREATE_LAYER('pxfb_avoid')
        self.GEN.AFFECTED_LAYER('panel_map', 'yes')
        # --将服务器模块挑出到pxfb_avoid层
        self.GEN.FILTER_TEXT_ATTR('.string', 'server_moudle', reset=1)
        self.GEN.FILTER_SELECT()
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.SEL_COPY('pxfb_avoid')
        # --将drl等尾孔模块挑出到pxfb_avoid层
        self.GEN.FILTER_TEXT_ATTR('.string', '*_tail_hole', reset=1)
        self.GEN.FILTER_SELECT()
        self.GEN.FILTER_RESET()
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.SEL_COPY('pxfb_avoid')
        # self.GEN.PAUSE("check")
        # --添加层偏对位点
        self.GEN.DELETE_LAYER('add_pxfb')
        self.GEN.CREATE_LAYER('add_pxfb')
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('add_pxfb', 'yes')
        # --防爆孔外层有pad,所以定义plated属性
        self.GEN.COM('cur_atr_reset')
        self.GEN.COM('cur_atr_set,attribute=.drill,option=plated,int=226')
        # --短边上
        self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r1000,polarity=positive,angle=0,mirror=no,'
                     'nx=%s,ny=1,dx=5000,dy=0,xscale=1,yscale=1' % (px_v_x, px_v_y1, x_nums))
        # --短边下
        self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r1000,polarity=positive,angle=0,mirror=no,'
                     'nx=%s,ny=1,dx=5000,dy=0,xscale=1,yscale=1' % (px_v_x, px_v_y2, x_nums))
        # --长边右
        self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r1000,polarity=positive,angle=0,mirror=no,'
                     'nx=1,ny=%s,dx=0,dy=5000,xscale=1,yscale=1' % (px_h_x1, px_h_y, y_nums))
        # --长边左
        self.GEN.COM('add_pad,attributes=yes,x=%s,y=%s,symbol=r1000,polarity=positive,angle=0,mirror=no,'
                     'nx=1,ny=%s,dx=0,dy=5000,xscale=1,yscale=1' % (px_h_x2, px_h_y, y_nums))

        # --先将喷锡防爆孔加大2mm,删除与孔touch的
        self.GEN.COM('sel_resize,size=2000,corner_ctl=no')
        # --判断是否重叠(不能与drl和inn中的孔相重)
        self.GEN.COM('sel_ref_feat,layers=%s\;inn,use=filter,mode=touch,pads_as=shape,f_types=line\;pad\;surface\;'
                     'arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=' % through_drl)
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM('sel_delete')

        # --判断是否重叠(不能与外层symbol相重)
        out_signal_array = self.parm.out_signal_array
        self.GEN.COM('sel_ref_feat,layers=pxfb_avoid\;l1\;%s,use=filter,mode=touch,pads_as=shape,f_types=line\;pad\;'
                     'arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=rect3981x45381xr190\;'
                     'rect3219x44619\;sh-outpg*\;chris-outpg*\;sh-opnew*'
                     % out_signal_array[1])
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM('sel_delete')

        # --再将喷锡防爆孔加大2mm,删除与铆钉symbol图形touch的
        JB_layers = self.parm.JB_layers
        self.GEN.COM('sel_resize,size=2000,corner_ctl=no')
        self.GEN.COM('sel_ref_feat,layers=%s,use=filter,mode=touch,pads_as=shape,f_types=line\;pad\;surface\;'
                     'arc\;text,polarity=positive\;negative,include_syms=sh-mdk*\;hdi1-mdk*,exclude_syms=' % JB_layers[
                         0])
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM('sel_delete')

        # --再将喷锡防爆孔加大16mm,删除与靶标touch的
        self.GEN.COM('sel_resize,size=16000,corner_ctl=no')
        self.GEN.COM('sel_ref_feat,layers=%s,use=filter,mode=touch,pads_as=shape,f_types=line\;pad\;surface\;'
                     'arc\;text,polarity=positive\;negative,include_syms=sh-ba*\;hdi1-ba*,exclude_syms=' % JB_layers[0])
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM('sel_delete')
        # --还原喷锡防爆孔大小
        self.GEN.COM('sel_resize,size=-20000,corner_ctl=no')
        self.GEN.DELETE_LAYER('pxfb_avoid')
        self.GEN.CLEAR_LAYER()


class chinese_cb(STATIC_SYM):
    """
    中文厂别
    """

    def __init__(self, frozen_json=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = None
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        sh_site = self.parm.sh_site
        site_list = ['HDI一厂', 'HDI二厂']
        sym_list = ['chris_sh11', 'chris_sh12']
        profile_xmax = self.parm.profile_xmax
        sr_ymin = self.parm.sr_ymin
        index = site_list.index(sh_site)
        cb_sym = sym_list[index]

        chinese_x1 = profile_xmax + 11.3
        chinese_y1 = sr_ymin + 40
        chinese_y2 = sr_ymin + 40 + 16
        # 庄潜潜多次反馈，厂别与内层多普ccd重叠，导致ccd残缺，将厂别往上移60mm
        # 2019.11.25李家兴修改
        chinese_y1 = chinese_y1 + 60
        chinese_y2 = chinese_y2 + 60

        # --坐标list
        top_x_list = [chinese_x1]
        top_y_list = [chinese_y1]
        bot_x_list = [chinese_x1]
        bot_y_list = [chinese_y2]
        info = {
            '外层c': self.convert_to_dict(x_list=top_x_list, y_list=top_y_list, angle=270, symbol=cb_sym),
            '内层c': self.convert_to_dict(x_list=top_x_list, y_list=top_y_list, angle=270, symbol=cb_sym),
            '内层s': self.convert_to_dict(x_list=bot_x_list, y_list=bot_y_list, angle=90, symbol=cb_sym, mirror='yes'),
            '外层s': self.convert_to_dict(x_list=bot_x_list, y_list=bot_y_list, angle=90, symbol=cb_sym, mirror='yes'),
        }
        return info


class silk_word(STATIC_SYM):
    """
    sh-opnew2014->sh-opnew2021
    """

    def __init__(self, frozen_json=None, priority=3):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        profile_ymax = self.parm.profile_ymax
        profile_xmax = self.parm.profile_xmax

        sr_xmax = self.parm.sr_xmax
        have_silk_in_pcb = self.parm.have_silk_in_pcb
        add_ld_symbol = self.parm.add_ld_symbol
        put_copper_out = self.parm.put_copper_out
        pn_seven = self.JOB[6]

        if pn_seven not in ['h', 'l']:
            silk_word_x = sr_xmax + 3.5
        else:
            silk_word_x = sr_xmax + 3.5 + 1.0406125
        silk_word_yt = profile_ymax * 0.5 + 48 - 10
        silk_word_yb = silk_word_yt + (48.434345 - 32.5217375)
        sgt_x = silk_word_x - 0.074
        sgt_y = silk_word_yt + 7.931
        md_word_x = profile_xmax + 2.8
        # --坐标list
        coord_x_list = [silk_word_x]
        coord_md_x_list = [md_word_x]
        coord_yt_list = [silk_word_yt]
        coord_yb_list = [silk_word_yb]

        coord_sgt_x_list = [sgt_x]
        coord_sgt_y_list = [sgt_y]
        sym_sgt = 'rect80960x2935'
        if put_copper_out == "no":
            pol_outer = 'negative'
            # pol_other = 'positive'
            # --外层蚀刻为正字,防焊下油，且比蚀刻字大
            sym_outer = 'sh-opnew2021+0mil'
            sym_other = 'sh-opnew2021+3mil'
        else:
            pol_outer = 'positive'
            # pol_other = 'negative'
            # --外层为负字,防焊对应开窗,外层比防焊字大
            sym_outer = 'sh-opnew2021+3mil'
            sym_other = 'sh-opnew2021+0mil'
        # === 2021.08.10 周涌要求防焊料号名为正字，与旧板边一致
        pol_other = 'negative'
        info = {
            '文字c': self.convert_to_dict(x_list=coord_x_list, y_list=coord_yt_list, angle=270, symbol=sym_other,
                                        polarity='negative', mirror="no"),
            '文字s': self.convert_to_dict(x_list=coord_x_list, y_list=coord_yb_list, angle=90, symbol=sym_other,
                                        polarity='negative', mirror="yes"),
            '防焊c': self.convert_to_dict(x_list=coord_x_list, y_list=coord_yt_list, angle=270, symbol=sym_other,
                                        polarity=pol_other, mirror="no"),
            '防焊s': self.convert_to_dict(x_list=coord_x_list, y_list=coord_yb_list, angle=90, symbol=sym_other,
                                        polarity=pol_other, mirror="yes"),
            '外层c': self.convert_to_dict(x_list=coord_x_list, y_list=coord_yt_list, angle=270, symbol=sym_outer,
                                        polarity=pol_outer, mirror="no"),
            '外层s': self.convert_to_dict(x_list=coord_x_list, y_list=coord_yb_list, angle=90, symbol=sym_outer,
                                        polarity=pol_outer, mirror="yes"),
            '档点c': self.convert_to_dict(x_list=coord_md_x_list, y_list=coord_yt_list, angle=270, symbol=sym_other,
                                        polarity=pol_other, mirror="no"),
            '档点s': self.convert_to_dict(x_list=coord_md_x_list, y_list=coord_yb_list, angle=90, symbol=sym_other,
                                        polarity=pol_other, mirror="yes"),
            '碳油c': self.convert_to_dict(x_list=coord_x_list, y_list=coord_yt_list, angle=270, symbol=sym_other,
                                        polarity='negative', mirror="no"),
            '碳油s': self.convert_to_dict(x_list=coord_x_list, y_list=coord_yb_list, angle=90, symbol=sym_other,
                                        polarity='negative', mirror="yes"),
            'w': self.convert_to_dict(x_list=coord_x_list, y_list=coord_yt_list, angle=270, symbol=sym_other,
                                      polarity='negative', mirror="no"),
            '选化c': self.convert_to_dict(x_list=coord_sgt_x_list, y_list=coord_sgt_y_list, angle=90, symbol=sym_sgt,
                                        polarity='negative', mirror="yes"),
            '选化s': self.convert_to_dict(x_list=coord_sgt_x_list, y_list=coord_sgt_y_list, angle=90, symbol=sym_sgt,
                                        polarity='negative', mirror="yes"),
        }
        info['选化c'].extend(
            self.convert_to_dict(x_list=coord_md_x_list, y_list=coord_yt_list, angle=270, symbol=sym_other,
                                 polarity=pol_other, mirror="no"))
        info['选化s'].extend(
            self.convert_to_dict(x_list=coord_md_x_list, y_list=coord_yb_list, angle=90, symbol=sym_other,
                                 polarity=pol_other, mirror="yes"))

        # --添加镭雕制程
        if have_silk_in_pcb == "yes":
            if add_ld_symbol == "是":
                # === 二次文字时会与镭雕字样重叠，下移3.5 V2.08
                ld_symbol_x_top = silk_word_x + 2.5
                ld_symbol_y_top = silk_word_yt - 50 - 12 - 3.5
                ld_symbol_x_bot = ld_symbol_x_top
                ld_symbol_y_bot = ld_symbol_y_top + 25 - 3.5
                info['文字c'].extend(self.convert_to_dict(x_list=[ld_symbol_x_top], y_list=[ld_symbol_y_top],
                                                        angle=0, symbol='sh-ld-sym', mirror="no"))
                info['文字s'].extend(self.convert_to_dict(x_list=[ld_symbol_x_bot], y_list=[ld_symbol_y_bot],
                                                        angle=180, symbol='sh-ld-sym', mirror="yes"))
        return info


class sh_out_pg(STATIC_SYM):
    """
    HDI 变更外层曝光框为二次铜时加CCD挂孔
    """

    def __init__(self, frozen_json=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        # --主要是sh-dwpad要避开所有层,sh-outpganew其它不用考虑
        self.avoidType = 'all'
        self.msg_array = []
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        profile_xmax = self.parm.profile_xmax
        profile_xmin = self.parm.profile_xmin
        profile_ymax = self.parm.profile_ymax
        rout_x = self.parm.rout_x
        sr_xmin = self.parm.sr_xmin
        # put_copper_md = self.parm.put_copper_md
        put_copper_out = self.parm.put_copper_out
        # add_three_plant = self.parm.add_three_plant
        # add_first_plant = self.parm.add_first_plant
        # add_hj_panel = self.parm.add_hj_panel
        hdi_num = self.parm.hdi_num
        flow_content = self.parm.flow_content
        job_signal_numbers = self.parm.job_signal_numbers

        ccd_hole_x = sr_xmin - 6
        info = {}
        return info  #全部取消添加 20240326
        if flow_content == '一次铜':
            return info
        # --添加ccd挂pin孔
        if hdi_num < 1:
            # --非hdi料号
            ccd_hole_y1 = profile_ymax * 0.5 + 130
            ccd_hole_y2 = profile_ymax * 0.5 - 125
        else:
            # --hdi料号
            ccd_hole_y1 = profile_ymax * 0.5 + 5 * 25.4
            ccd_hole_y2 = ccd_hole_y1 - 255
        ccd_hole_x_list = [ccd_hole_x, ccd_hole_x]
        ccd_hole_y_list = [ccd_hole_y1, ccd_hole_y2]
        ccd_hole_sym = 'sh-dwpad'
        ccd_hole_clear = None
        ccd_hole_pol = 'positive'

        info['通孔'] = self.convert_to_dict(x_list=ccd_hole_x_list, y_list=ccd_hole_y_list, symbol='r3175')
        info['外层'] = self.convert_to_dict(x_list=ccd_hole_x_list, y_list=ccd_hole_y_list, symbol=ccd_hole_sym,
                                          polarity=ccd_hole_pol)
        info['选化'] = self.convert_to_dict(x_list=ccd_hole_x_list, y_list=ccd_hole_y_list, symbol='r3686')
        info['化金'] = self.convert_to_dict(x_list=ccd_hole_x_list, y_list=ccd_hole_y_list, symbol='sh-dwpad')
        info['蚀刻引线'] = self.convert_to_dict(x_list=ccd_hole_x_list, y_list=ccd_hole_y_list, symbol='sh-dwpad')
        info['内层'] = self.convert_to_dict(x_list=ccd_hole_x_list, y_list=ccd_hole_y_list, symbol='sh-dwpad')
        info['辅助层'] = self.convert_to_dict(x_list=ccd_hole_x_list, y_list=ccd_hole_y_list, symbol='sh-dwpad')
        info['档点'] = self.convert_to_dict(x_list=ccd_hole_x_list, y_list=ccd_hole_y_list, symbol='r3686')

        # --长边留边超过25mm时，加两排ccd孔
        ccd_out_x = 0
        add_ccd = "no"
        if job_signal_numbers == 2:
            len_rout = sr_xmin
        else:
            len_rout = sr_xmin - profile_xmin - (profile_xmax - rout_x) * 0.5
        if sr_xmin > 25 and sr_xmin <= 35:
            if job_signal_numbers == 2:
                if len_rout > 25:
                    ccd_out_x = profile_xmin + 10
                    add_ccd = "yes"
            else:
                if len_rout > 20:
                    ccd_out_x = profile_xmin + (profile_xmax - rout_x) * 0.5 + 10
                    add_ccd = "yes"
        if sr_xmin > 35 and sr_xmin <= 50:
            if job_signal_numbers == 2:
                if len_rout > 25:
                    ccd_out_x = profile_xmin + 20
                    add_ccd = "yes"
            else:
                if len_rout > 20:
                    ccd_out_x = profile_xmin + (profile_xmax - rout_x) * 0.5 + 20
                    add_ccd = "yes"
        if sr_xmin > 50:
            if job_signal_numbers == 2:
                if len_rout > 25:
                    ccd_out_x = profile_xmin + 25
                    add_ccd = "yes"
            else:
                if len_rout > 20:
                    ccd_out_x = profile_xmin + (profile_xmax - rout_x) * 0.5 + 25
                    add_ccd = "yes"
        add_hole_x_list = [ccd_out_x, ccd_out_x]
        add_hole_y_list = [ccd_hole_y1, ccd_hole_y2]
        if add_ccd == "yes":
            info['外层'].extend(self.convert_to_dict(x_list=add_hole_x_list, y_list=add_hole_y_list,
                                                   symbol=ccd_hole_sym, polarity=ccd_hole_pol))
            # --化金板且外层铺铜时,其它厂别还是依据story-view-690d套掉sh-dwpad上的pad,做成npth孔,防止掉膜碎
            # info['外层'].extend(self.convert_to_dict(x_list=add_hole_x_list, y_list=add_hole_y_list,
            #                                        symbol=ccd_hole_clear,polarity='negative'))
            info['内层'].extend(self.convert_to_dict(x_list=add_hole_x_list, y_list=add_hole_y_list,
                                                   symbol='sh-dwpad'))
            info['辅助层'].extend(self.convert_to_dict(x_list=add_hole_x_list, y_list=add_hole_y_list,
                                                    symbol='sh-dwpad'))
            info['通孔'].extend(self.convert_to_dict(x_list=add_hole_x_list, y_list=add_hole_y_list,
                                                   symbol='r3175'))

            # --选化喷锡挂Pin孔还是以D+20补PAD
            info['选化'].extend(self.convert_to_dict(x_list=add_hole_x_list, y_list=add_hole_y_list,
                                                   symbol='r3683'))
            info['档点'].extend(self.convert_to_dict(x_list=add_hole_x_list, y_list=add_hole_y_list,
                                                   symbol='r3683'))

        return info


class add_gm_line(STATIC_SYM):
    """
    添加干膜线
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        # --不需要避开
        self.avoidType = None
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        fill_array = self.parm.fill_array
        lamination = self.parm.lamination
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        lam_rout = self.parm.lam_rout
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        put_copper_out = self.parm.put_copper_out
        out_signal_array = self.parm.out_signal_array
        # TODO用于在所有信号层添加干膜线
        # --所有信号层
        for fill_hash in fill_array:
            layer_name = fill_hash.layer_name
            gm_size_inch = fill_hash.gm_size
            lamin_num = int(fill_hash.lamin_num)

            # === 获取当前压合次数及压合结果，判断干膜线加在长边还是短边
            # === 取当前压合次数
            # === 取当前压合的锣边
            current_gm_size = float(gm_size_inch) * 25.4
            tmp_lamin_num = lamin_num
            input_rout_x = rout_x
            input_rout_y = rout_y
            if tmp_lamin_num == 0:
                input_rout_x = panel_x
                input_rout_y = panel_y
            else:
                input_rout_x = [i[1] for i in lam_rout if i[0] == tmp_lamin_num][0]
                input_rout_y = [i[2] for i in lam_rout if i[0] == tmp_lamin_num][0]

            add_gm_side = ''
            (gm_startx, gm_starty, gm_endx, gm_endy) = (0, 0, 0, 0)

            # === 判断干膜线加在长边还是短边 ===
            if current_gm_size <= input_rout_y and current_gm_size > input_rout_x:
                add_gm_side = 'updown'
                gm_startx = (panel_x - input_rout_x) * 0.5
                gm_starty = (panel_y - current_gm_size) * 0.5
                gm_endx = gm_startx + input_rout_x
                gm_endy = gm_starty + current_gm_size
            elif current_gm_size <= input_rout_x:
                add_gm_side = 'leftright'
                gm_startx = (panel_x - current_gm_size) * 0.5
                gm_starty = (panel_y - input_rout_y) * 0.5
                gm_endx = gm_startx + current_gm_size
                gm_endy = gm_starty + input_rout_y
            # else:
            #     $mw->Dialog(-title= > 'Dialog',
            #     -text = > "压合$tmp_lamin_num 干膜尺寸 $current_gm_size 无法确认加在长边还是短边",
            #     -default_button = > 'Ok',
            #     -buttons = >['Ok'],
            #     -bitmap = > 'error')->Show();
            #     }
            ad_pol = 'negative'

            if put_copper_out == 'yes' and layer_name in out_signal_array:
                ad_pol = 'positive'

            line_xs_list = [gm_startx, gm_endx, gm_endx, gm_startx]
            line_xe_list = [gm_endx, gm_endx, gm_startx, gm_startx]
            line_ys_list = [gm_starty, gm_starty, gm_endy, gm_endy]
            line_ye_list = [gm_starty, gm_endy, gm_endy, gm_starty]

            info[layer_name] = self.convert_to_dict(x_list=line_xs_list, y_list=line_ys_list,
                                                    xe_list=line_xe_list,
                                                    ye_list=line_ye_list, symbol='r1', polarity=ad_pol)

        return info


# class long_arrow(STATIC_SYM):
#     """
#     防焊长边箭头  取消添加 http://192.168.2.120:82/zentao/story-view-6269.html
#     """
# 
#     def __init__(self, frozen_json=None, priority=2):
#         self.parm = frozen_json
#         self.priority = priority
#         self.avoidType = 'outer'
#         STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)
# 
#     def get_sym_info(self):
#         """
#         获取symbol添加时的坐标极性等相关信息
#         :return:
#         :rtype:
#         """
#         # add_first_plant = self.parm.add_first_plant
#         profile_ymax = self.parm.profile_ymax
#         sr_xmin = self.parm.sr_xmin
#         tmp_content1 = self.JOB[6]
#         if tmp_content1 in ['h', 'l']:
#             arror_x = sr_xmin - 4
#             arror_y = profile_ymax * 0.5 + 15
#         else:
#             arror_x = sr_xmin - 4
#             arror_y = profile_ymax * 0.5
#         # if add_first_plant == "yes":
#         #     sym = 'sh-row-la'
#         # else:
#         sym = 'sh-row-mc'
#         info = {'防焊': self.convert_to_dict(x_list=[arror_x], y_list=[arror_y], symbol=sym)}
#         return info


class SM_copper(object):
    """
    防焊板边铺铜
    """

    def __init__(self, frozen_json=None, priority=0):
        self.parm = frozen_json
        self.GEN = genCOM.GEN_COM()
        self.JOB = os.environ.get('JOB', None)
        self.cusNo = self.JOB[1:4]

    def put_copper(self):
        """
        依据fill_array指定的铺铜方式进行铺铜
        :return:
        :rtype:
        """
        fill_array = self.parm.fill_array
        add_first_plant = self.parm.add_first_plant
        sh_site = self.parm.sh_site
        pn_7_8 = self.JOB[6:8]
        pn_seven = self.JOB[6:7]
        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        board_thick = self.parm.board_thick
        flow_content = self.parm.flow_content
        fill_margin_x = sr_xmin - 2.5
        fill_margin_y = sr_ymin - 2.5
        fill_margin_x1 = sr_xmax + 2.5
        fill_margin_y1 = sr_ymax + 2.5
        judge_phone_subplate = self.parm.judge_phone_subplate
        job_signal_numbers = self.parm.job_signal_numbers
        # http://192.168.2.120:82/zentao/story-view-5150.html 取消0.4板厚限制 按新的规则来控制 20230302 by lyh
        #if board_thick <= 0.4:
            ## == song 引用注释-- 20201015李家兴依据story-view-2035修改，板厚小于0.4mm的板，取消防焊板边大开窗（铺铜）
            #return
        
        if add_first_plant == 'yes' and pn_7_8 in ['py', 'pr']:
            # --一厂防焊铺铜
            self.GEN.CLEAR_LAYER()
            self.GEN.COM('affected_filter,filter=(type=solder_mask&context=board&side=top|bottom)')
            sel_gold_x1 = sr_xmin + 50.8 + 20
            sel_gold_y1 = sr_ymax + 1.6
            sel_gold_y2 = profile_ymax + 2
            sel_gold_x2 = sr_xmax - 40.6 - 20
            self.GEN.COM("add_surf_strt,surf_type=feature")
            self.GEN.COM("add_surf_poly_strt,x=%s,y=%s" % (sel_gold_x1, sel_gold_y1))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x1, sel_gold_y2))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x2, sel_gold_y2))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x2, sel_gold_y1))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x1, sel_gold_y1))
            self.GEN.COM("add_surf_poly_end")
            self.GEN.COM("add_surf_end,attributes=no,polarity=positive")

            sel_gold_x1 = sr_xmin + 50.8 + 20
            sel_gold_y1 = profile_ymin - 2
            sel_gold_y2 = sr_ymin - 2
            sel_gold_x2 = sr_xmax - 40.6 - 20

            self.GEN.COM("add_surf_strt,surf_type=feature")
            self.GEN.COM("add_surf_poly_strt,x=%s,y=%s" % (sel_gold_x1, sel_gold_y1))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x1, sel_gold_y2))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x2, sel_gold_y2))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x2, sel_gold_y1))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x1, sel_gold_y1))
            self.GEN.COM("add_surf_poly_end")
            self.GEN.COM("add_surf_end,attributes=no,polarity=positive")

            sel_gold_x1 = profile_xmin - 2
            sel_gold_y1 = sr_ymin + 12.7 + 20 + 10
            sel_gold_y2 = sr_ymax - 38.1 - 20
            sel_gold_x2 = sr_xmin - 1.6

            self.GEN.COM("add_surf_strt,surf_type=feature")
            self.GEN.COM("add_surf_poly_strt,x=%s,y=%s" % (sel_gold_x1, sel_gold_y1))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x1, sel_gold_y2))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x2, sel_gold_y2))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x2, sel_gold_y1))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x1, sel_gold_y1))
            self.GEN.COM("add_surf_poly_end")
            self.GEN.COM("add_surf_end,attributes=no,polarity=positive")

            sel_gold_x1 = sr_xmax + 1.6
            sel_gold_y1 = sr_ymin + 12.7 + 20 + 10
            sel_gold_y2 = sr_ymax - 38.1 - 20
            sel_gold_x2 = profile_xmax + 2

            self.GEN.COM("add_surf_strt,surf_type=feature")
            self.GEN.COM("add_surf_poly_strt,x=%s,y=%s" % (sel_gold_x1, sel_gold_y1))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x1, sel_gold_y2))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x2, sel_gold_y2))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x2, sel_gold_y1))
            self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (sel_gold_x1, sel_gold_y1))
            self.GEN.COM("add_surf_poly_end")
            self.GEN.COM("add_surf_end,attributes=no,polarity=positive")
        if add_first_plant == 'no':
            # 添加防焊铜边
            self.GEN.CLEAR_LAYER()
            self.GEN.COM('affected_filter,filter=(type=solder_mask&context=board&side=top|bottom)')
            # 薛岩弟需求 http://192.168.2.120:82/zentao/story-view-513.html开窗距离锣边10mm
            # === 2022.03.07 V2.06 增加双面板数据转换
            if job_signal_numbers == 2:
                # === 2021.09.03 双面板，锣后尺寸使用板尺寸 ===
                rout_x = profile_xmax
                rout_y = profile_ymax
            clip_x1 = (profile_xmax - rout_x) * 0.5 + 10
            clip_y1 = (profile_ymax - rout_y) * 0.5 + 10
            clip_x2 = (profile_xmax - rout_x) * 0.5 + rout_x - 10
            clip_y2 = (profile_ymax - rout_y) * 0.5 + rout_y - 10
            self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,"
                         "use_arcs=yes,symbol=,dx=2.54,dy=2.54,std_angle=45,std_line_width=254,std_step_dist=1270,"
                         "std_indent=odd,break_partial=yes,cut_prims=no,outline_draw=no,outline_width=0,outline_invert=no")
            self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-8,step_margin_y=-8,step_max_dist_x=2540,"
                         "step_max_dist_y=2540,sr_margin_x=2.5,sr_margin_y=2.5,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                         "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
            if pn_seven in ['h', 'l'] or (pn_seven == 'g' and (flow_content == "二次铜" or judge_phone_subplate)):
                self.GEN.COM("clip_area_strt")
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_x1, clip_y1))
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_x2, clip_y2))
                self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                             "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
            else:
                self.GEN.COM("clip_area_strt")
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (fill_margin_x, fill_margin_y))
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (fill_margin_x1, fill_margin_y1))
                self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                             "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
        # --防焊曝光点切铜要等到加完防焊对位pad之后
        
        if flow_content == "一次铜":            
            self.cut_mask_area()
    
    def cut_mask_area(self):
        """金手指板 重新切铜 20230218 by lyh
        参考http://192.168.2.120:82/zentao/story-view-5150.html"""
        sel_jsz = self.parm.sel_jsz
        g_direction = self.parm.g_direction
        
        out_signal_array = self.parm.out_signal_array
        add_hj_panel = self.parm.add_hj_panel
        board_thick = self.parm.board_thick
        job_signal_numbers = self.parm.job_signal_numbers        
        
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        if job_signal_numbers <= 2:
            rout_x = self.parm.profile_xmax
            rout_y = self.parm.profile_ymax        
        
        job = gClasses.Job(self.JOB)
        stepname = "panel"
        step = gClasses.Step(job, stepname)
        step.open()
        step.COM("units,type=mm")
        
        matrixInfo = job.matrix.getInfo()
        solderMaskLayers = [lay for i, lay in enumerate(matrixInfo["gROWname"])
    
                            if matrixInfo["gROWcontext"][i] == "board"
    
                            and matrixInfo["gROWlayer_type"][i] == "solder_mask"]        
        
        lb_x = (profile_xmax - rout_x) * 0.5
        lb_y = (profile_ymax - rout_y) * 0.5        
        step.clearAll()
        step.removeLayer("surface_tmp")
        step.createLayer("surface_tmp")
        step.affect("surface_tmp")
        step.reset_fill_params()
        step.addRectangle(profile_xmin+lb_x, profile_ymin+lb_y, profile_xmax-lb_x, profile_ymax-lb_y)            
        step.addRectangle(profile_xmin+lb_x+8, profile_ymin+lb_y+8,
                          profile_xmax-lb_x-8, profile_ymax-lb_y-8, polarity='negative')
        
        step.contourize()
        step.addAttr(".pattern_fill",valType="", change_attr="yes")
        
        if sel_jsz == '是' and board_thick > 0.5:
            step.clearAll()
            step.COM('affected_filter,filter=(type=solder_mask&context=board&side=top|bottom)')
            #step.addRectangle(sr_xmin-4.1, sr_ymin-4.1, sr_xmax+4.1, sr_ymax+4.1, polarity='negative')
            
            step.COM("clip_area_strt")
            step.COM("clip_area_xy,x=%s,y=%s" % (sr_xmin-4.1, sr_ymin-4.1))
            step.COM("clip_area_xy,x=%s,y=%s" % (sr_xmax+4.1, sr_ymax+4.1))
            step.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                         "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
            
            if (g_direction == "X方向" or g_direction == "XY均有") and profile_ymax <= 650: 
                step.COM("clip_area_strt")
                step.COM("clip_area_xy,x=%s,y=%s" % (sr_xmin-4.1, sr_ymin-4.1))
                step.COM("clip_area_xy,x=%s,y=%s" % (sr_xmax+4.1, profile_ymax-lb_y-10))
                step.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                             "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
            else:
                step.COM("clip_area_strt")
                step.COM("clip_area_xy,x=%s,y=%s" % (sr_xmin-4.1, sr_ymin-4.1))
                step.COM("clip_area_xy,x=%s,y=%s" % (profile_xmax-lb_x-10, sr_ymax+4.1))
                step.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                             "inout=inside,contour_cut=yes,margin=0,feat_types=surface")                
                    
            step.clearAll()
            
        #化金 或选化 且板厚小于等于0.5mm
        if add_hj_panel == "是" and board_thick <= 0.5:
            for layer in solderMaskLayers:
                step.copyLayer(job.name, stepname, "surface_tmp", layer)
                
        step.clearAll()
        step.removeLayer("surface_tmp")

class MD_copper(object):
    """
    档点铺铜
    """

    def __init__(self, frozen_json=None, opt_side=None, priority=0):
        self.parm = frozen_json
        self.opt_side = opt_side
        self.GEN = genCOM.GEN_COM()
        self.JOB = os.environ.get('JOB', None)

    def put_copper(self):
        """
        依据fill_array指定的铺铜方式进行铺铜
        :return:
        :rtype:
        """
        sel_jsz = self.parm.sel_jsz
        g_direction = self.parm.g_direction
        
        put_copper_md = self.parm.put_copper_md
        job_signal_numbers = self.parm.job_signal_numbers
        add_three_plant = self.parm.add_three_plant
        flow_content = self.parm.flow_content
        gold_finger = self.JOB[7]
        pn_seven = self.JOB[6]
        profile_xmin = self.parm.profile_xmin
        profile_xmax = self.parm.profile_xmax
        profile_ymin = self.parm.profile_ymin
        profile_ymax = self.parm.profile_ymax
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        judge_phone_subplate = self.parm.judge_phone_subplate
        if job_signal_numbers == 2:
            rout_x = profile_xmax
            rout_y = profile_ymax
        add_hj_panel = self.parm.add_hj_panel
        board_thick = self.parm.board_thick
        self.GEN.CLEAR_LAYER()
        self.GEN.COM('affected_layer,name=md1,mode=single,affected=yes')
        self.GEN.COM('affected_layer,name=md2,mode=single,affected=yes')
        # if put_copper_md == "yes": # === HDI 暂不使用此项
        if add_three_plant == "yes":
            self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface")
            if gold_finger in ['y', 'h', 'l', 's', 'r']:
                # --铺出profile 4mm,距内profile 1.5mm
                self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-4,step_margin_y=-4,step_max_dist_x=2540,"
                             "step_max_dist_y=2540,sr_margin_x=1.5,sr_margin_y=1.5,sr_max_dist_x=0,sr_max_dist_y=0,"
                             "nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,"
                             "attributes=no")
                self.GEN.COM("sel_resize,size=-1000,corner_ctl=no")
                self.GEN.COM("sel_resize,size=1000,corner_ctl=no")
            else:
                # --铺出profile 4mm,距内profile 1.0mm
                self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-4,step_margin_y=-4,step_max_dist_x=2540,"
                             "step_max_dist_y=2540,sr_margin_x=1,sr_margin_y=1,sr_max_dist_x=0,sr_max_dist_y=0,"
                             "nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,"
                             "attributes=no")
                self.GEN.COM("sel_resize,size=-381,corner_ctl=no")
                self.GEN.COM("sel_resize,size=381,corner_ctl=no")
        else:
            self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface")
            if gold_finger in ['y', 'h', 'l', 's', 'r']:
                # --铺出profile 4mm,距内profile 1.5mm
                self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-4,step_margin_y=-4,step_max_dist_x=2540,"
                             "step_max_dist_y=2540,sr_margin_x=1.5,sr_margin_y=1.5,sr_max_dist_x=0,sr_max_dist_y=0,"
                             "nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,"
                             "attributes=no")
                self.GEN.COM("sel_resize,size=-1000,corner_ctl=no")
                self.GEN.COM("sel_resize,size=1000,corner_ctl=no")
            else:
                if pn_seven != 'g':
                    # --铺出profile 4mm,距内profile 0.508mm
                    self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-4,step_margin_y=-4,step_max_dist_x=2540,"
                                 "step_max_dist_y=2540,sr_margin_x=0.508,sr_margin_y=0.508,sr_max_dist_x=0,sr_max_dist_y=0,"
                                 "nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,"
                                 "attributes=no")
                    self.GEN.COM("sel_resize,size=-381,corner_ctl=no")
                    self.GEN.COM("sel_resize,size=381,corner_ctl=no")
                    
        # --20200831李家兴依据story-view-1866添加，化金板以角线中心点clip板内
        sm_conner_ymax = sr_ymax + 1
        sm_conner_xmax = sr_xmax + 1
        sm_conner_ymin = sr_ymin - 1
        sm_conner_xmin = sr_xmin - 1
        if add_hj_panel == '是':
            self.GEN.COM("clip_area_strt");
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (sm_conner_xmin, sm_conner_ymin))
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (sm_conner_xmax, sm_conner_ymax));
            self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                         "inout=inside,contour_cut=yes,margin=0,feat_types=surface");

        # 20190917 HDI一厂要求，工艺叶龙文，CAM薛岩弟，负片流程挡墨板边不盖油，以下更改铺铜距离成型5mm Song
        # 20190918 改成距成型2mm
        if pn_seven == 'g':
            self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-8,step_margin_y=-8,step_max_dist_x=2540,"
                         "step_max_dist_y=2540,sr_margin_x=2,sr_margin_y=2,sr_max_dist_x=0,sr_max_dist_y=0,"
                         "nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,"
                         "attributes=no")

            # 5mm梁涛提出要求
            # dine the area which clip.
            # 20190917 HDI一厂要求，挡墨板边不盖油，不盖油距离成型5mm，以下屏蔽切铜
            # 20191023 HDI一厂要求，二次铜正片板边挡墨距离成型10mm，以下启用切铜10mm
            # V2.09 183手机副板不切铜
            # if flow_content == '二次铜' or judge_phone_subplate:
            if flow_content == '二次铜':
                # 薛岩弟需求 http://192.168.2.120:82/zentao/story-view-513.html开窗距离挡墨10mm
                rect_x1 = (profile_xmax - rout_x) * 0.5 + 10
                rect_y1 = (profile_ymax - rout_y) * 0.5 + 10
                rect_x2 = (profile_xmax - rout_x) * 0.5 + rout_x - 10
                rect_y2 = (profile_ymax - rout_y) * 0.5 + rout_y - 10

                self.GEN.COM("clip_area_strt")
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (rect_x1, rect_y1))
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (rect_x2, rect_y2))
                self.GEN.COM(
                    "clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                    "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text");

        clip_size = 0            
        #周涌通知 手机副板有osp+化金的 挡点全部开窗 20221125 by lyh
        if judge_phone_subplate:
            if (self.GEN.LAYER_EXISTS("sgt-c", self.JOB, "panel") == "yes" or \
                self.GEN.LAYER_EXISTS("sgt-s", self.JOB, "panel") == "yes"):
                clip_size = 0
            else:
                # 周涌通知 手机副板化金板改成8mm留铜 20221125 by lyh       
                clip_size = 10
                
        # --20201015李家兴依据story-view-2035添加，小于0.4mm板厚，档点距锣边8mm留铜
        if board_thick <= 0.4:
            clip_size = 8                

        if clip_size:
            cut_x1 = profile_xmin + (profile_xmax - rout_x) * 0.5 + clip_size
            cut_y1 = profile_ymin + (profile_ymax - rout_y) * 0.5 + clip_size
            cut_x2 = profile_xmax - (profile_xmax - rout_x) * 0.5 - clip_size
            cut_y2 = profile_ymax - (profile_ymax - rout_y) * 0.5 - clip_size
            self.GEN.COM("clip_area_strt")
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_x1, cut_y1))
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_x2, cut_y2))
            self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                         "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
            
        
        #翟鸣通知 金手指板 档点也开大了，跟开窗一样大就行了 20230324 by lyh
        lb_x = (profile_xmax - rout_x) * 0.5
        lb_y = (profile_ymax - rout_y) * 0.5          
        if sel_jsz == '是' and board_thick > 0.5:            
            self.GEN.COM("clip_area_strt")
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (sr_xmin-4.1, sr_ymin-4.1))
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (sr_xmax+4.1, sr_ymax+4.1))
            self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                         "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
            
            if (g_direction == "X方向" or g_direction == "XY均有") and profile_ymax <= 650: 
                self.GEN.COM("clip_area_strt")
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (sr_xmin-4.1, sr_ymin-4.1))
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (sr_xmax+4.1, profile_ymax-lb_y-10))
                self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                             "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
            else:
                self.GEN.COM("clip_area_strt")
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (sr_xmin-4.1, sr_ymin-4.1))
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (profile_xmax-lb_x-10, sr_ymax+4.1))
                self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                             "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
                
        #翟鸣通知 小于0.5mm的化金板的档点也帮忙改成跟防焊一样 20230327 by lyh
        if add_hj_panel == "是" and board_thick <= 0.5:
            self.GEN.COM("clip_area_strt")
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (profile_xmin+lb_x+8, profile_ymin+lb_y+8))
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (profile_xmax-lb_x-8, profile_ymax-lb_y-8))
            self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                         "inout=inside,contour_cut=yes,margin=0,feat_types=surface")            
        
        self.GEN.CLEAR_LAYER()


class OUT_copper(object):
    """
    外层板边铺铜
    """

    def __init__(self, frozen_json=None, priority=0):
        self.parm = frozen_json
        self.GEN = genCOM.GEN_COM()
        self.JOB = os.environ.get('JOB', None)

    def put_dummy(self):
        """
        绕内profile铺dummy,已经没有实际用处,story-view-1679要求为了省油墨,sr范围内不铺铜
        :return:
        :rtype:
        """
        out_signal_array = self.parm.out_signal_array
        flow_content = self.parm.flow_content
        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        # region
        # --------------------------------------------------------------------------------------------------------------
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('l1', 'yes')
        self.GEN.FILTER_RESET()
        tPnlDotPadLayer = 'pnl-dot++'
        tInnSrSurLayer = 'sr-sur++'
        tmpSigLayer = '-tmp-pnl++'
        # --panel范围内铺dummy pad
        self.GEN.COM("fill_params,type=pattern,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,"
                     "use_arcs=yes,symbol=s1000,dx=2,dy=2,std_angle=45,std_line_width=254,std_step_dist=1270,"
                     "std_indent=odd,break_partial=yes,cut_prims=no,outline_draw=no,outline_width=0,outline_invert=no")
        self.GEN.COM("sr_fill,polarity=positive,step_margin_x=0,step_margin_y=0,step_max_dist_x=2540,"
                     "step_max_dist_y=2540,sr_margin_x=2,sr_margin_y=2,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                     "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        if flow_content == '一次铜':
            # --20200909李家兴依据story-view-1679沿内profile删除外层dummy pad;sr_xmin,sr_ymin->sr_xmax,sr_ymax
            clip_cu_x1 = sr_xmin - 2.5
            clip_cu_x2 = sr_xmax + 2.5
            clip_cu_y1 = sr_ymin - 2.5
            clip_cu_y2 = sr_ymax + 2.5
            self.GEN.COM("filter_area_strt")
            self.GEN.COM("filter_area_xy,x=%s,y=%s" % (clip_cu_x1, clip_cu_y1))
            self.GEN.COM("filter_area_xy,x=%s,y=%s" % (clip_cu_x2, clip_cu_y2))
            self.GEN.COM("filter_area_end,layer=,filter_name=popup,operation=select,area_type=rectangle,"
                         "inside_area=yes,intersect_area=no")
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                # --主要用来删除品字形排版,sr范围内的dummy
                # self.GEN.CLEAR_FEAT()
                self.GEN.COM('sel_delete')
        # --copy到dummy pad层别,只copy顶层的就好了,别重复
        self.GEN.SEL_COPY(tPnlDotPadLayer)
        # --去掉板边不要的铜块.保留距内profile 2 mm的dummy
        get_sr_xmin = sr_xmin + 2
        get_sr_ymin = sr_ymin + 2
        get_sr_xmax = sr_xmax - 2
        get_sr_ymax = sr_ymax - 2
        self.GEN.COM("filter_area_strt")
        self.GEN.COM("filter_area_xy,x=%s,y=%s" % (get_sr_xmin, get_sr_ymin))
        self.GEN.COM("filter_area_xy,x=%s,y=%s" % (get_sr_xmax, get_sr_ymax))
        self.GEN.COM("filter_area_end,layer=,filter_name=popup,operation=select,area_type=rectangle,inside_area=yes,"
                     "intersect_area=no,lines_only=no,ovals_only=no,min_len=0,max_len=0,min_angle=0,max_angle=0")
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            # --注意反选
            self.GEN.COM('sel_reverse')
            self.GEN.COM('sel_delete')
        else:
            self.GEN.COM('sel_delete')
        # --填充子排版
        self.GEN.DELETE_LAYER('create_copper')
        self.GEN.DELETE_LAYER('sr_area_dummy')
        self.GEN.CREATE_LAYER('create_copper')
        self.GEN.DELETE_LAYER('flat_copper')
        step_list = ['edit', 'edit1', 'edit+flip', 'edit1+flip', 'set', 'set1', 'zk']
        for step in step_list:
            self.GEN.OPEN_STEP(step, job=self.JOB)
            self.GEN.CLEAR_LAYER()
            self.GEN.COM('units,type=mm')
            self.GEN.AFFECTED_LAYER('create_copper', 'yes')
            self.GEN.COM('fill_params,type=solid,origin_type=datum,solid_type=surface')
            self.GEN.COM("sr_fill,polarity=positive,step_margin_x=0,step_margin_y=0,step_max_dist_x=2540,"
                         "step_max_dist_y=2540,sr_margin_x=0,sr_margin_y=0,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                         "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
            self.GEN.CLEAR_LAYER()
            self.GEN.COM('editor_page_close')
        # --重新打开panel
        self.GEN.OPEN_STEP('panel', job=self.JOB)
        self.GEN.CLEAR_LAYER()
        self.GEN.COM('units,type=mm')
        self.GEN.AFFECTED_LAYER('create_copper', 'yes')
        self.GEN.COM("flatten_layer,source_layer=create_copper,target_layer=flat_copper")
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('flat_copper', 'yes')
        # --前面flatten出来的层别加大27mm,单边13.5mm
        self.GEN.COM("sel_resize,size=27000,corner_ctl=no")
        self.GEN.COM("sel_resize,size=8000,corner_ctl=no")
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('l1', 'yes')
        self.GEN.SEL_REF_FEAT('flat_copper', 'touch')
        # --删除距离内profile 17.5mm之外的dummy
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM('sel_reverse')
            if self.GEN.GET_SELECT_COUNT() > 0:
                self.GEN.SEL_DELETE()
        # --resize -15000保证距内profile 10mm
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('flat_copper', 'yes')
        self.GEN.COM("sel_resize,size=-15000,corner_ctl=no")

        # --距profile 10mm以外的move到chris-create-00layer,之后仍会保持dummy形态
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('l1', 'yes')
        self.GEN.SEL_REF_FEAT('flat_copper', 'touch')
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM('sel_reverse')
            if self.GEN.GET_SELECT_COUNT() > 0:
                self.GEN.SEL_MOVE('sr_area_dummy')
            # --距profile 10mm以内的转成surface形态
            self.GEN.COM("sel_resize,size=1500,corner_ctl=no")
            self.GEN.COM(
                "sel_contourize,accuracy=6.35,break_to_islands=yes,clean_hole_size=76.2,clean_hole_mode=x_and_y")
            self.GEN.COM("sel_resize,size=-1500,corner_ctl=no")
            self.GEN.SEL_COPY(tInnSrSurLayer)
            self.GEN.COM("affected_layer,mode=all,affected=no")
            # --tPnlDotPadLayer删除已经转成surface的部分
            self.GEN.AFFECTED_LAYER(tPnlDotPadLayer, 'yes')
            self.GEN.SEL_REF_FEAT('l1', 'touch')
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_DELETE()
            self.GEN.AFFECTED_LAYER(tPnlDotPadLayer, 'no')
            if self.GEN.LAYER_EXISTS('sr_area_dummy', job=self.JOB, step='panel') == 'yes':
                self.GEN.CLEAR_LAYER()
                self.GEN.AFFECTED_LAYER('sr_area_dummy', 'yes')
                self.GEN.SEL_MOVE('l1')
                self.GEN.DELETE_LAYER('sr_area_dummy')
        # --将c面的dummy复制到s面
        self.GEN.COPY_LAYER(self.JOB, 'panel', 'l1', out_signal_array[1])
        self.GEN.DELETE_LAYER(tPnlDotPadLayer)
        self.GEN.DELETE_LAYER('flat_copper')
        self.GEN.DELETE_LAYER('create_copper')
        # endregion

    def put_copper(self):
        """
        铺铜皮
        :return:
        :rtype:
        """
        # --开始铺铜皮
        put_copper_out = self.parm.put_copper_out
        if put_copper_out == 'no':
            # --不铺铜直接返回
            # pass
            return
        job_signal_numbers = self.parm.job_signal_numbers
        out_signal_array = self.parm.out_signal_array
        flow_content = self.parm.flow_content
        judge_phone_subplate = self.parm.judge_phone_subplate

        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        profile_xmin = self.parm.profile_xmin
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        if job_signal_numbers <= 2:
            rout_x = self.parm.profile_xmax
            rout_y = self.parm.profile_ymax
        fill_margin_x = sr_xmin - 2.5
        fill_margin_y = sr_ymin - 2.5
        fill_margin_x1 = sr_xmax + 2.5
        fill_margin_y1 = sr_ymax + 2.5
        sel_jsz = self.parm.sel_jsz
        add_first_plant = self.parm.add_first_plant
        hdi_num = self.parm.hdi_num
        board_thick = self.parm.board_thick
        # --确认是否铺dummy
        self.put_dummy()
        # region
        # --------------------------------------------------------------------------------------------------------------
        self.GEN.CLEAR_LAYER()
        self.GEN.DELETE_LAYER('fill_copper')
        self.GEN.CREATE_LAYER('fill_copper')
        self.GEN.AFFECTED_LAYER('fill_copper', 'yes')
        # if  job_signal_numbers == 4:
        #     self.GEN.COM('fill_params,type=solid,origin_type=datum,solid_type=surface')
        #     # --铺出profile 8mm
        #     self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-8,step_margin_y=-8,step_max_dist_x=2540,"
        #                  "step_max_dist_y=2540,sr_margin_x=0,sr_margin_y=0,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
        #                  "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        #     if L_margin >= 7:
        #         cut_corner_x1 = sr_xmin - 2.5
        #         cut_corner_x2 = sr_xmax + 2.5
        #     else:
        #         cut_corner_x1 = sr_xmin - 1.5
        #         cut_corner_x2 = sr_xmax + 1.5
        #     if U_margin >= 7:
        #         cut_corner_y1 = sr_ymin - 2.5
        #         cut_corner_y2 = sr_ymax + 2.5
        #     else:
        #         cut_corner_y1 = sr_ymin - 1.5
        #         cut_corner_y2 = sr_ymax + 1.5
        #     self.GEN.COM("clip_area_strt")
        #     self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_corner_x1,cut_corner_y1))
        #     self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_corner_x2,cut_corner_y2))
        #     self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
        #                  "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
        # else:
        #     self.GEN.COM('fill_params,type=solid,origin_type=datum,solid_type=surface')
        #     # --胜宏铺铜，profile向外8mm,距内profile2.5mm
        #     self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-8,step_margin_y=-8,step_max_dist_x=2540,"
        #                  "step_max_dist_y=2540,sr_margin_x=2.5,sr_margin_y=2.5,sr_max_dist_x=0,sr_max_dist_y=0,"
        #                  "nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        self.GEN.COM('fill_params,type=solid,origin_type=datum,solid_type=surface')
        # --胜宏铺铜，profile向外8mm,距内profile2.5mm
        self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-8,step_margin_y=-8,step_max_dist_x=2540,"
                     "step_max_dist_y=2540,sr_margin_x=2.5,sr_margin_y=2.5,sr_max_dist_x=0,sr_max_dist_y=0,"
                     "nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        # if job_signal_numbers != 4:
        #     # --切铜，距sr_xmin 2.5mm,注意样品板sr_xmin是修正过的
        #     self.GEN.COM("clip_area_strt")
        #     self.GEN.COM("clip_area_xy,x=%s,y=%s" % (fill_margin_x, fill_margin_y))
        #     self.GEN.COM("clip_area_xy,x=%s,y=%s" % (fill_margin_x1, fill_margin_y1))
        #     self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
        #                  "inout=inside,contour_cut=yes,margin=0,feat_types=surface")

        # --切铜，距sr_xmin 2.5mm,注意样品板sr_xmin是修正过的
        self.GEN.COM("clip_area_strt")
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (fill_margin_x, fill_margin_y))
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (fill_margin_x1, fill_margin_y1))
        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                     "inout=inside,contour_cut=yes,margin=0,feat_types=surface")

        if sel_jsz == '否':
            if add_first_plant == 'no' and board_thick > 0.4 and not judge_phone_subplate:
                # --二三四五六厂一次铜板边
                top_after_margin = self.parm.top_after_margin
                left_after_margin = self.parm.left_after_margin
                # sh_top_borad = profile_ymax - (profile_ymax - rout_y) * 0.5 - sr_ymax
                # sh_bot_borad = sr_ymin - (profile_ymax - rout_y) * 0.5
                # if sh_top_borad > 25:
                #     # --为了省铜,短边top留边>25要切掉中间部分
                #     cut_sh_x1 = sr_xmin - 2.5
                #     cut_sh_y1 = sr_ymax + 10
                #     cut_sh_x2 = sr_xmax + 2.5
                #     cut_sh_y2 = profile_ymax - (profile_ymax - rout_y) * 0.5 - 10
                #     self.GEN.COM("clip_area_strt")
                #     self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x1, cut_sh_y1))
                #     self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x2, cut_sh_y2))
                #     self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                #                  "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
                # if sh_bot_borad > 25:
                #     # --为了省铜,短边top留边>25要切掉中间部分
                #     cut_sh_x1 = sr_xmin - 2.5
                #     cut_sh_y1 = (profile_ymax - rout_y) * 0.5 + 10
                #     cut_sh_x2 = sr_xmax + 2.5
                #     cut_sh_y2 = sr_ymin - 10
                #     self.GEN.COM("clip_area_strt")
                #     self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x1, cut_sh_y1))
                #     self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x2, cut_sh_y2))
                #     self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                #                  "inout=inside,contour_cut=yes,margin=0,feat_types=surface")

                if top_after_margin > 20.5 or left_after_margin > 20.5:
                    if top_after_margin > 20.5:
                        if left_after_margin > 20.5:
                            cut_copper_x1 = profile_xmin + (profile_xmax - rout_x) * 0.5 + 10
                            cut_copper_x2 = profile_xmax - (profile_xmax - rout_x) * 0.5 - 10
                        else:
                            cut_copper_x1 = sr_xmin
                            cut_copper_x2 = sr_xmax
                        cut_copper_y1 = sr_ymax + 10.5
                        cut_copper_y2 = profile_ymax - (profile_ymax - rout_y) * 0.5 - 10
                        self.GEN.COM("clip_area_strt")
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x1, cut_copper_y1))
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x2, cut_copper_y2))
                        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                                     "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
                        cut_copper_y1 = sr_ymin - 10.5
                        cut_copper_y2 = profile_ymin + (profile_ymax - rout_y) * 0.5 + 10
                        self.GEN.COM("clip_area_strt")
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x1, cut_copper_y1))
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x2, cut_copper_y2))
                        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                                     "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")

                    if left_after_margin > 20.5:
                        if top_after_margin > 20.5:
                            cut_copper_y1 = profile_ymin + (profile_ymax - rout_y) * 0.5 + 10
                            cut_copper_y2 = profile_ymax - (profile_ymax - rout_y) * 0.5 - 10
                        else:
                            cut_copper_y1 = sr_ymin
                            cut_copper_y2 = sr_ymax
                        cut_copper_x1 = sr_xmin - 10.5
                        cut_copper_x2 = profile_xmin + (profile_xmax - rout_x) * 0.5 + 10
                        self.GEN.COM("clip_area_strt")
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x1, cut_copper_y1))
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x2, cut_copper_y2))
                        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                                     "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
                        cut_copper_x1 = sr_xmax + 10.5
                        cut_copper_x2 = profile_xmax - (profile_xmax - rout_x) * 0.5 - 10
                        self.GEN.COM("clip_area_strt")
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x1, cut_copper_y1))
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x2, cut_copper_y2))
                        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                                     "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
                if flow_content == '一次铜':
                    # --若为二厂一次铜,整个短边top切掉只留10mm
                    gold_finger = self.JOB[6]
                    cut_sh_x1 = -20
                    cut_sh_y1 = sr_ymin - 10
                    cut_sh_x2 = profile_xmax + 20
                    cut_sh_y2 = profile_ymin - 20
                    self.GEN.COM("clip_area_strt")
                    self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x1, cut_sh_y1))
                    self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x2, cut_sh_y2))
                    self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                                 "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
                    # --若为二厂一次铜,整个短边bot切掉只留10mm
                    cut_sh_x1 = -20
                    cut_sh_y1 = sr_ymax + 10
                    cut_sh_x2 = profile_xmax + 20
                    cut_sh_y2 = profile_ymax + 20
                    self.GEN.COM("clip_area_strt")
                    self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x1, cut_sh_y1))
                    self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x2, cut_sh_y2))
                    self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                                 "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
                    # --2017-06-28(梁涛发邮件要求由原来的5mm改为8mm)
                    # --第七码是e的为化金+碳油流程,2021.2.17刘文东要求添加
                    if gold_finger in ['g', 'o', 'e']:
                        sub_value = rout_x
                        if job_signal_numbers == 2:
                            sub_value = profile_xmax
                        # --切长边左侧,保证距最后一次锣边0.5mm
                        cut_sh_x1 = -20
                        cut_sh_y1 = -20
                        cut_sh_x2 = (profile_xmax - sub_value) * 0.5 + 0.5
                        cut_sh_y2 = profile_ymax + 20
                        self.GEN.COM("clip_area_strt")
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x1, cut_sh_y1))
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x2, cut_sh_y2))
                        self.GEN.COM(
                            "clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                            "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
                        # --切长边右侧,保证距最后一次锣边0.5mm
                        cut_sh_x1 = profile_xmax - (profile_xmax - sub_value) * 0.5 - 0.5
                        cut_sh_y1 = -20
                        cut_sh_x2 = profile_xmax + 20
                        cut_sh_y2 = profile_ymax + 20
                        self.GEN.COM("clip_area_strt")
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x1, cut_sh_y1))
                        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_sh_x2, cut_sh_y2))
                        self.GEN.COM(
                            "clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                            "inout=inside,contour_cut=yes,margin=0,feat_types=surface")
            elif board_thick <= 0.4 or  judge_phone_subplate:
                # ===V1.09  释放应力切铜线 shvl = shave_line
                shvl_x1 = -8
                shvl_x2 = sr_xmin
                shvl_x3 = sr_xmin + (sr_xmax - sr_xmin) * 0.25
                shvl_x4 = sr_xmin + (sr_xmax - sr_xmin) * 0.5
                shvl_x5 = sr_xmin + (sr_xmax - sr_xmin) * 0.75
                shvl_x6 = sr_xmax
                shvl_x7 = profile_xmax + 8

                shvl_y1 = -8
                shvl_y2 = sr_ymin
                shvl_y3 = sr_ymin + (sr_ymax - sr_ymin) * 0.25
                shvl_y4 = sr_ymin + (sr_ymax - sr_ymin) * 0.5
                shvl_y5 = sr_ymin + (sr_ymax - sr_ymin) * 0.75
                shvl_y6 = sr_ymax
                shvl_y7 = profile_ymax + 8
                # === 左侧5根线,右侧5根线，下面3根线，上面3根线 ===
                cor_list = [(shvl_x1, shvl_y1, shvl_x2, shvl_y2),
                            (shvl_x1, shvl_y3, shvl_x2, shvl_y3),
                            (shvl_x1, shvl_y4, shvl_x2, shvl_y4),
                            (shvl_x1, shvl_y5, shvl_x2, shvl_y5),
                            (shvl_x1, shvl_y7, shvl_x2, shvl_y6),
                            (shvl_x7, shvl_y1, shvl_x6, shvl_y2),
                            (shvl_x7, shvl_y3, shvl_x6, shvl_y3),
                            (shvl_x7, shvl_y4, shvl_x6, shvl_y4),
                            (shvl_x7, shvl_y5, shvl_x6, shvl_y5),
                            (shvl_x7, shvl_y7, shvl_x6, shvl_y6),
                            (shvl_x3, shvl_y1, shvl_x3, shvl_y2),
                            (shvl_x4, shvl_y1, shvl_x4, shvl_y2),
                            (shvl_x5, shvl_y1, shvl_x5, shvl_y2),
                            (shvl_x3, shvl_y7, shvl_x3, shvl_y6),
                            (shvl_x4, shvl_y7, shvl_x4, shvl_y6),
                            (shvl_x5, shvl_y7, shvl_x5, shvl_y6),
                            ]
                for (xs, ys, xe, ye) in cor_list:
                    self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s3000,polarity=negative,"
                                 "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                                 % (xs, ys, xe, ye))
                self.GEN.SEL_CONTOURIZE()

        # # --依据fix_ganmo_size再次切铜
        # top_after_margin = self.parm.top_after_margin
        # left_after_margin = self.parm.left_after_margin
        # # if (top_after_margin > 20.5 or left_after_margin > 20.5) and hdi_num < 1:
        # if top_after_margin > 20.5 or left_after_margin > 20.5:
        #     if top_after_margin > 20.5:
        #         if left_after_margin > 20.5:
        #             cut_copper_x1 = profile_xmin + (profile_xmax - rout_x) * 0.5 + 10
        #             cut_copper_x2 = profile_xmax - (profile_xmax - rout_x) * 0.5 - 10
        #         else:
        #             cut_copper_x1 = sr_xmin
        #             cut_copper_x2 = sr_xmax
        #         cut_copper_y1 = sr_ymax + 10.5
        #         cut_copper_y2 = profile_ymax - (profile_ymax - rout_y) * 0.5 - 10
        #         self.GEN.COM("clip_area_strt")
        #         self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x1, cut_copper_y1))
        #         self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x2, cut_copper_y2))
        #         self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
        #                      "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
        #         cut_copper_y1 = sr_ymin - 10.5
        #         cut_copper_y2 = profile_ymin + (profile_ymax - rout_y) * 0.5 + 10
        #         self.GEN.COM("clip_area_strt")
        #         self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x1, cut_copper_y1))
        #         self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x2, cut_copper_y2))
        #         self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
        #                      "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
        #
        #     if left_after_margin > 20.5:
        #         if top_after_margin > 20.5:
        #             cut_copper_y1 = profile_ymin + (profile_ymax - rout_y) * 0.5 + 10
        #             cut_copper_y2 = profile_ymax - (profile_ymax - rout_y) * 0.5 - 10
        #         else:
        #             cut_copper_y1 = sr_ymin
        #             cut_copper_y2 = sr_ymax
        #         cut_copper_x1 = sr_xmin - 10.5
        #         cut_copper_x2 = profile_xmin + (profile_xmax - rout_x) * 0.5 + 10
        #         self.GEN.COM("clip_area_strt")
        #         self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x1, cut_copper_y1))
        #         self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x2, cut_copper_y2))
        #         self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
        #                      "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
        #         cut_copper_x1 = sr_xmax + 10.5
        #         cut_copper_x2 = profile_xmax - (profile_xmax - rout_x) * 0.5 - 10
        #         self.GEN.COM("clip_area_strt")
        #         self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x1, cut_copper_y1))
        #         self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x2, cut_copper_y2))
        #         self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
        #                      "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
        # --依据add_ccd_symbol添加s12000线
        pn_eight = self.JOB[7]
        if pn_eight in ['y', 'r', 'l']:
            add_line_x1 = profile_xmin + 8.8
            add_line_x2 = sr_xmin - 8.8
            add_line_x3 = profile_xmax * 0.5 + 8.8
            add_line_x4 = sr_xmax + 8.8
            add_line_x5 = profile_xmax - 8.8

            add_line_x6 = sr_xmin + 35
            add_line_x7 = sr_xmax - 35

            add_line_y1 = profile_ymin + 8.8
            add_line_y2 = sr_ymin - 8.8
            add_line_y3 = profile_ymax * 0.5 + 8.8
            add_line_y4 = sr_ymax + 8.8
            add_line_y5 = profile_ymax - 8.8

            add_line_y6 = sr_ymin + 35
            add_line_y7 = sr_ymax - 35
            if sr_xmin >= 24:
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x1, add_line_y3, add_line_x2, add_line_y3))
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x4, add_line_y3, add_line_x5, add_line_y3))
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x1, add_line_y6, add_line_x2, add_line_y6))
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x4, add_line_y6, add_line_x5, add_line_y6))
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x1, add_line_y7, add_line_x2, add_line_y7))
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x4, add_line_y7, add_line_x5, add_line_y7))

            if sr_ymin >= 24:
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x3, add_line_y1, add_line_x3, add_line_y2))
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x3, add_line_y4, add_line_x3, add_line_y5))
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x6, add_line_y1, add_line_x6, add_line_y2))
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x6, add_line_y4, add_line_x6, add_line_y5))
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x7, add_line_y1, add_line_x7, add_line_y2))
                self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s12000,polarity=positive,"
                             "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                             % (add_line_x7, add_line_y4, add_line_x7, add_line_y5))

        # --分别copy到外层
        for layer in out_signal_array:
            self.GEN.SEL_COPY(layer)
        # --删除临时层别
        self.GEN.DELETE_LAYER('fill_copper')
        # endregion
        # --金手指卡板切铜
        # self.vgaChange()
        
        if flow_content == '一次铜':
            self.cut_copper()
        
    def cut_copper(self):
        """金手指板 重新切铜 20230218 by lyh
        参考http://192.168.2.120:82/zentao/story-view-5150.html"""
        sel_jsz = self.parm.sel_jsz
        g_direction = self.parm.g_direction
        
        out_signal_array = self.parm.out_signal_array
        add_hj_panel = self.parm.add_hj_panel
        board_thick = self.parm.board_thick
        job_signal_numbers = self.parm.job_signal_numbers
        
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        if job_signal_numbers <= 2:
            rout_x = self.parm.profile_xmax
            rout_y = self.parm.profile_ymax        
        
        job = gClasses.Job(self.JOB)
        stepname = "panel"
        step = gClasses.Step(job, stepname)
        step.open()
        step.COM("units,type=mm")
        
        step.clearAll()
        step.removeLayer("surface_tmp")
        step.createLayer("surface_tmp")
        step.affect("surface_tmp")
        step.reset_fill_params()
        step.addRectangle(profile_xmin-8, profile_ymin-8, profile_xmax+8, profile_ymax+8)            
        step.addRectangle(sr_xmin-1, sr_ymin-1, sr_xmax+1, sr_ymax+1, polarity='negative')
        step.contourize()
        step.addAttr(".pattern_fill",valType="", change_attr="yes")        
        
        #step.PAUSE("{0} {1} {2}".format(sel_jsz, add_hj_panel, board_thick))
        if sel_jsz == '是' and board_thick > 0.5:
            step.clearAll()
            step.affect("surface_tmp")
            for layer in out_signal_array:
                step.copySel(layer)
                
            for layer in out_signal_array:
                step.clearAll()
                step.affect(layer)
                if (g_direction == "X方向" or g_direction == "XY均有") and profile_ymax <= 650:                    
                    step.addRectangle(profile_xmin-20, profile_ymin-20, sr_xmin-4, profile_ymax+20, polarity='negative')
                    step.addRectangle(sr_xmax+4, profile_ymin-20, profile_xmax+20, profile_ymax+20, polarity='negative')
                    step.addRectangle(profile_xmin-20, profile_ymin-20, profile_xmax+20, sr_ymin-4, polarity='negative')
                else:
                    step.addRectangle(profile_xmin-20, profile_ymin-20, sr_xmin-4, profile_ymax+20, polarity='negative')
                    # step.addRectangle(sr_xmax+4, profile_ymin-20, profile_xmax+20, profile_ymax+20, polarity='negative')                    
                    step.addRectangle(profile_xmin-20, profile_ymin-20, profile_xmax+20, sr_ymin-4, polarity='negative')
                    step.addRectangle(profile_xmin-20, sr_ymax+4, profile_xmax+20, profile_ymax+20, polarity='negative')
                
                step.resetFilter()
                step.filter_set(feat_types='surface')
                step.selectAll()
                if step.featureSelected():
                    step.contourize()
                    
            step.clearAll()
            
        #化金 或选化 且板厚小于等于0.5mm
        if add_hj_panel == "是" and board_thick <= 0.5:
            step.clearAll()
            step.affect("surface_tmp")
            for layer in out_signal_array:
                step.copySel(layer)
            lb_x = (profile_xmax - rout_x) * 0.5
            lb_y = (profile_ymax - rout_y) * 0.5
            for layer in out_signal_array:
                step.clearAll()
                step.affect(layer)
                step.addRectangle(profile_xmin-20, profile_ymin-20, profile_xmin+lb_x+1.5, profile_ymax+20, polarity='negative')
                step.addRectangle(profile_xmax-lb_x-1.5, profile_ymin-20, profile_xmax+20, profile_ymax+20, polarity='negative')
                step.addRectangle(profile_xmin-20, profile_ymin-20, profile_xmax+20, profile_ymin+lb_y+1.5, polarity='negative')
                step.addRectangle(profile_xmin-20, profile_ymax-lb_y-1.5, profile_xmax+20, profile_ymax+20, polarity='negative')
                
                # ===V1.09  释放应力切铜线 shvl = shave_line
                shvl_x1 = -8
                shvl_x2 = sr_xmin
                shvl_x3 = sr_xmin + (sr_xmax - sr_xmin) * 0.25
                shvl_x4 = sr_xmin + (sr_xmax - sr_xmin) * 0.5
                shvl_x5 = sr_xmin + (sr_xmax - sr_xmin) * 0.75
                shvl_x6 = sr_xmax
                shvl_x7 = profile_xmax + 8

                shvl_y1 = -8
                shvl_y2 = sr_ymin
                shvl_y3 = sr_ymin + (sr_ymax - sr_ymin) * 0.25
                shvl_y4 = sr_ymin + (sr_ymax - sr_ymin) * 0.5
                shvl_y5 = sr_ymin + (sr_ymax - sr_ymin) * 0.75
                shvl_y6 = sr_ymax
                shvl_y7 = profile_ymax + 8
                # === 左侧5根线,右侧5根线，下面3根线，上面3根线 ===
                cor_list = [(shvl_x1, shvl_y1, shvl_x2, shvl_y2),
                            (shvl_x1, shvl_y3, shvl_x2, shvl_y3),
                            (shvl_x1, shvl_y4, shvl_x2, shvl_y4),
                            (shvl_x1, shvl_y5, shvl_x2, shvl_y5),
                            (shvl_x1, shvl_y7, shvl_x2, shvl_y6),
                            (shvl_x7, shvl_y1, shvl_x6, shvl_y2),
                            (shvl_x7, shvl_y3, shvl_x6, shvl_y3),
                            (shvl_x7, shvl_y4, shvl_x6, shvl_y4),
                            (shvl_x7, shvl_y5, shvl_x6, shvl_y5),
                            (shvl_x7, shvl_y7, shvl_x6, shvl_y6),
                            (shvl_x3, shvl_y1, shvl_x3, shvl_y2),
                            (shvl_x4, shvl_y1, shvl_x4, shvl_y2),
                            (shvl_x5, shvl_y1, shvl_x5, shvl_y2),
                            (shvl_x3, shvl_y7, shvl_x3, shvl_y6),
                            (shvl_x4, shvl_y7, shvl_x4, shvl_y6),
                            (shvl_x5, shvl_y7, shvl_x5, shvl_y6),
                            ]
                for (xs, ys, xe, ye) in cor_list:
                    step.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s3000,polarity=negative,"
                                 "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                                 % (xs, ys, xe, ye))
                    
                
                step.resetFilter()
                step.filter_set(feat_types='surface')
                step.selectAll()
                step.filter_set(feat_types='line;arc', polarity='negative')
                step.selectAll()
                if step.featureSelected():
                    step.contourize()                                       
                    
        step.clearAll()
        step.removeLayer("surface_tmp")

    def vgaChange(self):
        """
        vgtChange卡板切铜
        :return:
        :rtype:
        """
        # region
        goldName = self.JOB[6:8]
        nameList = ['py', 'pr', 'sy', 'sr', 'gr', 'gy', 'hy', 'pl', 'sl', 'gl']
        if goldName not in nameList:
            return
        job_signal_numbers = self.parm.job_signal_numbers
        out_signal_array = self.parm.out_signal_array
        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        if job_signal_numbers <= 2:
            rout_x = profile_xmax
            rout_y = profile_ymax
        # --右边文字自动对位点坐标
        silk_auto_dwx2 = sr_xmax + 3.5
        goldLine = silk_auto_dwx2 + 1.5 + 1.65
        routXmin = profile_xmin + (profile_xmax - rout_x) * 0.5
        routYmin = profile_ymin + (profile_ymax - rout_y) * 0.5
        routXmax = profile_xmax - (profile_xmax - rout_x) * 0.5
        routYmax = profile_ymax - (profile_ymax - rout_y) * 0.5
        surfaceYmax = profile_ymax + 12
        surfaceXmax = profile_xmax + 12
        surfaceYmin = profile_ymin - 12
        surfaceXmin = profile_xmin - 12
        rout_after_margin_x = sr_xmin - routXmin
        rout_after_margin_y = sr_ymin - routYmin
        # --按20191127邮件需求，如果留边(pnl_rout->setp_profile)小于12mm切铜按2mm，否则且同按3mm。
        if rout_after_margin_x >= 12:
            routXmin += 3
            routXmax -= 3
        else:
            routXmin += 2
            routXmax -= 2
        if rout_after_margin_y >= 12:
            routYmin += 3
            routYmax -= 3
        else:
            routYmin += 2
            routYmax -= 2
        # --建立残留膜屑区域铜皮实体
        self.GEN.DELETE_LAYER('clip_copper')
        self.GEN.CREATE_LAYER('clip_copper')
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('clip_copper', 'yes')
        # --最外围铺铜距profile 12 mm
        self.GEN.COM("add_surf_strt,surf_type=feature")
        self.GEN.COM("add_surf_poly_strt,x=%s,y=%s" % (surfaceXmin, surfaceYmin))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (surfaceXmin, surfaceYmax))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (surfaceXmax, surfaceYmax))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (surfaceXmax, surfaceYmin))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (surfaceXmin, surfaceYmin))
        self.GEN.COM("add_surf_poly_end")
        self.GEN.COM("add_surf_end,attributes=no,polarity=positive")
        # --里面掏空距最后一次成型3mm
        self.GEN.COM("add_surf_strt,surf_type=feature")
        self.GEN.COM("add_surf_poly_strt,x=%s,y=%s" % (routXmin, routYmin))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (routXmin, routYmax))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (routXmax, routYmax))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (routXmax, routYmin))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (routXmin, routYmin))
        self.GEN.COM("add_surf_poly_end")
        self.GEN.COM("add_surf_end,attributes=no,polarity=negative")
        # --长边右侧切铜,距文字自动对位pad
        self.GEN.COM("add_surf_strt,surf_type=feature")
        self.GEN.COM("add_surf_poly_strt,x=%s,y=%s" % (goldLine, surfaceYmin))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (goldLine, surfaceYmax))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (surfaceXmax, surfaceYmax))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (surfaceXmax, surfaceYmin))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (goldLine, surfaceYmin))
        self.GEN.COM("add_surf_poly_end")
        self.GEN.COM("add_surf_end,attributes=no,polarity=positive")
        self.GEN.COM("sel_cont_resize,accuracy=0,break_to_islands=yes,island_size=0,hole_size=0,"
                     "drill_filter=no,corner_ctl=no")
        self.GEN.AFFECTED_LAYER('clip_copper', 'no')
        # --分别copy到外层
        for layer in out_signal_array:
            self.GEN.COPY_LAYER(self.JOB, 'panel', 'clip_copper', layer, mode='append', invert='yes')
            self.GEN.AFFECTED_LAYER(layer, 'yes')
            self.GEN.SEL_CONTOURIZE()
            self.GEN.AFFECTED_LAYER(layer, 'no')
        # endregion

    def add_eagle_mark(self):
        """
        灯板添加鹰眼pad
        :return:
        :rtype:
        """
        out_signal_array = self.parm.out_signal_array
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        srXmax = self.parm.sr_xmax
        srXmin = self.parm.sr_xmin
        srYmax = self.parm.sr_ymax
        srYmin = self.parm.sr_ymin
        left_after_margin = self.parm.left_after_margin
        top_after_margin = self.parm.top_after_margin
        through_drl = self.parm.drl
        # --删除辅助层别
        self.GEN.DELETE_LAYER('song-create-tmp')
        self.GEN.CREATE_LAYER('song-create-tmp')

        but_v_x = srXmin
        but_v_y1 = srYmax + 5
        but_v_y2 = srYmin - 5
        but_h_y = srYmin
        but_h_x1 = srXmax + 5
        but_h_x2 = srXmin - 5

        add_eagle_x = 'yes'
        add_eagle_y = 'yes'
        if left_after_margin < 10.5:
            add_eagle_y = 'no'
        if top_after_margin < 10.5:
            add_eagle_x = 'no'
        x_nums = int((srXmax - srXmin) / 20) + 1
        y_nums = int((srYmax - srYmin) / 20) + 1

        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("units,type=mm")
        self.GEN.COM("affected_layer,name=song-create-tmp,mode=single,affected=yes")

        # 添加四角四个pad #
        self.GEN.COM(
            "add_pad,attributes=no,x=%s,y=%s,symbol=eagle-mark-dot,polarity=positive,angle=0,mirror=no,nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1"
            % (but_h_x2, but_v_y2))
        self.GEN.COM(
            "add_pad,attributes=no,x=%s,y=%s,symbol=eagle-mark-dot,polarity=positive,angle=0,mirror=no,nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1"
            % (but_h_x1, but_v_y2))
        self.GEN.COM(
            "add_pad,attributes=no,x=%s,y=%s,symbol=eagle-mark-dot,polarity=positive,angle=0,mirror=no,nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1"
            % (but_h_x1, but_v_y1))
        self.GEN.COM(
            "add_pad,attributes=no,x=%s,y=%s,symbol=eagle-mark-dot,polarity=positive,angle=0,mirror=no,nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1"
            % (but_h_x2, but_v_y1))

        # 添加X方向的蝴蝶pad铜
        if add_eagle_x == 'yes':
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=eagle-mark-dot,polarity=positive,angle=0,mirror=no,nx=%s,ny=1,dx=20000,dy=0,xscale=1,yscale=1"
                % (but_v_x, but_v_y1, x_nums))
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=eagle-mark-dot,polarity=positive,angle=0,mirror=no,nx=%s,ny=1,dx=20000,dy=0,xscale=1,yscale=1"
                % (but_v_x, but_v_y2, x_nums))
        # 添加Y方向的蝴蝶pad铜
        if add_eagle_y == 'yes':
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=eagle-mark-dot,polarity=positive,angle=0,mirror=no,nx=1,ny=%s,dx=0,dy=20000,xscale=1,yscale=1"
                % (but_h_x1, but_h_y, y_nums))
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=eagle-mark-dot,polarity=positive,angle=0,mirror=no,nx=1,ny=%s,dx=0,dy=20000,xscale=1,yscale=1"
                % (but_h_x2, but_h_y, y_nums))

        # --不能与备靶重叠
        if self.GEN.LAYER_EXISTS('l2', job=self.JOB, step='panel') == 'yes':
            self.GEN.SEL_REF_FEAT('l2', 'touch', f_type='pad', include='sh-ba*')
            # self.GEN.PAUSE("check touch sh-ba")
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_DELETE()
        # --不能与尾孔模块接触
        if self.GEN.LAYER_EXISTS('panel_map', job=self.JOB, step='panel') == 'yes':
            self.GEN.DELETE_LAYER('tail_hole')
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('panel_map', 'yes')
            self.GEN.FILTER_TEXT_ATTR('.string', '*tail_hole', reset=1)
            self.GEN.FILTER_SELECT()
            self.GEN.FILTER_RESET()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_COPY('tail_hole')
            else:
                self.GEN.CREATE_LAYER('tail_hole')
            self.GEN.AFFECTED_LAYER('panel_map', 'yes')
        else:
            self.GEN.CREATE_LAYER('tail_hole')
        # --分别copy到外层,不能与已经添加的外层pad接触
        self.GEN.CLEAR_LAYER()
        self.GEN.COM("affected_layer,name=song-create-tmp,mode=single,affected=yes")
        self.GEN.FILTER_RESET()
        for layer in out_signal_array:
            # TODO 2021.07.20  以下语句在Genesis下报错，暂时仅用一层
            if platform.system() == "Linux":
                self.GEN.SEL_REF_FEAT('%s\;tail_hole\;%s\;inn' % (layer, through_drl), 'disjoint', f_type='pad\;text')
            else:
                self.GEN.SEL_REF_FEAT('%s' % layer, 'disjoint', f_type='pad\;text')
            # self.GEN.PAUSE("check disjoint")
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_COPY(layer)
        self.GEN.COM("affected_layer,name=song-create-tmp,mode=single,affected=no")
        self.GEN.DELETE_LAYER('tail_hole')
        if self.GEN.LAYER_EXISTS('song-tmp', job=self.JOB, step='panel') == 'yes':
            # --分别copy到外层,--添加板内鹰眼pad
            for layer in out_signal_array:
                self.GEN.COPY_LAYER(self.JOB, 'panel', 'song-tmp', layer, mode='append', invert='no')
        # --删除辅助层别
        # self.GEN.DELETE_LAYER ('song-create-tmp')
        # self.GEN.DELETE_LAYER ('song-tmp')

    def add_eagle_cu(self):
        """
        鹰眼pad底铜
        :return:
        :rtype:
        """
        out_signal_array = self.parm.out_signal_array
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        srXmax = self.parm.sr_xmax
        srXmin = self.parm.sr_xmin
        srYmax = self.parm.sr_ymax
        srYmin = self.parm.sr_ymin
        add_hj_panel = self.parm.add_hj_panel

        if add_hj_panel == "否":
            # --删除辅助层别
            self.GEN.DELETE_LAYER('song-create-tmp')
            self.GEN.CREATE_LAYER('song-create-tmp')

            but_v_x = srXmin
            but_v_y1 = srYmax + 4
            but_v_y2 = srYmin - 4
            but_h_y = srYmin
            but_h_x1 = srXmax + 4
            but_h_x2 = srXmin - 4

            add_eagle_x = 'yes'
            add_eagle_y = 'yes'
            if (rout_x - srXmax + srXmin) * 0.5 < 10.5:
                add_eagle_y = 'no'
            if (rout_y - srYmax + srYmin) * 0.5 < 10.5:
                add_eagle_x = 'no'
            x_nums = int((srXmax - srXmin) / 20) + 1
            y_nums = int((srYmax - srYmin) / 20) + 1

            self.GEN.CLEAR_LAYER()
            self.GEN.COM("units,type=mm")
            self.GEN.COM("affected_layer,name=song-create-tmp,mode=single,affected=yes")

            # 添加四角四个pad #
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=s25000,polarity=positive,angle=0,mirror=no,nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1"
                % (but_h_x2, but_v_y2))
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=s25000,polarity=positive,angle=0,mirror=no,nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1"
                % (but_h_x1, but_v_y2))
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=s25000,polarity=positive,angle=0,mirror=no,nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1"
                % (but_h_x1, but_v_y1))
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=s25000,polarity=positive,angle=0,mirror=no,nx=1,ny=1,dx=0,dy=0,xscale=1,yscale=1"
                % (but_h_x2, but_v_y1))

            # 添加X方向的蝴蝶pad铜
            if add_eagle_x == 'yes':
                self.GEN.COM(
                    "add_pad,attributes=no,x=%s,y=%s,symbol=s25000,polarity=positive,angle=0,mirror=no,nx=%s,ny=1,dx=20000,dy=0,xscale=1,yscale=1"
                    % (but_v_x, but_v_y1, x_nums))
                self.GEN.COM(
                    "add_pad,attributes=no,x=%s,y=%s,symbol=s25000,polarity=positive,angle=0,mirror=no,nx=%s,ny=1,dx=20000,dy=0,xscale=1,yscale=1"
                    % (but_v_x, but_v_y2, x_nums))
            # 添加Y方向的蝴蝶pad铜
            if add_eagle_y == 'yes':
                self.GEN.COM(
                    "add_pad,attributes=no,x=%s,y=%s,symbol=s25000,polarity=positive,angle=0,mirror=no,nx=1,ny=%s,dx=0,dy=20000,xscale=1,yscale=1"
                    % (but_h_x1, but_h_y, y_nums))
                self.GEN.COM(
                    "add_pad,attributes=no,x=%s,y=%s,symbol=s25000,polarity=positive,angle=0,mirror=no,nx=1,ny=%s,dx=0,dy=20000,xscale=1,yscale=1"
                    % (but_h_x2, but_h_y, y_nums))
            self.GEN.COM(
                "sel_contourize,accuracy=6.35,break_to_islands=yes,clean_hole_size=5000,clean_hole_mode=x_or_y")
            # --改为4MM的铜宽
            self.GEN.COM("sel_resize,size=-21000,corner_ctl=no")
            # --分别copy到外层
            for layer in out_signal_array:
                self.GEN.COPY_LAYER(self.JOB, 'panel', 'song-create-tmp', layer, mode='append', invert='no')

        if self.GEN.LAYER_EXISTS('eagle-cu', job=self.JOB, step='panel') == 'yes':
            # --分别copy到外层,--添加板内鹰眼pad底铜
            for layer in out_signal_array:
                self.GEN.COPY_LAYER(self.JOB, 'panel', 'eagle-cu', layer, mode='append', invert='no')
        # --删除辅助层别
        self.GEN.DELETE_LAYER('song-create-tmp')
        self.GEN.DELETE_LAYER('eagle-cu')

    def add_eagle_inncu(self):
        """
        品字形拼板鹰眼pad底铜
        :return:
        :rtype:
        """
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        panel_x_size = self.parm.panel_x
        panel_y_size = self.parm.panel_y
        srXmax = self.parm.sr_xmax
        srXmin = self.parm.sr_xmin
        srYmax = self.parm.sr_ymax
        srYmin = self.parm.sr_ymin
        srdxbig, srdybig = 0, 0
        if profile_xmax - srXmax > srXmin - profile_xmin:
            srdxbig = profile_xmax - srXmax
        else:
            srdxbig = srXmin - profile_xmin

        if profile_ymax - srYmax > srYmin - profile_ymin:
            srdybig = profile_ymax - srYmax
        else:
            srdybig = srYmin - profile_ymin

        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("units,type=mm")

        self.GEN.VOF()
        self.GEN.COM("delete_layer,layer=tmp-mich1")

        self.GEN.COM("delete_layer,layer=tmp-song1")
        self.GEN.COM("delete_layer,layer=tmp-song2")
        self.GEN.COM("delete_layer,layer=tmp-song3")
        self.GEN.COM("delete_layer,layer=tmp-song4")
        # 保留的铜皮层
        self.GEN.COM("delete_layer,layer=eagle-cu")
        self.GEN.COM("delete_layer,layer=eagle-cu-pitch")
        self.GEN.COM("delete_layer,layer=eagle-dot-pitch")
        # 保留的symbol层
        self.GEN.COM("delete_layer,layer=song-tmp")
        self.GEN.COM("create_layer,layer=tmp-mich1,context=misc,type=signal,polarity=positive,ins_layer=")

        self.GEN.COM("create_layer,layer=tmp-song1,context=misc,type=signal,polarity=positive,ins_layer=")
        self.GEN.COM("create_layer,layer=tmp-song2,context=misc,type=signal,polarity=positive,ins_layer=")
        self.GEN.COM("create_layer,layer=tmp-song3,context=misc,type=signal,polarity=positive,ins_layer=")
        self.GEN.COM("create_layer,layer=tmp-song4,context=misc,type=signal,polarity=positive,ins_layer=")
        self.GEN.VON()
        self.GEN.COM("snap_mode,mode=off")
        self.GEN.COM("units,type=mm")
        # tmp1 铺整版铜 距离sr 2mm
        self.GEN.COM("display_layer,name=tmp-song1,display=yes,number=1")
        self.GEN.COM("work_layer,name=tmp-song1")
        self.GEN.COM(
            "fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,use_arcs=yes,symbol=,dx=1,dy=1,std_angle=45,std_line_width=254,std_step_dist=1270,std_indent=odd,break_partial=yes,cut_prims=no,outline_draw=no,outline_width=0,outline_invert=no")
        self.GEN.COM(
            "sr_fill,polarity=positive,step_margin_x=3,step_margin_y=3,step_max_dist_x=2540,step_max_dist_y=2540,sr_margin_x=2,sr_margin_y=2,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        # tmp2 按留边铺铜
        self.GEN.COM("display_layer,name=tmp-song2,display=yes,number=1")
        self.GEN.COM("work_layer,name=tmp-song2")
        self.GEN.COM(
            "fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,use_arcs=yes,symbol=,dx=1,dy=1,std_angle=45,std_line_width=254,std_step_dist=1270,std_indent=odd,break_partial=yes,cut_prims=no,outline_draw=no,outline_width=0,outline_invert=no")
        self.GEN.COM(
            "sr_fill,polarity=positive,step_margin_x=3,step_margin_y=3,step_max_dist_x=%s,step_max_dist_y=%s,sr_margin_x=2,sr_margin_y=2,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no"
            % (srdxbig, srdybig))
        # tmp3 围绕sr铺铜 距离sr 4mm 铺铜距离5mm，实际铺铜宽度1mm 间距小于8mm的未铺铜
        self.GEN.COM("display_layer,name=tmp-song3,display=yes,number=1")
        self.GEN.COM("work_layer,name=tmp-song3")
        self.GEN.COM(
            "fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,use_arcs=yes,symbol=,dx=1,dy=1,std_angle=45,std_line_width=254,std_step_dist=1270,std_indent=odd,break_partial=yes,cut_prims=no,outline_draw=no,outline_width=0,outline_invert=no")
        self.GEN.COM(
            "sr_fill,polarity=positive,step_margin_x=3,step_margin_y=3,step_max_dist_x=2540,step_max_dist_y=2540,sr_margin_x=4,sr_margin_y=4,sr_max_dist_x=5,sr_max_dist_y=5,nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")

        # 加大，保证到sr距离2mm
        self.GEN.COM("sel_resize,size=10000,corner_ctl=no")
        self.GEN.COM("sel_contourize,accuracy=6.35,break_to_islands=yes,clean_hole_size=5,clean_hole_mode=x_and_y")
        self.GEN.COM("sel_resize,size=-6000,corner_ctl=no")

        # 切除留边区域
        self.GEN.COM("clip_area_strt")
        self.GEN.COM(
            "clip_area_end,layers_mode=layer_name,layer=tmp-song3,area=reference,area_type=rectangle,inout=inside,contour_cut=no,margin=2,ref_layer=tmp-song2,feat_types=line\;pad\;surface\;arc\;text")
        # 打散铜皮
        self.GEN.COM("sel_decompose,overlap=yes")
        # 选中小于25平方mm的铜块，删除
        self.GEN.COM("filter_reset,filter_name=popup")
        self.GEN.COM("adv_filter_set,filter_name=popup,update_popup=yes,srf_area=yes,min_area=0,max_area=25")
        self.GEN.COM("filter_area_strt")
        self.GEN.COM(
            "filter_area_end,layer=,filter_name=popup,operation=select,area_type=none,inside_area=no,intersect_area=no")
        # 选中dx小于4mm的铜块，删除
        self.GEN.COM("filter_reset,filter_name=popup")
        self.GEN.COM("adv_filter_reset,filter_name=popup")
        self.GEN.COM(
            "adv_filter_set,filter_name=popup,update_popup=yes,limit_box=yes,min_dx=0,max_dx=4,min_dy=0,max_dy=0")
        self.GEN.COM("filter_area_strt")
        self.GEN.COM(
            "filter_area_end,layer=,filter_name=popup,operation=select,area_type=none,inside_area=no,intersect_area=no")
        # 选中dy小于4mm的铜块，删除
        self.GEN.COM("filter_reset,filter_name=popup")
        self.GEN.COM("adv_filter_reset,filter_name=popup")
        self.GEN.COM(
            "adv_filter_set,filter_name=popup,update_popup=yes,limit_box=yes,min_dx=0,max_dx=0,min_dy=0,max_dy=4")
        self.GEN.COM("filter_area_strt")
        self.GEN.COM(
            "filter_area_end,layer=,filter_name=popup,operation=select,area_type=none,inside_area=no,intersect_area=no")
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM("sel_delete")
        self.GEN.COM("adv_filter_reset,filter_name=popup")

        # 保留铜皮
        self.GEN.COM(
            "sel_copy_other,dest=layer_name,target_layer=eagle-cu,invert=no,dx=0,dy=0,size=0,x_anchor=0,y_anchor=0,rotation=0,mirror=none")

        # --tmp-mich1排版间距铺铜
        self.GEN.COM("display_layer,name=tmp-mich1,display=yes,number=1")
        self.GEN.COM("work_layer,name=tmp-mich1")
        self.GEN.COM(
            "sr_fill,polarity=positive,step_margin_x=3,step_margin_y=3,step_max_dist_x=2540,step_max_dist_y=2540,sr_margin_x=0.2,sr_margin_y=0.2,sr_max_dist_x=2,sr_max_dist_y=2,nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        self.GEN.COM("display_layer,name=tmp-song1,display=yes,number=1")
        self.GEN.COM("work_layer,name=tmp-song1")
        self.GEN.COM(
            "sel_copy_other,dest=layer_name,target_layer=tmp-mich1,invert=yes,dx=0,dy=0,size=4000,x_anchor=0,y_anchor=0,rotation=0,mirror=none")
        self.GEN.COM("display_layer,name=tmp-mich1,display=yes,number=1")
        self.GEN.COM("work_layer,name=tmp-mich1")
        self.GEN.COM("sel_contourize,accuracy=6.35,break_to_islands=yes,clean_hole_size=5,clean_hole_mode=x_and_y")
        self.GEN.COM(
            "sel_copy_other,dest=layer_name,target_layer=eagle-cu-pitch,invert=no,dx=0,dy=0,size=0,x_anchor=0,y_anchor=0,rotation=0,mirror=none")

        self.GEN.COM("display_layer,name=tmp-song4,display=yes,number=1")
        self.GEN.COM("work_layer,name=tmp-song4")

        eagle_pnl_xe = panel_x_size + panel_y_size
        self.GEN.COM(
            "add_line,attributes=no,xs=%s,ys=0,xe=%s,ye=%s,symbol=s1500,polarity=positive,bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
            % (panel_x_size, eagle_pnl_xe, panel_y_size))
        eagleladdnum = int(panel_x_size / 20 + 1 + panel_y_size / 20)
        self.GEN.COM("sel_single_feat,operation=select,x=%s,y=0,tol=5,cyclic=no" % panel_x_size)
        self.GEN.COM("sel_copy_repeat,nx=%s,ny=1,dx=-20,dy=0,ref_layer=" % eagleladdnum)

        # 切除板外的
        self.GEN.COM("clip_area_strt")
        self.GEN.COM(
            "clip_area_end,layers_mode=affected_layers,layer=,area=profile,area_type=rectangle,inout=outside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
        self.GEN.COM(
            "sel_copy_other,dest=layer_name,target_layer=tmp-song3,invert=yes,dx=0,dy=0,size=0,x_anchor=0,y_anchor=0,rotation=0,mirror=none")
        self.GEN.COM(
            "sel_copy_other,dest=layer_name,target_layer=tmp-mich1,invert=yes,dx=0,dy=0,size=0,x_anchor=0,y_anchor=0,rotation=0,mirror=none")
        self.GEN.COM("display_layer,name=tmp-song3,display=yes,number=1")
        self.GEN.COM("work_layer,name=tmp-song3")
        self.GEN.COM("affected_layer,name=tmp-mich1,mode=single,affected=yes");
        self.GEN.COM("sel_contourize,accuracy=6.35,break_to_islands=yes,clean_hole_size=5,clean_hole_mode=x_and_y")
        self.GEN.COM("sel_decompose,overlap=yes")  # song change 20190531 打散整体化的铜皮 #
        self.GEN.COM("sel_cont2pad,match_tol=25.4,restriction=,min_size=254,max_size=50000,suffix=+++")
        self.GEN.VOF()
        self.GEN.COM("delete_layer,layer=tmp-song3+++")
        self.GEN.COM("delete_layer,layer=tmp-mich1+++");
        self.GEN.VON()
        self.GEN.COM("affected_layer,name=tmp-mich1,mode=single,affected=no");
        self.GEN.COM("filter_reset,filter_name=popup")
        self.GEN.COM("filter_set,filter_name=popup,update_popup=no,feat_types=pad")
        self.GEN.COM("filter_area_strt")
        self.GEN.COM(
            "filter_area_end,layer=,filter_name=popup,operation=select,area_type=none,inside_area=no,intersect_area=no")
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM("sel_change_sym,symbol=eagle-mark-dot,reset_angle=no")
        self.GEN.COM("filter_reset,filter_name=popup")
        self.GEN.COM("filter_set,filter_name=popup,update_popup=no,feat_types=pad")
        self.GEN.COM("filter_set,filter_name=popup,update_popup=no,include_syms=eagle-mark-dot")
        self.GEN.COM(
            "sel_ref_feat,layers=eagle-cu,use=filter,mode=cover,pads_as=shape,f_types=line\;pad\;surface\;arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=")
        count = self.GEN.GET_SELECT_COUNT()  # song change 20190531 必须碰到铜皮的才move过去 #
        if count > 0:
            self.GEN.COM(
                "sel_move_other,target_layer=song-tmp,invert=no,dx=0,dy=0,size=0,x_anchor=0,y_anchor=0,rotation=0,mirror=none")

        # --将排版间距之间的pad转为bfr45
        self.GEN.COM("display_layer,name=tmp-mich1,display=yes,number=1")
        self.GEN.COM("work_layer,name=tmp-mich1")
        self.GEN.COM("filter_reset,filter_name=popup")
        self.GEN.COM("filter_set,filter_name=popup,update_popup=no,feat_types=pad")
        self.GEN.COM("filter_area_strt")
        self.GEN.COM(
            "filter_area_end,layer=,filter_name=popup,operation=select,area_type=none,inside_area=no,intersect_area=no")
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM("sel_change_sym,symbol=bfr1143,reset_angle=no")

        self.GEN.COM("filter_reset,filter_name=popup")
        self.GEN.COM("filter_set,filter_name=popup,update_popup=no,feat_types=pad")
        self.GEN.COM("filter_set,filter_name=popup,update_popup=no,include_syms=bfr1143")
        self.GEN.COM(
            "sel_ref_feat,layers=eagle-cu-pitch,use=filter,mode=cover,pads_as=shape,f_types=line\;pad\;surface\;arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=")
        count = self.GEN.GET_SELECT_COUNT()  # 必须碰到铜皮的才move过去
        if count > 0:
            self.GEN.COM(
                "sel_move_other,target_layer=eagle-dot-pitch,invert=no,dx=0,dy=0,size=0,x_anchor=0,y_anchor=0,rotation=0,mirror=none")
            self.GEN.COM(
                "copy_layer,source_job=%s,source_step=panel,source_layer=eagle-dot-pitch,dest=layer_name,dest_layer=song-tmp,mode=append,invert=no" % self.JOB)

        self.GEN.COM("display_layer,name=eagle-cu,display=yes,number=1")
        self.GEN.COM("work_layer,name=eagle-cu")
        self.GEN.COM("filter_reset,filter_name=popup")
        self.GEN.COM(
            "sel_ref_feat,layers=eagle-cu,use=filter,mode=disjoint,pads_as=shape,f_types=line\;pad\;surface\;arc\;text,polarity=positive\;negative,include_syms=,exclude_syms=")
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM("sel_delete")
        self.GEN.VOF()
        self.GEN.COM("delete_layer,layer=tmp-mich1")
        self.GEN.COM("delete_layer,layer=tmp-song1")
        self.GEN.COM("delete_layer,layer=tmp-song2")
        self.GEN.COM("delete_layer,layer=tmp-song3")
        self.GEN.COM("delete_layer,layer=tmp-song4")
        self.GEN.VON()


class ETCH_copper(object):
    """
    蚀刻引线层铺铜
    """

    def __init__(self, frozen_json=None, priority=0):
        self.parm = frozen_json
        self.GEN = genCOM.GEN_COM()
        self.JOB = os.environ.get('JOB', None)

    def put_copper(self):
        """
        依据fill_array指定的铺铜方式进行铺铜
        :return:
        :rtype:
        """

        self.GEN.CLEAR_LAYER()
        if self.GEN.LAYER_EXISTS('etch-c', job=self.JOB, step='panel') == 'yes':
            self.GEN.COM('affected_layer,name=etch-c,mode=single,affected=yes')
        if self.GEN.LAYER_EXISTS('etch-s', job=self.JOB, step='panel') == 'yes':
            self.GEN.COM('affected_layer,name=etch-s,mode=single,affected=yes')
        self.GEN.COM('get_affect_layer')
        layers = self.GEN.COMANS.split()
        if len(layers) == 0:
            self.GEN.DELETE_LAYER('clip_copper')
            return
        self.GEN.COM('fill_params,type=solid,origin_type=datum,solid_type=surface')
        # V2.09 铺铜至单元0.254-->0
        self.GEN.COM("sr_fill,polarity=positive,step_margin_x=0,step_margin_y=0,step_max_dist_x=2540,"
                     "step_max_dist_y=2540,sr_margin_x=0,sr_margin_y=0,sr_max_dist_x=0,sr_max_dist_y=0,"
                     "nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        self.GEN.COM("sel_resize,size=-381,corner_ctl=no")
        self.GEN.COM("sel_resize,size=381,corner_ctl=no")
        self.GEN.CLEAR_LAYER()
        # --利用前面外层铺铜生成的clip_copper层别
        goldName = self.JOB[6:8]
        nameList = ['py', 'pr', 'sy', 'sr', 'gr', 'gy', 'hy', 'pl', 'sl', 'gl', 'pf']
        if goldName not in nameList:
            return
        if self.GEN.LAYER_EXISTS('clip_copper', job=self.JOB, step='panel') == 'yes':
            # --分别copy到外层
            if self.GEN.LAYER_EXISTS('etch-c', job=self.JOB, step='panel') == 'yes':
                self.GEN.COPY_LAYER(self.JOB, 'panel', 'clip_copper', 'etch-c', mode='append', invert='yes')
                self.GEN.COM('affected_layer,name=etch-c,mode=single,affected=yes')
                self.GEN.SEL_CONTOURIZE()
                self.GEN.AFFECTED_LAYER('etch-c', 'no')
            if self.GEN.LAYER_EXISTS('etch-s', job=self.JOB, step='panel') == 'yes':
                self.GEN.COPY_LAYER(self.JOB, 'panel', 'clip_copper', 'etch-s', mode='append', invert='yes')
                self.GEN.COM('affected_layer,name=etch-s,mode=single,affected=yes')
                self.GEN.SEL_CONTOURIZE()
                self.GEN.AFFECTED_LAYER('etch-s', 'no')
            self.GEN.DELETE_LAYER('clip_copper')


class GOLD_copper(object):
    """
    化金板边铺铜
    """

    def __init__(self, frozen_json=None, priority=0):
        self.parm = frozen_json
        self.GEN = genCOM.GEN_COM()
        self.JOB = os.environ.get('JOB', None)

    def put_copper(self):
        """
        依据fill_array指定的铺铜方式进行铺铜
        :return:
        :rtype:
        """
        sel_finger = self.parm.sel_finger
        g_direction = self.parm.g_direction
        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        job_signal_numbers = self.parm.job_signal_numbers

        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y

        if job_signal_numbers == 2:
            rout_x = profile_xmax
            rout_y = profile_ymax
        self.GEN.CLEAR_LAYER()
        if self.GEN.LAYER_EXISTS('gold-c', job=self.JOB, step='panel') == 'yes':
            self.GEN.COM('affected_layer,name=gold-c,mode=single,affected=yes')
        if self.GEN.LAYER_EXISTS('gold-s', job=self.JOB, step='panel') == 'yes':
            self.GEN.COM('affected_layer,name=gold-s,mode=single,affected=yes')
        self.GEN.COM('get_affect_layer')
        layers = self.GEN.COMANS.split()
        if len(layers) == 0:
            return
        # V2.13 http://192.168.2.120:82/zentao/story-view-4625.html
        # 1,开料尺寸≤650mm时，留边与开窗取短边，短边留边需大于30mm，短边开窗依最后一次锣边往内开10mm，如留边不够提示需修改拼版。
        # 2，开料尺寸＞650mm时，留边与开窗取长边，长边留边需大于30mm，长边开窗依最后一次锣边往内开10mm，如留边不够提示需修改拼版。 20221115 by lyh
        
        # 20230221 by lyh
        # 20230221 工艺要求恢复手指选择
        # http://192.168.2.120:82/zentao/story-view-5150.html
        #1、镀金系列板边留铜 8-10mm,留铜边距板边≤650 mm，导电窗留铜保证不与金手指相对（即板内手指与板边留铜开窗边平行），其余三边干膜覆盖。
        #2、镀金手指排列不规律按开料规格≤650 mm短边留铜，＞650 mm长边留铜其余三边干膜覆盖。
        
        if sel_finger == "是" and (g_direction == "X方向" or g_direction == "XY均有") and profile_ymax <= 650:
        # if sel_finger == "是" and profile_ymax <= 650:            
            rout_after_marginy = (profile_ymax - rout_y) * 0.5
            # rout_after_marginx = (profile_xmax - rout_x) * 0.5
            max_dist_y = profile_ymax - sr_ymax - 2.0
            max_dist_y2 = rout_after_marginy + 10
            if max_dist_y2 < max_dist_y:
                max_dist_y = max_dist_y2

            surface_y = profile_ymax + 2
            surface_y2 = sr_ymax + ((profile_ymax - sr_ymax) - max_dist_y)
            surface_right_x1 = profile_xmin - 2
            surface_left_x1 = profile_xmax + 2
            self.add_surf_poly(surface_right_x1, surface_y, surface_left_x1, surface_y2)
            self.GEN.CLEAR_LAYER()
        elif sel_finger == "是" and (g_direction == "Y方向" or (g_direction == "XY均有" and profile_ymax > 650)):
        # elif sel_finger == "是" and profile_ymax > 650:   
            rout_after_marginx = (profile_xmax - rout_x) * 0.5
            max_dist_x = profile_xmax - sr_xmax - 2.0
            max_dist_x2 = rout_after_marginx + 10
            if max_dist_x2 < max_dist_x:
                max_dist_x = max_dist_x2
            surface_x = profile_xmax + 2
            surface_x2 = sr_xmax + ((profile_xmax - sr_xmax) - max_dist_x)
            surface_down_y1 = profile_ymin - 2
            surface_up_x1 = profile_ymax + 2
            self.add_surf_poly(surface_x, surface_down_y1, surface_x2, surface_up_x1)
            self.GEN.CLEAR_LAYER()

    def add_surf_poly(self, startx, starty, endx, endy):

        self.GEN.COM(
            "fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,use_arcs=yes,"
            "symbol=,dx=2.54,dy=2.54,std_angle=45,std_line_width=254,std_step_dist=1270,std_indent=odd,"
            "break_partial=yes,cut_prims=no,outline_draw=no,outline_width=0,outline_invert=no")
        self.GEN.COM("add_surf_strt,surf_type=feature")
        self.GEN.COM("add_surf_poly_strt,x=%s,y=%s" % (startx, starty))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (startx, endy))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (endx, endy))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (endx, starty))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (startx, starty))
        self.GEN.COM("add_surf_poly_end")
        self.GEN.COM("add_surf_end,attributes=no,polarity=positive")


class SGT_copper(object):
    """
    选化板边铺铜,锣边5mm铺铜,不盖干膜
    """

    def __init__(self, frozen_json=None, priority=0):
        self.parm = frozen_json
        self.GEN = genCOM.GEN_COM()
        self.JOB = os.environ.get('JOB', None)

    def put_copper(self):
        """
        依据fill_array指定的铺铜方式进行铺铜
        :return:
        :rtype:
        """
        job_signal_numbers = self.parm.job_signal_numbers
        lam_rout = self.parm.lam_rout
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        flow_content = self.parm.flow_content
        put_copper_out = self.parm.put_copper_out
        sel_finger = self.parm.sel_finger
        sgt_on_do = self.JOB[6]
        if sgt_on_do == 'o' and sel_finger == '否':
            pass
        elif sel_finger == '是':
            pass
        else:
            return
        self.GEN.CLEAR_LAYER()
        if self.GEN.LAYER_EXISTS('sgt-c', job=self.JOB, step='panel') == 'yes':
            self.GEN.COM('affected_layer,name=sgt-c,mode=single,affected=yes')
        if self.GEN.LAYER_EXISTS('sgt-s', job=self.JOB, step='panel') == 'yes':
            self.GEN.COM('affected_layer,name=sgt-s,mode=single,affected=yes')
        self.GEN.COM('get_affect_layer')
        layers = self.GEN.COMANS.split()
        if len(layers) == 0:
            return

        # 20200408李家兴依据story-view-1075修改，一次铜选化板边，要以外层pad D+20套开选化层
        if flow_content == '一次铜' and put_copper_out == "no":
            self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface");
            self.GEN.COM(
                "sr_fill,polarity=positive,step_margin_x=0,step_margin_y=0,step_max_dist_x=2540,step_max_dist_y=2540,sr_margin_x=0,sr_margin_y=0,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,stop_at_steps=,consider_feat=yes,feat_margin=0.254,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no");

        self.GEN.CLEAR_LAYER()
        
        if flow_content == "一次铜":            
            self.adjust_copper()
    
    def adjust_copper(self):
        """选化板 且板厚小于等于0.5mm 需铺铜 20230218 by lyh
        参考http://192.168.2.120:82/zentao/story-view-5150.html"""
        add_hj_panel = self.parm.add_hj_panel
        board_thick = self.parm.board_thick
        job_signal_numbers = self.parm.job_signal_numbers
        
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        if job_signal_numbers <= 2:
            rout_x = self.parm.profile_xmax
            rout_y = self.parm.profile_ymax        
        
        job = gClasses.Job(self.JOB)
        stepname = "panel"
        step = gClasses.Step(job, stepname)
        step.open()
        step.COM("units,type=mm")  
        
        lb_x = (profile_xmax - rout_x) * 0.5
        lb_y = (profile_ymax - rout_y) * 0.5        
        step.clearAll()
        step.removeLayer("surface_tmp")
        step.createLayer("surface_tmp")
        step.affect("surface_tmp")
        step.reset_fill_params()
        step.addRectangle(profile_xmin+lb_x, profile_ymin+lb_y, profile_xmax-lb_x, profile_ymax-lb_y)            
        step.addRectangle(profile_xmin+lb_x+0.4, profile_ymin+lb_y+0.4,
                          profile_xmax-lb_x-0.4, profile_ymax-lb_y-0.4, polarity='negative')
        
        step.contourize()
        step.addAttr(".pattern_fill",valType="", change_attr="yes")
            
        #化金 或选化 且板厚小于等于0.5mm
        if add_hj_panel == "是" and board_thick <= 0.5:
            for layer in ['sgt-c', 'sgt-s']:
                if step.isLayer(layer):                    
                    step.copyLayer(job.name, stepname, "surface_tmp", layer)
                
        step.clearAll()
        step.removeLayer("surface_tmp")

class LineK_copper(object):
    """
        V2.09新增 印选化油层铺铜
    """

    def __init__(self, frozen_json=None, priority=0):
        self.parm = frozen_json
        self.GEN = genCOM.GEN_COM()
        self.JOB = os.environ.get('JOB', None)

    def put_copper(self):
        """
        依据fill_array指定的铺铜方式进行铺铜
        :return:
        :rtype:
        """
        job_signal_numbers = self.parm.job_signal_numbers
        lam_rout = self.parm.lam_rout
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        flow_content = self.parm.flow_content
        put_copper_out = self.parm.put_copper_out
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y

        if job_signal_numbers == 2:
            rout_x = panel_x
            rout_y = panel_y
        self.GEN.CLEAR_LAYER()
        #增加一次 二次选化印油铺铜 20221123 by lyh V2.14
        # 印选化油后半孔锣不用铺铜仅限linek-c,和linek-s  http://192.168.2.120:82/zentao/story-view-6784.html
        all_flows = InPlan(self.JOB).get_inplan_all_flow()
        half_drill_rout_index = None
        for flow in all_flows:
            if '半孔锣' in flow['WORK_CENTER_CODE']:
                half_drill_rout_index = int(flow['TRAVELER_ORDERING_INDEX'])
                break
        not_fill_copper = []
        if half_drill_rout_index:
            for flow in all_flows:
                if '印选化油' in flow['WORK_CENTER_CODE'] and int(flow['TRAVELER_ORDERING_INDEX']) < half_drill_rout_index:
                    not_fill_copper = ["linek-c", "linek-s"]
                    if re.search('linek.*,linek.*', str(flow['VALUE_AS_STRING']).strip()):
                        get_lineks = str(flow['VALUE_AS_STRING']).strip().split(',')
                        if len(get_lineks) == 2:
                            if get_lineks[0] in self.GEN.GET_ATTR_LAYER('all') and get_lineks[1] in self.GEN.GET_ATTR_LAYER('all'):
                                not_fill_copper = get_lineks
                        break
        for layer in ["linek-c", "linek-s", "linek-c-1", "linek-s-1", "linek-c-2", "linek-s-2"]:
            if self.GEN.LAYER_EXISTS(layer, job=self.JOB, step='panel') == 'yes':
                if not_fill_copper:
                    if layer in not_fill_copper:
                        continue
                self.GEN.COM('affected_layer,name={0},mode=single,affected=yes'.format(layer))
          
        self.GEN.COM('get_affect_layer')
        layers = self.GEN.COMANS.split()
        if len(layers) == 0:
            return
        margin_x = (panel_x - rout_x)  * 0.5  + 4
        margin_y = (panel_y - rout_y)  * 0.5  + 7

        self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface")
        self.GEN.COM(
            "sr_fill,polarity=positive,step_margin_x=%s,step_margin_y=%s,step_max_dist_x=2540,step_max_dist_y=2540,"
            "sr_margin_x=1.5,sr_margin_y=1.5,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,stop_at_steps=,consider_feat=yes,"
            "feat_margin=0.254,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no" % (margin_x, margin_y))

        self.GEN.CLEAR_LAYER()
        
        if flow_content == "一次铜": 
            self.adjust_copper()
        
    def adjust_copper(self):
        """金手指板 1.板边只保留5颗对位Symbol，一次字样和料号信息
        2.二次选化 加图示铜块 20230218 by lyh
        参考http://192.168.2.120:82/zentao/story-view-5150.html"""
        sel_jsz = self.parm.sel_jsz
        g_direction = self.parm.g_direction
        
        out_signal_array = self.parm.out_signal_array
        add_hj_panel = self.parm.add_hj_panel
        board_thick = self.parm.board_thick
        job_signal_numbers = self.parm.job_signal_numbers
        
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        if job_signal_numbers <= 2:
            rout_x = self.parm.profile_xmax
            rout_y = self.parm.profile_ymax        
        
        job = gClasses.Job(self.JOB)
        stepname = "panel"
        step = gClasses.Step(job, stepname)
        step.open()
        step.COM("units,type=mm")

        lb_x = (profile_xmax - rout_x) * 0.5
        lb_y = (profile_ymax - rout_y) * 0.5        
        step.clearAll()
        step.removeLayer("surface_tmp")
        step.createLayer("surface_tmp")
        step.affect("surface_tmp")
        step.reset_fill_params()
        step.addRectangle(profile_xmin+lb_x, profile_ymin+lb_y, profile_xmax-lb_x, profile_ymax-lb_y)            
        step.addRectangle(profile_xmin+lb_x+0.4, profile_ymin+lb_y+0.4,
                          profile_xmax-lb_x-0.4, profile_ymax-lb_y-0.4, polarity='negative')
        
        step.contourize()
        step.addAttr(".pattern_fill",valType="", change_attr="yes")
        
        if sel_jsz == '是' and board_thick > 0.5:            
            step.clearAll()
            for layer in ["linek-c", "linek-s","linek-c-1","linek-s-1","linek-c-2","linek-s-2"]:
                if step.isLayer(layer):
                    step.affect(layer)
                    
            step.resetFilter()
            step.filter_set(feat_types='surface', polarity='positive')
            step.selectAll()
            if step.featureSelected():
                step.selectDelete()
                
            step.reset_fill_params()
            for layer in ["linek-c-2","linek-s-2"]:
                if step.isLayer(layer):                    
                    step.clearAll()
                    step.affect(layer)
                    if (g_direction == "X方向" or g_direction == "XY均有") and profile_ymax <= 650: 
                        step.addRectangle(profile_xmin+lb_x+12, sr_ymax+20*0.0254, profile_xmax-lb_x-12, profile_ymax-8)
                    else:
                        step.addRectangle(sr_xmax+20*0.0254, profile_ymin+lb_x+12, profile_xmax-8, profile_ymax-lb_x-12)                        
                    
            step.clearAll()
            
        #化金 或选化 且板厚小于等于0.5mm
        if add_hj_panel == "是" and board_thick <= 0.5:
            for layer in ["linek-c", "linek-s","linek-c-1","linek-s-1","linek-c-2","linek-s-2"]:
                if step.isLayer(layer):                    
                    step.copyLayer(job.name, stepname, "surface_tmp", layer)
                
        step.clearAll()
        step.removeLayer("surface_tmp")            


class INN_copper(object):
    """
    内层板边铺铜
    """

    def __init__(self, frozen_json=None, priority=0):
        self.parm = frozen_json
        self.GEN = genCOM.GEN_COM()
        self.JOB = os.environ.get('JOB', None)
        self.create_honeycomb_tmp()
        self.get_sr_honeycomb()
        self.cusNo = self.JOB[1:4]

    def put_copper(self):
        """
        依据fill_array指定的铺铜方式进行铺铜
        :return:
        :rtype:
        """
        fill_array = self.parm.fill_array
        fill_sym_list = [fill_hash.panel_fill for fill_hash in fill_array]
        lam_rout = self.parm.lam_rout

        if '蜂窝' in fill_sym_list:
            self.create_honeycomb_sym()
        if '梯形' in fill_sym_list:
            self.create_ladder_sym()
        if '辅助' in fill_sym_list:
            self.create_assist_copper()
        # if self.parm.is_PHOTOVOLTAIC_board:
        #     # --光电板铺铜
        #     self.create_PHOTOVOLTAIC_copper()
        out_signal_array = self.parm.out_signal_array
        for fill_hash in fill_array:
            layer_name = fill_hash.layer_name
            layer_side = fill_hash.layer_side
            panel_fill = fill_hash.panel_fill
            cur_lamin_num = fill_hash.lamin_num
            if not layer_name in out_signal_array:
                if panel_fill == '梯形':
                    # === 按正反判断会出现相邻层相同的情况，使用top，bot循环添加，不与正反正相关 ===
                    # if layer_side == "正":
                    #     source_layer = 'ladder_top%s' % cur_lamin_num
                    # else:
                    #     source_layer = 'ladder_bot%s' % cur_lamin_num
                    layer_num = layer_name[1:]
                    if int(layer_num) % 2 == 0:
                        source_layer = 'ladder_top%s' % cur_lamin_num
                    else:
                        source_layer = 'ladder_bot%s' % cur_lamin_num

                elif panel_fill == '蜂窝':
                    # if layer_side == "正":
                    #     source_layer = 'honeycomb-tok'
                    # else:
                    #     source_layer = 'honeycomb-bok'

                    layer_num = layer_name[1:]
                    if int(layer_num) % 2 == 0:
                        source_layer = 'honeycomb-tok%s' % cur_lamin_num
                    else:
                        source_layer = 'honeycomb-bok%s' % cur_lamin_num

                elif panel_fill == '辅助':
                    source_layer = 'assist_copper'
                # --copy板边铺铜
                self.GEN.COPY_LAYER(self.JOB, 'panel', source_layer, layer_name)
                # if self.parm.is_PHOTOVOLTAIC_board:
                #     self.GEN.COPY_LAYER(self.JOB,'panel','photo_copper',layer_name,mode='append')
        # --删除临时层别
        self.GEN.DELETE_LAYER('honeycomb-t')
        self.GEN.DELETE_LAYER('honeycomb-b')
        self.GEN.DELETE_LAYER('honeycomb-tsr')
        self.GEN.DELETE_LAYER('honeycomb-bsr')
        self.GEN.DELETE_LAYER('honeycomb-tmp1')
        self.GEN.DELETE_LAYER('honeycomb-tmp2')
        self.GEN.DELETE_LAYER('honeycomb-tmp3')
        self.GEN.DELETE_LAYER('honeycomb-tmp4')
        self.GEN.DELETE_LAYER('honeycomb-tmp5')
        self.GEN.DELETE_LAYER('honeycomb-tok')
        self.GEN.DELETE_LAYER('honeycomb-bok')
        for i in range(len(lam_rout) + 1):
            self.GEN.DELETE_LAYER('ladder_top%s' % i)
            self.GEN.DELETE_LAYER('ladder_bot%s' % i)

            self.GEN.DELETE_LAYER('honeycomb-tok%s' % i)
            self.GEN.DELETE_LAYER('honeycomb-bok%s' % i)

        self.GEN.DELETE_LAYER('assist_copper')

        self.GEN.DELETE_LAYER('eagle-clear-pitch')
        self.GEN.DELETE_LAYER('eagle-cu-pitch')
        self.GEN.DELETE_LAYER('eagle-dot-pitch')

    def create_PHOTOVOLTAIC_copper(self):
        """
        光电板sr2.5mm范围内铺铜
        :return:
        :rtype:
        """
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        self.create_tmp_layer('photo_copper')
        self.GEN.CLEAR_LAYER()
        self.GEN.COM("affected_layer,name=photo_copper,mode=single,affected=yes")
        # --定义并添加bot砖块,从左至右
        x1_bot = sr_xmin + 1.6
        x2_bot = x1_bot + 1.25
        y1_bot = sr_ymin - 0.2 - 0.25 - 1.4
        y2_bot = y1_bot + 0.25 * 2 + 0.2
        dy1_bot = 1400
        dy2_bot = 0
        ny1_bot = 2
        ny2_bot = 1
        dx1_bot = 2500
        dx2_bot = 2500
        nx1_bot = (sr_xmax - 1.6 * 2 - sr_xmin) / 2.5
        nx1_bot = math.modf(nx1_bot)[1] + 1
        nx2_bot = (sr_xmax - 1.6 * 2 - sr_xmin - 2.5) / 2.5
        nx2_bot = math.modf(nx2_bot)[1] + 1
        self.GEN.ADD_PAD(x1_bot, y1_bot, 'rect2000x500', nx=nx1_bot, ny=ny1_bot, dx=dx1_bot, dy=dy1_bot)
        self.GEN.ADD_PAD(x2_bot, y2_bot, 'rect2000x500', nx=nx2_bot, ny=ny2_bot, dx=dx2_bot, dy=dy2_bot)

        # --定义并添加top砖块,从右至左
        x1_top = sr_xmax - 1.6
        x2_top = x1_top - 1.25
        y1_top = sr_ymax + 0.2 + 0.25
        y2_top = y1_top + 0.25 * 2 + 0.2
        dy1_top = 1400
        dy2_top = 0
        ny1_top = 2
        ny2_top = 1
        dx1_top = -2500
        dx2_top = -2500
        nx1_top = (sr_xmax - 1.6 * 2 - sr_xmin) / 2.5
        nx1_top = math.modf(nx1_top)[1] + 1
        nx2_top = (sr_xmax - 1.6 * 2 - sr_xmin - 2.5) / 2.5
        nx2_top = math.modf(nx2_top)[1] + 1
        self.GEN.ADD_PAD(x1_top, y1_top, 'rect2000x500', nx=nx1_top, ny=ny1_top, dx=dx1_top, dy=dy1_top)
        self.GEN.ADD_PAD(x2_top, y2_top, 'rect2000x500', nx=nx2_top, ny=ny2_top, dx=dx2_top, dy=dy2_top)

        # --定义并添加right砖块,从下至上
        y1_right = sr_ymin + 1.6
        y2_right = y1_right + 1.25
        x1_right = sr_xmax + 0.2 + 0.25
        x2_right = x1_right + 0.25 * 2 + 0.2
        dx1_right = 1400
        dx2_right = 0
        nx1_right = 2
        nx2_right = 1
        dy1_right = 2500
        dy2_right = 2500
        ny1_right = (sr_ymax - 1.6 * 2 - sr_ymin) / 2.5
        ny1_right = math.modf(ny1_right)[1] + 1
        ny2_right = (sr_ymax - 1.6 * 2 - sr_ymin - 2.5) / 2.5
        ny2_right = math.modf(ny2_right)[1] + 1
        self.GEN.ADD_PAD(x1_right, y1_right, 'rect500x2000', nx=nx1_right, ny=ny1_right, dx=dx1_right, dy=dy1_right)
        self.GEN.ADD_PAD(x2_right, y2_right, 'rect500x2000', nx=nx2_right, ny=ny2_right, dx=dx2_right, dy=dy2_right)

        # --定义并添加left砖块,从上至下
        y1_left = sr_ymax - 1.6
        y2_left = y1_left - 1.25
        x1_left = sr_xmin - 0.2 - 0.25 - 1.4
        x2_left = x1_left + 0.25 * 2 + 0.2
        dx1_left = 1400
        dx2_left = 0
        nx1_left = 2
        nx2_left = 1
        dy1_left = -2500
        dy2_left = -2500
        ny1_left = (sr_ymax - 1.6 * 2 - sr_ymin) / 2.5
        ny1_left = math.modf(ny1_left)[1] + 1
        ny2_left = (sr_ymax - 1.6 * 2 - sr_ymin - 2.5) / 2.5
        ny2_left = math.modf(ny2_left)[1] + 1
        self.GEN.ADD_PAD(x1_left, y1_left, 'rect500x2000', nx=nx1_left, ny=ny1_left, dx=dx1_left, dy=dy1_left)
        self.GEN.ADD_PAD(x2_left, y2_left, 'rect500x2000', nx=nx2_left, ny=ny2_left, dx=dx2_left, dy=dy2_left)
        self.GEN.COM("affected_layer,name=photo_copper,mode=single,affected=no")

    def create_assist_copper(self):
        """
        创建辅助层铺铜
        :return:
        :rtype:
        """
        profile_xmin = self.parm.profile_xmin
        profile_xmax = self.parm.profile_xmax
        profile_ymin = self.parm.profile_ymin
        profile_ymax = self.parm.profile_ymax
        xmin = profile_xmin - 0.254
        ymin = profile_ymin - 0.254
        xmax = profile_xmax + 0.254
        ymax = profile_ymax + 0.254
        self.create_tmp_layer('assist_copper')
        self.GEN.WORK_LAYER('assist_copper')
        self.GEN.COM("units,type=mm")
        self.GEN.COM("add_surf_strt,surf_type=feature")
        self.GEN.COM("add_surf_poly_strt,x=%s,y=%s" % (xmin, ymin))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (xmin, ymax))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (xmax, ymax))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (xmax, ymin))
        self.GEN.COM("add_surf_poly_seg,x=%s,y=%s" % (xmin, ymin))
        self.GEN.COM("add_surf_poly_end")
        self.GEN.COM("add_surf_end,attributes=no,polarity=positive")

    def create_ladder_sym(self):
        """
        创建梯形的板边铺铜symbol
        :return:
        :rtype:
        """
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        profile_xmin = self.parm.profile_xmin
        profile_xmax = self.parm.profile_xmax
        profile_ymin = self.parm.profile_ymin
        profile_ymax = self.parm.profile_ymax
        job_signal_numbers = self.parm.job_signal_numbers
        lam_rout = self.parm.lam_rout
        lenth = 13
        width = 63
        # --长边clip板内坐标定义
        clip_Iy_xmax = sr_xmin - 2.5
        clip_Iy_xmin = sr_xmax + 2.5
        clip_Iy_ymin = profile_ymin - 5
        clip_Iy_ymax = profile_ymax + 5
        # --短边clip板内坐标定义
        clip_Ix_xmin = sr_xmin - 2.5 - 5
        clip_Ix_xmax = sr_xmax + 2.5 + 5
        clip_Ix_ymin = sr_ymin - 2.5
        clip_Ix_ymax = sr_ymax + 2.5
        # --短边clip板外坐标定义
        clip_Ox_xmin = sr_xmin - 2.5 - 5
        clip_Ox_xmax = sr_xmax + 2.5 + 5

        clip_out_dict = {}
        for lamin_i in lam_rout:
            cur_lamin_num = lamin_i[0]
            cur_lamin_routx = lamin_i[1]
            cur_lamin_routy = lamin_i[2]

            clip_Oy_xmin = profile_xmin + (profile_xmax - cur_lamin_routx) * 0.5 + 2
            clip_Oy_xmax = profile_xmax - (profile_xmax - cur_lamin_routx) * 0.5 - 2
            clip_Oy_ymin = profile_ymin + (profile_ymax - cur_lamin_routy) * 0.5 + 2
            clip_Oy_ymax = profile_ymax - (profile_ymax - cur_lamin_routy) * 0.5 - 2
            clip_Ox_ymin = profile_ymin + (profile_ymax - cur_lamin_routy) * 0.5 + 2
            clip_Ox_ymax = profile_ymax - (profile_ymax - cur_lamin_routy) * 0.5 - 2
            clip_out_dict[cur_lamin_num] = {
                'clip_Oy_xmin': clip_Oy_xmin,
                'clip_Oy_xmax': clip_Oy_xmax,
                'clip_Oy_ymin': clip_Oy_ymin,
                'clip_Oy_ymax': clip_Oy_ymax,
                'clip_Ox_xmin': clip_Ox_xmin,
                'clip_Ox_xmax': clip_Ox_xmax,
                'clip_Ox_ymin': clip_Ox_ymin,
                'clip_Ox_ymax': clip_Ox_ymax,
            }
        # === 增加0压数据 ===
        clip_out_dict[0] = {
            'clip_Oy_xmin': profile_xmin + 2,
            'clip_Oy_xmax': profile_xmax - 2,
            'clip_Oy_ymin': profile_ymin + 2,
            'clip_Oy_ymax': profile_ymax - 2,
            'clip_Ox_xmin': clip_Ox_xmin,
            'clip_Ox_xmax': clip_Ox_xmax,
            'clip_Ox_ymin': profile_ymin + 2,
            'clip_Ox_ymax': profile_ymax - 2
        }
        # # --长边clip板外坐标定义
        # clip_Oy_xmin = profile_xmin - 5
        # clip_Oy_xmax = profile_xmax + 5
        # clip_Oy_ymin = profile_ymin - 5
        # clip_Oy_ymax = profile_ymax + 5
        #
        #
        # clip_Ox_ymin = profile_ymin - 5
        # clip_Ox_ymax = profile_ymax + 5
        # --20210118新规则,所有板层同六层板
        # --20210209内层铺铜，四层板仍然要求距锣边1mm
        # if job_signal_numbers == 4:
        #     # --四层板距锣边(profile)1mm
        #     clip_Oy_xmin = profile_xmin + (profile_xmax - rout_x)*0.5 + 1
        #     clip_Oy_xmax = profile_xmax - (profile_xmax - rout_x)*0.5 - 1
        #     clip_Oy_ymin = profile_ymin + (profile_ymax - rout_y)*0.5 + 1
        #     clip_Oy_ymax = profile_ymax - (profile_ymax - rout_y)*0.5 - 1
        #     clip_Ox_ymin = profile_ymin + (profile_ymax - rout_y)*0.5 + 1
        #     clip_Ox_ymax = profile_ymax - (profile_ymax - rout_y)*0.5 - 1
        # --计算长边偏移值
        long_offset_top = 0
        # --注意bot只是在top面的基础上再偏移1.5(默认,后面会调整)
        long_offset_bot = 3
        long_side_top = sr_xmin - 2.5 - clip_Oy_xmin
        long_side_bot = sr_xmin - 2.5 - clip_Oy_xmin + long_offset_bot
        long_model_top = long_side_top % 6.5
        long_model_bot = long_side_bot % 6.5
        long_model_top = float('%.3f' % long_model_top)
        long_model_bot = float('%.3f' % long_model_bot)
        # --最内侧铜皮保留(封口)宽度
        long_revise_top = 5
        long_revise_bot = 5 - long_offset_bot

        # --计算短边偏移值
        short_offset_top = 3
        short_offset_bot = 0
        short_side_bot = sr_ymin - 2.5 - clip_Ox_ymin
        short_side_top = sr_ymin - 2.5 - clip_Ox_ymin + short_offset_top
        short_model_bot = short_side_bot % 6.5
        short_model_top = short_side_top % 6.5
        short_model_top = float('%.3f' % short_model_top)
        short_model_bot = float('%.3f' % short_model_bot)
        short_revise_bot = 5
        short_revise_top = 5 - short_offset_top

        # --长边添加pad的x坐标,5.75为fill_ladder_top中心到边缘的距离,以top面为基准
        x1_top = sr_xmin - 5.75 - 2.5 + long_offset_top
        x2_top = sr_xmax + 5.75 + 2.5 - long_offset_top
        x1_bot = sr_xmin - 5.75 - 2.5 + long_offset_bot
        x2_bot = sr_xmax + 5.75 + 2.5 - long_offset_bot
        # --短边添加pad的y坐标,以bot面为基准
        y1_bot = sr_ymin - 5.75 - 2.5 + short_offset_bot
        y2_bot = sr_ymax + 5.75 + 2.5 - short_offset_bot
        y1_top = sr_ymin - 5.75 - 2.5 + short_offset_top
        y2_top = sr_ymax + 5.75 + 2.5 - short_offset_top
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        for side in ('top', 'bot'):
            if side == 'top':
                layer_y = 'ladder_y_top'
                layer_x = 'ladder_x_top'
                # === TODO 此处应为列表 ===
                layer = 'ladder_top'
                sym = 'fill_ladder_top'
                x1 = x1_top
                x2 = x2_top
                # --设置clip参数使长短边交汇处平齐
                clip_Ox_xmin = sr_xmin - 2.5 - long_revise_top
                clip_Ox_xmax = sr_xmax + 2.5 + long_revise_top
                # --top面短边靠近板内做3.5mm
                y1 = y1_top
                y2 = y2_top
            else:
                layer_y = 'ladder_y_bot'
                layer_x = 'ladder_x_bot'
                layer = 'ladder_bot'
                sym = 'fill_ladder_bot'
                # --bot面长边靠近板内做3.5mm
                x1 = x1_bot
                x2 = x2_bot
                y1 = y1_bot
                y2 = y2_bot
                # --设置clip参数使长短边交汇处平齐
                clip_Ox_xmin = sr_xmin - 2.5 - long_revise_bot
                clip_Ox_xmax = sr_xmax + 2.5 + long_revise_bot
            self.create_tmp_layer(layer_y)
            self.create_tmp_layer(layer_x)
            for cur_lamin_num in clip_out_dict.keys():
                self.create_tmp_layer('%s%s' % (layer, cur_lamin_num))
            self.GEN.WORK_LAYER(layer_y)
            self.GEN.SEL_DELETE()
            # --定义长边添加symbol的参数
            nx = int(long_side_top / lenth) + 2
            ny = int((profile_ymax - profile_ymin) / width) + 2
            y = (profile_ymax - profile_ymin) / 2 - (ny - 1) * width / 2
            dx = lenth * 1000
            dy = width * 1000
            self.GEN.ADD_PAD(x1, y, sym, nx=nx, ny=ny, dx=-dx, dy=dy)
            self.GEN.ADD_PAD(x2, y, sym, nx=nx, ny=ny, dx=dx, dy=dy)
            # print "long_model_top",long_model_top
            # print "long_model_bot",long_model_bot
            # self.GEN.PAUSE("add long pad")
            # --长边板内clip
            self.GEN.COM("clip_area_strt")
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_Iy_xmin, clip_Iy_ymin))
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_Iy_xmax, clip_Iy_ymax))
            self.GEN.COM(
                "clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=inside,"
                "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
            # self.GEN.PAUSE("clip pad long inner")
            # --长边板外clip
            for cur_lamin_num in range(0, len(lam_rout)):
                # for item in lam_rout:
                #     if item[0] ==  cur_lamin_num:
                self.GEN.COM("clip_area_strt")
                # self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_Oy_xmin, clip_Oy_ymin))
                # self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_Oy_xmax, clip_Oy_ymax))
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (
                    clip_out_dict[cur_lamin_num]['clip_Oy_xmin'], clip_out_dict[cur_lamin_num]['clip_Oy_ymin']))
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (
                    clip_out_dict[cur_lamin_num]['clip_Oy_xmax'], clip_out_dict[cur_lamin_num]['clip_Oy_ymax']))

                self.GEN.COM(
                    "clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=outside,"
                    "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
                # self.GEN.PAUSE("clip pad long outer")
                self.GEN.SEL_COPY("%s%s" % (layer, cur_lamin_num))
            # --定义短边添加symbol的参数
            ny = int(short_side_bot / lenth) + 2
            nx = int((profile_xmax - profile_xmin) / width) + 2
            dy = lenth * 1000
            dx = width * 1000
            x = (profile_xmax - profile_xmin) / 2 - (nx - 1) * width / 2
            self.GEN.WORK_LAYER(layer_x)
            self.GEN.SEL_DELETE()
            self.GEN.ADD_PAD(x, y1, sym, nx=nx, ny=ny, dx=dx, dy=-dy, angle=90)
            self.GEN.ADD_PAD(x, y2, sym, nx=nx, ny=ny, dx=dx, dy=dy, angle=90)
            # print "short_model_bot",short_model_bot
            # print "short_model_top",short_model_top
            # self.GEN.PAUSE("add short pad")
            # --短边板内clip
            self.GEN.COM("clip_area_strt")
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_Ix_xmin, clip_Ix_ymin))
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_Ix_xmax, clip_Ix_ymax))
            self.GEN.COM(
                "clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=inside,"
                "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
            # self.GEN.PAUSE("clip pad short inner")
            # --短边板外clip
            for cur_lamin_num in range(0, len(lam_rout)):
                # for item in lam_rout:
                #     if item[0] ==  cur_lamin_num:
                self.GEN.COM("clip_area_strt")
                # self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_Oy_xmin, clip_Oy_ymin))
                # self.GEN.COM("clip_area_xy,x=%s,y=%s" % (clip_Oy_xmax, clip_Oy_ymax))
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (
                    clip_out_dict[cur_lamin_num]['clip_Ox_xmin'], clip_out_dict[cur_lamin_num]['clip_Ox_ymin']))
                self.GEN.COM("clip_area_xy,x=%s,y=%s" % (
                    clip_out_dict[cur_lamin_num]['clip_Ox_xmax'], clip_out_dict[cur_lamin_num]['clip_Ox_ymax']))

                self.GEN.COM(
                    "clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=outside,"
                    "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
                # self.GEN.PAUSE("clip pad long outer")
                self.GEN.SEL_COPY("%s%s" % (layer, cur_lamin_num))

            # --删除临时层别
            self.GEN.DELETE_LAYER(layer_x)
            self.GEN.DELETE_LAYER(layer_y)
        # self.GEN.PAUSE("check")
        # --通过两次resize,去掉尖角和小于5mil的surface
        for cur_lamin_num in range(0, len(lam_rout)):
            top_layer = 'ladder_top%s' % (cur_lamin_num)
            bot_layer = 'ladder_bot%s' % (cur_lamin_num)
            self.remove_small_surface(size=1000, target_top=top_layer, target_bot=bot_layer)
            # --将梯形铺铜整体化成一整块surface,方便框选其它symbol
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER(top_layer, 'yes')
            self.GEN.AFFECTED_LAYER(bot_layer, 'yes')
            self.GEN.COM('sel_contourize, accuracy=6.35, break_to_islands=no, clean_hole_size=76.2')
            self.GEN.CLEAR_LAYER()
            # --品字形排版sr范围内铺蜂窝铜
            self.copy_sr_honeycomb(target_top=top_layer, target_bot=bot_layer)
            # --排版间距里铺铜条
            for direct in ('horizontal', 'vertical'):
                self.fill_pitch(direct, target_top=top_layer, target_bot=bot_layer)
            # --四角铺铜皮,940,968转角不铺铜皮 === HDI无此要求 ===
            # if self.cusNo not in ('940', '968'):
            self.corner_copper(copper_dis=60, target_top=top_layer, target_bot=bot_layer, cur_lamin_num=cur_lamin_num)
            # --绕内profile一圈添加金线,光电板不需要
            # if not self.parm.is_PHOTOVOLTAIC_board:
            self.add_gold_line(target_top=top_layer, target_bot=bot_layer)
            # --增加属性,方便后续作业
            self.add_attribute(layer=top_layer, attribute='.bit,text=pnl_ladder_cu')
            self.add_attribute(layer=bot_layer, attribute='.bit,text=pnl_ladder_cu')
            self.add_attribute(layer=top_layer, attribute='.string,text=ladder_top')
            self.add_attribute(layer=bot_layer, attribute='.string,text=ladder_bot')
        self.GEN.CLEAR_LAYER()

    def create_honeycomb_sym(self):
        """
        创建蜂窝形状的板边铺铜symbol
        :return:
        :rtype:
        """
        job_signal_numbers = self.parm.job_signal_numbers
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        profile_xmin = self.parm.profile_xmin
        profile_xmax = self.parm.profile_xmax
        profile_ymin = self.parm.profile_ymin
        profile_ymax = self.parm.profile_ymax
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        top_after_margin = self.parm.top_after_margin
        left_after_margin = self.parm.left_after_margin

        lam_rout = self.parm.lam_rout

        # --将蜂窝临时层的内容物copy到正式层然后clip
        self.GEN.CLEAR_LAYER()
        self.create_tmp_layer('honeycomb-tok')
        self.create_tmp_layer('honeycomb-bok')
        for cur_lamin_num in range(len(lam_rout) + 1):
            self.create_tmp_layer('honeycomb-tok%s' % cur_lamin_num)
            self.create_tmp_layer('honeycomb-bok%s' % cur_lamin_num)
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-t,mode=single,affected=yes")
        # --top临时层copy到top_ok
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=honeycomb-tok,invert=no,dx=0,dy=0,"
                     "size=0,x_anchor=0,y_anchor=0,rotation=0,mirror=none")
        # --bot临时层copy到bot_ok
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-b,mode=single,affected=yes")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=honeycomb-bok,invert=no,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none")
        # --切铜参数定义

        # === 使用距离板内2.5mm的铺铜距离，不区分几层板 by Song
        cut_copper_x1 = sr_xmin - 2.5
        cut_copper_y1 = sr_ymin - 2.5
        cut_copper_x2 = sr_xmax + 2.5
        cut_copper_y2 = sr_ymax + 2.5

        clip_out_dict = {}
        for cur_lamin_num in range(len(lam_rout) + 1):
            if cur_lamin_num == 0:
                clip_out_dict[0] = dict(
                    cut_copper_x3=profile_xmin + 2,
                    cut_copper_y3=profile_ymin + 2,
                    cut_copper_x4=profile_xmax - 2,
                    cut_copper_y4=profile_ymax - 2
                )
            else:
                cur_lamin_routx = lam_rout[cur_lamin_num - 1][1]
                cur_lamin_routy = lam_rout[cur_lamin_num - 1][2]
                clip_out_dict[cur_lamin_num] = dict(
                    cut_copper_x3=profile_xmin + (profile_xmax - cur_lamin_routx) * 0.5 + 2,
                    cut_copper_y3=profile_ymin + (profile_ymax - cur_lamin_routy) * 0.5 + 2,
                    cut_copper_x4=profile_xmax - (profile_xmax - cur_lamin_routx) * 0.5 - 2,
                    cut_copper_y4=profile_ymax - (profile_ymax - cur_lamin_routy) * 0.5 - 2)

        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-tok,mode=single,affected=yes")
        self.GEN.COM("affected_layer,name=honeycomb-bok,mode=single,affected=yes")
        # --伸到板内部分进行clip
        self.GEN.COM("clip_area_strt")
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x1, cut_copper_y1))
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x2, cut_copper_y2))
        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=inside,"
                     "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")

        cut_copper_x3 = clip_out_dict[0]['cut_copper_x3']
        cut_copper_y3 = clip_out_dict[0]['cut_copper_y3']
        cut_copper_x4 = clip_out_dict[0]['cut_copper_x4']
        cut_copper_y4 = clip_out_dict[0]['cut_copper_y4']

        # --伸出板外部分进行clip
        self.GEN.COM("clip_area_strt")
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x3, cut_copper_y3))
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x4, cut_copper_y4))
        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=outside,"
                     "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")

        # --品字形sr范围内铺蜂窝铜
        self.copy_sr_honeycomb(target_top='honeycomb-tok', target_bot='honeycomb-bok')
        # --排版间距里铺铜条
        for direct in ('horizontal', 'vertical'):
            self.fill_pitch(direct, target_top='honeycomb-tok', target_bot='honeycomb-bok')
        # --通过两次resize,去掉尖角和小于5mil的surface
        self.remove_small_surface(target_top='honeycomb-tok', target_bot='honeycomb-bok')
        # --四角铺铜皮
        self.corner_copper(target_top='honeycomb-tok', target_bot='honeycomb-bok')
        # --绕内profile一圈添加金线
        self.add_gold_line(target_top='honeycomb-tok', target_bot='honeycomb-bok')

        for cur_lamin_num in range(len(lam_rout) + 1):
            cut_copper_x3 = clip_out_dict[cur_lamin_num]['cut_copper_x3']
            cut_copper_y3 = clip_out_dict[cur_lamin_num]['cut_copper_y3']
            cut_copper_x4 = clip_out_dict[cur_lamin_num]['cut_copper_x4']
            cut_copper_y4 = clip_out_dict[cur_lamin_num]['cut_copper_y4']
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('honeycomb-tok', 'yes')
            self.GEN.AFFECTED_LAYER('honeycomb-bok', 'yes')

            # --伸出板外部分进行clip 放在此位置，避免多次运行
            self.GEN.COM("clip_area_strt")
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x3, cut_copper_y3))
            self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x4, cut_copper_y4))
            self.GEN.COM(
                "clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=outside,"
                "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('honeycomb-tok', 'yes')
            self.GEN.SEL_COPY('honeycomb-tok%s' % cur_lamin_num)
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('honeycomb-bok', 'yes')
            self.GEN.SEL_COPY('honeycomb-bok%s' % cur_lamin_num)
            self.GEN.CLEAR_LAYER()

            self.add_attribute(layer='honeycomb-tok%s' % cur_lamin_num, attribute='surface,text=copper')
            self.add_attribute(layer='honeycomb-bok%s' % cur_lamin_num, attribute='surface,text=copper')
            self.add_attribute(layer='honeycomb-tok%s' % cur_lamin_num, attribute='.string,text=ladder_top')
            self.add_attribute(layer='honeycomb-bok%s' % cur_lamin_num, attribute='.string,text=ladder_bot')
        self.GEN.CLEAR_LAYER()

        # --创建symbol,由于创建symbol会导致在panel查看时移动较卡，所以取消
        # self.GEN.COM("clear_layers")
        # self.GEN.COM("affected_layer,mode=all,affected=no")
        # self.GEN.COM("affected_layer,name=honeycomb-tok,mode=single,affected=yes")
        # self.GEN.COM("sel_create_sym,symbol=panel_symbol_top,x_datum=0,y_datum=0,delete=no,fill_dx=2.54,fill_dy=2.54,"
        #              "attach_atr=no,retain_atr=no")
        #
        # self.GEN.COM("clear_layers")
        # self.GEN.COM("affected_layer,mode=all,affected=no")
        # self.GEN.COM("affected_layer,name=honeycomb-bok,mode=single,affected=yes")
        # self.GEN.COM("sel_create_sym,symbol=panel_symbol_bot,x_datum=0,y_datum=0,delete=no,fill_dx=2.54,fill_dy=2.54,"
        #              "attach_atr=no,retain_atr=no")

    def add_attribute(self, layer=None, attribute=None):
        """
        将铺铜的surface加上属性
        :return:
        :rtype:
        """
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(layer, 'yes')
        self.GEN.COM('cur_atr_reset')
        self.GEN.COM('cur_atr_set,attribute=%s' % attribute)
        self.GEN.COM('sel_change_atr,mode=add')
        self.GEN.COM('cur_atr_reset')
        self.GEN.AFFECTED_LAYER(layer, 'no')

    def create_honeycomb_tmp(self):
        """
        创建蜂窝临时层别
        :return:
        :rtype:
        """
        self.GEN.OPEN_STEP('panel', job=self.JOB)
        self.GEN.CLEAR_LAYER()
        self.create_tmp_layer('honeycomb-t')
        self.create_tmp_layer('honeycomb-b')
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        # --top面与bot面用同样的参数fill
        self.GEN.COM("affected_layer,name=honeycomb-t,mode=single,affected=yes")
        self.GEN.COM("affected_layer,name=honeycomb-b,mode=single,affected=yes")
        self.GEN.COM("fill_params,type=pattern,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,"
                     "use_arcs=yes,symbol=2oz_fw,dx=9.72312,dy=5.588,std_angle=45,std_line_width=254,"
                     "std_step_dist=1270,std_indent=odd,break_partial=yes,cut_prims=yes,outline_draw=no,"
                     "outline_width=0,outline_invert=no")
        # --超出内profile10mm,超出profile也是10mm
        self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-10,step_margin_y=-10,step_max_dist_x=2540,"
                     "step_max_dist_y=2540,sr_margin_x=-10,sr_margin_y=-10,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                     "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        # --top面与bot面错位3.14mm
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-t,mode=single,affected=yes")
        self.GEN.COM("sel_move,dx=3.14,dy=0")

    def get_sr_honeycomb(self):
        """
        sr范围内铺蜂窝铜,品字形拼板才会有
        :return:
        :rtype:
        """
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        # --删除并重新创建临时层别
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.create_tmp_layer('honeycomb-tmp1')
        self.create_tmp_layer('honeycomb-tmp2')
        # --用solid fill tmp1,距内profile 2.5mm,外面超出profile 5mm,以下步骤对品字形排版有用
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-tmp1,mode=single,affected=yes")
        self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,"
                     "use_arcs=yes,symbol=2oz_fw,dx=9.72312,dy=5.588,std_angle=45,std_line_width=254,std_step_dist=1270,"
                     "std_indent=odd,break_partial=yes,cut_prims=yes,outline_draw=no,outline_width=0,outline_invert=no")
        self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-5,step_margin_y=-5,step_max_dist_x=2540,"
                     "step_max_dist_y=2540,sr_margin_x=2.5,sr_margin_y=2.5,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                     "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        # --用solid fill tmp2,铺进板内1000mm,以下步骤对品字形排版有用
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-tmp2,mode=single,affected=yes")
        self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,"
                     "use_arcs=yes,symbol=2oz_fw,dx=9.72312,dy=5.588,std_angle=45,std_line_width=254,std_step_dist=1270,"
                     "std_indent=odd,break_partial=yes,cut_prims=yes,outline_draw=no,outline_width=0,outline_invert=no")
        self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-5,step_margin_y=-5,step_max_dist_x=2540,"
                     "step_max_dist_y=2540,sr_margin_x=-1000,sr_margin_y=-1000,sr_max_dist_x=0,sr_max_dist_y=0,"
                     "nest_sr=no,consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        # --tmp1 copy到tmp2,两者合并得到超出内profile 2.5mm的铺满整个内容物的铜皮
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-tmp1,mode=single,affected=yes")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=honeycomb-tmp2,invert=yes,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none")

        # --对honeycomb-t和honeycomb-b进行clip,保留sr范围内的部分
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-t,mode=single,affected=yes")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=honeycomb-tsr,invert=no,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none")

        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-b,mode=single,affected=yes")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=honeycomb-bsr,invert=no,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none")

        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-tsr,mode=single,affected=yes")
        self.GEN.COM("affected_layer,name=honeycomb-bsr,mode=single,affected=yes")

        # cut_copper_x5 = sr_xmin + 1
        # cut_copper_y5 = sr_ymin + 1
        # cut_copper_x6 = sr_xmax - 1
        # cut_copper_y6 = sr_ymax - 1
        cut_copper_x5 = sr_xmin - 2
        cut_copper_y5 = sr_ymin - 2
        cut_copper_x6 = sr_xmax + 2
        cut_copper_y6 = sr_ymax + 2

        self.GEN.COM("clip_area_strt")
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x5, cut_copper_y5))
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_copper_x6, cut_copper_y6))
        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=outside,"
                     "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")

        # === v2.12 铺铜距离加大后，限位孔角线被覆盖，切掉多余铜 ===
        # === 1.左下
        self.GEN.COM('clip_area_strt')
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin - 2.5),(sr_ymin - 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin + 2.5),(sr_ymin - 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin + 2.5),(sr_ymin)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin),(sr_ymin)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin),(sr_ymin + 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin - 2.5),(sr_ymin + 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin - 2.5),(sr_ymin - 2.5)))
        self.GEN.COM('clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=polygon,inout=inside,contour_cut=no,margin=0,feat_types=surface')
        # === 2.右下
        self.GEN.COM('clip_area_strt')
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax + 2.5),(sr_ymin - 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax - 2.5),(sr_ymin - 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax - 2.5),(sr_ymin)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax),(sr_ymin)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax),(sr_ymin + 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax + 2.5),(sr_ymin + 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax + 2.5),(sr_ymin - 2.5)))
        self.GEN.COM('clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=polygon,inout=inside,contour_cut=no,margin=0,feat_types=surface')
        # === 3.右上
        self.GEN.COM('clip_area_strt')
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax + 2.5),(sr_ymax + 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax - 2.5),(sr_ymax + 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax - 2.5),(sr_ymax)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax),(sr_ymax)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax),(sr_ymax - 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax + 2.5),(sr_ymax - 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmax + 2.5),(sr_ymax + 2.5)))
        self.GEN.COM('clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=polygon,inout=inside,contour_cut=no,margin=0,feat_types=surface')
        # === 4.左上
        self.GEN.COM('clip_area_strt')
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin - 2.5),(sr_ymax + 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin + 2.5),(sr_ymax + 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin + 2.5),(sr_ymax)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin),(sr_ymax)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin),(sr_ymax - 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin - 2.5),(sr_ymax - 2.5)))
        self.GEN.COM('clip_area_xy,x=%s,y=%s' % ((sr_xmin - 2.5),(sr_ymax + 2.5)))
        self.GEN.COM('clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=polygon,inout=inside,contour_cut=no,margin=0,feat_types=surface')


        # --tmp2整体化后copy到honeycomb-tsr和honeycomb-bsr
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-tmp2,mode=single,affected=yes")
        self.GEN.COM("sel_contourize,accuracy=50.8,break_to_islands=yes,clean_hole_size=76.2,clean_hole_mode=x_and_y")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=honeycomb-tsr,invert=yes,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=honeycomb-bsr,invert=yes,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none")
        # --honeycomb-tsr和honeycomb-bsr进行整体化,这几步对品字形排版有用,对正正排版是在做无用功，copy空气到tok和bok
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-tsr,mode=single,affected=yes")
        self.GEN.COM("affected_layer,name=honeycomb-bsr,mode=single,affected=yes")
        # self.GEN.COM("sel_contourize,accuracy=50.8,break_to_islands=yes,clean_hole_size=76.2,clean_hole_mode=x_and_y")
        # --整体化成一整块
        self.GEN.COM("sel_contourize,accuracy=50.8,break_to_islands=no,clean_hole_size=76.2,clean_hole_mode=x_and_y")
        self.GEN.CLEAR_LAYER()

    def copy_sr_honeycomb(self, target_top=None, target_bot=None):
        """
        品字形,sr范围内的蜂窝铜copy到相应层别
        :param target_top: 内层top面
        :param target_bot: 内层bot面
        :return:
        """
        # --分别copy到honeycomb-tok和honeycomb-bok
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-tsr,mode=single,affected=yes")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=%s,invert=no,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none" % target_top)

        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-bsr,mode=single,affected=yes")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=%s,invert=no,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none" % target_bot)

    def remove_small_surface(self, size=431, target_top='honeycomb-tok', target_bot='honeycomb-bok'):
        """
        通过两次resize,去掉尖角和小于5mil的surface
        :return:
        :rtype:
        """
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=%s,mode=single,affected=yes" % target_top)
        self.GEN.COM("affected_layer,name=%s,mode=single,affected=yes" % target_bot)
        if size == 1000:
            if platform.system() == "Windows" or PRODUCT is None:
                # windows环境下,梯形symbol的尖角在resize时没有圆角处理，导致output时报SIP错误
                # 李家兴2019.11.08依据story-view-156修改
                self.GEN.COM('sel_resize,size=-1000,corner_ctl=yes')
                self.GEN.COM('sel_resize,size=1000,corner_ctl=yes')
                self.GEN.COM('fill_params,type=solid,origin_type=datum,solid_type=fill,std_type=line,min_brush=999,'
                             'use_arcs=yes,symbol=,dx=2.54,dy=2.54,std_angle=45,std_line_width=254,std_step_dist=1270,'
                             'std_indent=odd,break_partial=yes,cut_prims=no,outline_draw=no,outline_width=0,outline_invert=no')
                self.GEN.COM('sel_fill')
                self.GEN.FILL_SUR_PARAMS()
                self.GEN.COM('sel_contourize, accuracy=6.35, break_to_islands=no, clean_hole_size=76.2')
            else:
                self.GEN.SEL_RESIZE(-1000)
                self.GEN.SEL_RESIZE(1000)
        else:
            self.GEN.COM("sel_resize,size=-%s,corner_ctl=no" % size)
            self.GEN.COM("sel_resize,size=%s,corner_ctl=no" % size)
            self.GEN.COM('sel_contourize, accuracy=6.35, break_to_islands=no, clean_hole_size=76.2')

    def corner_copper(self, copper_dis=None, target_top='honeycomb-tok', target_bot='honeycomb-bok',
                      cur_lamin_num=None):
        """
        四角铺铜皮
        :return:
        :rtype:
        """
        job_signal_numbers = self.parm.job_signal_numbers
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        top_after_margin = self.parm.top_after_margin
        left_after_margin = self.parm.left_after_margin
        lam_rout = self.parm.lam_rout
        # --切铜参数定义
        # --20210118新规则,所有板层同六层板
        # --20210209内层铺铜，四层板仍然要求距锣边1mm
        if job_signal_numbers == 4:
            if left_after_margin >= 7:
                cut_corner_x1 = sr_xmin - 2.5
                cut_corner_x2 = sr_xmax + 2.5
            else:
                cut_corner_x1 = sr_xmin - 1.5
                cut_corner_x2 = sr_xmax + 1.5
            if top_after_margin >= 7:
                cut_corner_y2 = sr_ymax + 2.5
                cut_corner_y1 = sr_ymin - 2.5
            else:
                cut_corner_y2 = sr_ymax + 1.5
                cut_corner_y1 = sr_ymin - 1.5
        else:
            cut_corner_x1 = sr_xmin - 2.5
            cut_corner_y1 = sr_ymin - 2.5
            cut_corner_x2 = sr_xmax + 2.5
            cut_corner_y2 = sr_ymax + 2.5
        # cut_corner_x1 = sr_xmin - 2.5
        # cut_corner_y1 = sr_ymin - 2.5
        # cut_corner_x2 = sr_xmax + 2.5
        # cut_corner_y2 = sr_ymax + 2.5
        # --四角铺铜皮
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.create_tmp_layer('honeycomb-tmp2')
        self.GEN.COM("affected_layer,name=honeycomb-tmp2,mode=single,affected=yes")
        self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,"
                     "use_arcs=yes,symbol=,dx=2.54,dy=2.54,std_angle=45,std_line_width=254,std_step_dist=1270,"
                     "std_indent=odd,break_partial=yes,cut_prims=no,outline_draw=no,outline_width=0,outline_invert=no")
        # --20210118新规则,所有板层同六层板
        # --20210209内层铺铜，四层板仍然要求距锣边1mm
        if cur_lamin_num:
            for item in lam_rout:
                if item[0] == cur_lamin_num:
                    cur_routx = item[1]
                    cur_routy = item[2]
                    # --四层板距profile(锣边)1mm === HDI距每次锣边 2mm
                    step_margin_x = (profile_xmax - cur_routx) * 0.5 + 2
                    step_margin_y = (profile_ymax - cur_routy) * 0.5 + 2
                    self.GEN.COM("sr_fill,polarity=positive,step_margin_x=%s,step_margin_y=%s,step_max_dist_x=2540,"
                                 "step_max_dist_y=2540,sr_margin_x=0,sr_margin_y=0,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                                 "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no"
                                 % (step_margin_x, step_margin_y))

        else:
            # step_margin_x = '-5'
            # step_margin_y = '-5'
            step_margin_x = 2
            step_margin_y = 2
            self.GEN.COM("sr_fill,polarity=positive,step_margin_x=%s,step_margin_y=%s,step_max_dist_x=2540,"
                         "step_max_dist_y=2540,sr_margin_x=2.5,sr_margin_y=2.5,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                         "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no"
                         % (step_margin_x, step_margin_y))
        # self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-5,step_margin_y=-5,step_max_dist_x=2540,"
        #              "step_max_dist_y=2540,sr_margin_x=2.5,sr_margin_y=2.5,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
        #              "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        self.GEN.COM("clip_area_strt")
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_corner_x1, cut_corner_y1))
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_corner_x2, cut_corner_y2))
        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,"
                     "inout=inside,contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
        # --判断sr距profile够不够55mm.
        enough_dis_y = sr_ymin - profile_ymin
        enough_dis_x = sr_xmin - profile_xmin
        if enough_dis_y <= 55:
            cut_corner_y1 = profile_ymin + 60
            cut_corner_y2 = profile_ymax - 60
            if copper_dis:
                # --梯形板边封角为60mm
                cut_corner_y1 = profile_ymin + copper_dis
                cut_corner_y2 = profile_ymax - copper_dis
        else:
            enough_dis_y = enough_dis_y + 5
            cut_corner_y1 = profile_ymin + enough_dis_y
            cut_corner_y2 = profile_ymax - enough_dis_y
        cut_corner_x1 = profile_xmin - 6
        cut_corner_x2 = profile_xmax + 6
        self.GEN.COM("clip_area_strt")
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_corner_x1, cut_corner_y1))
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_corner_x2, cut_corner_y2))
        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=inside,"
                     "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
        if enough_dis_x <= 55:
            cut_corner_x1 = profile_xmin + 60
            cut_corner_x2 = profile_xmax - 60
        else:
            enough_dis_x = enough_dis_x + 5
            cut_corner_x1 = profile_xmin + enough_dis_x
            cut_corner_x2 = profile_xmax - enough_dis_x
        cut_corner_y1 = profile_ymin - 6
        cut_corner_y2 = profile_ymax + 6
        self.GEN.COM("clip_area_strt")
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_corner_x1, cut_corner_y1))
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (cut_corner_x2, cut_corner_y2))
        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=inside,"
                     "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=%s,invert=no,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none" % target_top)
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=%s,invert=no,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none" % target_bot)

    def add_gold_line(self, target_top=None, target_bot=None):
        """
        绕内profile一圈添加金线
        :return:
        :rtype:
        """
        job_signal_numbers = self.parm.job_signal_numbers
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        pn_eight = self.JOB[7]
        if pn_eight in ['y', 'r', 'l']:
            if job_signal_numbers >= 4:
                line_x1 = sr_xmin - 1.25
                line_x2 = sr_xmin + 15
                line_x3 = sr_xmax - 15
                line_x4 = sr_xmax + 1.25

                line_y1 = sr_ymin - 1.25
                line_y2 = sr_ymin + 15
                line_y3 = sr_ymax - 15
                line_y4 = sr_ymax + 1.25
                self.GEN.COM("clear_layers")
                self.GEN.COM("affected_layer,mode=all,affected=no")
                self.create_tmp_layer('honeycomb-tmp2')
                self.GEN.COM("affected_layer,name=honeycomb-tmp2,mode=single,affected=yes")
                self.GEN.COM(
                    "add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s1500,polarity=positive,bus_num_lines=0,"
                    "bus_dist_by=pitch,bus_distance=0,bus_reference=left" % (line_x1, line_y2, line_x1, line_y3))
                self.GEN.COM(
                    "add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s1500,polarity=positive,bus_num_lines=0,"
                    "bus_dist_by=pitch,bus_distance=0,bus_reference=left" % (line_x4, line_y2, line_x4, line_y3))
                self.GEN.COM(
                    "add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s1500,polarity=positive,bus_num_lines=0,"
                    "bus_dist_by=pitch,bus_distance=0,bus_reference=left" % (line_x2, line_y1, line_x3, line_y1))
                self.GEN.COM(
                    "add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s1500,polarity=positive,bus_num_lines=0,"
                    "bus_dist_by=pitch,bus_distance=0,bus_reference=left" % (line_x2, line_y4, line_x3, line_y4))
                loop_num_y = int((sr_ymax - sr_ymin - 30) / 22)
                loop_num_x = int((sr_xmax - sr_xmin - 30) / 22)
                # --线水平方向
                for i in range(1, loop_num_y + 1):
                    s_pad_y = sr_ymin + 22 * i
                    self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s3000,polarity=negative,"
                                 "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                                 % (profile_xmin, s_pad_y, profile_xmax, s_pad_y))
                # --线垂直方向
                for i in range(1, loop_num_x + 1):
                    s_pad_x = sr_xmin + 22 * i
                    self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=s3000,polarity=negative,"
                                 "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                                 % (s_pad_x, profile_ymin, s_pad_x, profile_ymax))
                self.GEN.COM(
                    "sel_contourize,accuracy=50.8,break_to_islands=yes,clean_hole_size=76.2,clean_hole_mode=x_and_y")
                self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=%s,invert=no,dx=0,dy=0,size=0,"
                             "x_anchor=0,y_anchor=0,rotation=0,mirror=none" % target_top)
                self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=%s,invert=no,dx=0,dy=0,size=0,"
                             "x_anchor=0,y_anchor=0,rotation=0,mirror=none" % target_bot)

    def fill_pitch(self, direct, target_top=None, target_bot=None):
        """
        排版间距之间的铺铜
        :return:
        :rtype:
        """
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        add_eagle_panel = self.parm.add_eagle_panel
        # --solid fill tmp2
        if direct == 'horizontal':
            margin_x = 10
            margin_y = 0.5

            margin2_x = 0
            margin2_y = 2.0
        else:
            margin_y = 10
            margin_x = 0.5

            margin2_y = 0
            margin2_x = 2.0
        self.GEN.CLEAR_LAYER()
        self.GEN.DELETE_LAYER('eagle-clear-pitch')
        if add_eagle_panel == '是':
            if self.GEN.LAYER_EXISTS("eagle-dot-pitch") == 'yes' and self.GEN.LAYER_EXISTS("eagle-clear-pitch") == 'yes':
                self.GEN.COM("copy_layer,source_job=%s,source_step=panel,source_layer=eagle-dot-pitch,"
                         "dest=layer_name,dest_layer=eagle-clear-pitch,mode=append,invert=no" % self.JOB)
                self.GEN.AFFECTED_LAYER('eagle-clear-pitch', 'yes')
                self.GEN.SEL_CHANEG_SYM('s1651')
                self.GEN.CLEAR_LAYER()

        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.create_tmp_layer('honeycomb-tmp1')

        self.create_tmp_layer('honeycomb-tmp2')
        self.create_tmp_layer('honeycomb-tmp3')

        self.create_tmp_layer('honeycomb-tmp4')
        self.create_tmp_layer('honeycomb-tmp5')

        self.GEN.COM("affected_layer,name=honeycomb-tmp2,mode=single,affected=yes")
        self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,"
                     "use_arcs=yes,symbol=2oz_fw,dx=9.72312,dy=5.588,std_angle=45,std_line_width=254,std_step_dist=1270,"
                     "std_indent=odd,break_partial=yes,cut_prims=yes,outline_draw=no,outline_width=0,outline_invert=no")
        self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-5,step_margin_y=-5,step_max_dist_x=2540,"
                     "step_max_dist_y=2540,sr_margin_x=%s,sr_margin_y=%s,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                     "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no"
                     % (margin_x, margin_y))

        # --clip掉板外部分
        self.GEN.COM("clip_area_strt")
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (sr_xmin, sr_ymin))
        self.GEN.COM("clip_area_xy,x=%s,y=%s" % (sr_xmax, sr_ymax))
        self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=manual,area_type=rectangle,inout=outside,"
                     "contour_cut=yes,margin=0,feat_types=line\;pad\;surface\;arc\;text")

        # --solid fill tmp1,以下步骤对品字形排版有用
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-tmp1,mode=single,affected=yes")
        self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,"
                     "use_arcs=yes,symbol=2oz_fw,dx=9.72312,dy=5.588,std_angle=45,std_line_width=254,std_step_dist=1270,"
                     "std_indent=odd,break_partial=yes,cut_prims=yes,outline_draw=no,outline_width=0,outline_invert=no")
        self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-5,step_margin_y=-5,step_max_dist_x=2540,"
                     "step_max_dist_y=2540,sr_margin_x=2.5,sr_margin_y=2.5,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                     "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no")
        # --resize tmp1然后copy到tmp2
        self.GEN.COM("sel_resize,size=4000,corner_ctl=no")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=honeycomb-tmp2,invert=yes,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none")
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=honeycomb-tmp4,invert=no,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none")
        # -- 在tmp5层别铺铜，延step外围 后续此层别被替换为反面外围铜
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('honeycomb-tmp5','yes')
        self.GEN.COM("fill_params,type=solid,origin_type=datum,solid_type=surface,std_type=line,min_brush=25.4,"
                     "use_arcs=yes,symbol=2oz_fw,dx=9.72312,dy=5.588,std_angle=45,std_line_width=254,std_step_dist=1270,"
                     "std_indent=odd,break_partial=yes,cut_prims=yes,outline_draw=no,outline_width=0,outline_invert=no")
        self.GEN.COM("sr_fill,polarity=positive,step_margin_x=-5,step_margin_y=-5,step_max_dist_x=2540,"
                     "step_max_dist_y=2540,sr_margin_x=%s,sr_margin_y=%s,sr_max_dist_x=0,sr_max_dist_y=0,nest_sr=no,"
                     "consider_feat=no,consider_drill=no,consider_rout=no,dest=affected_layers,attributes=no"
                     % (margin2_x, margin2_y))
        self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=honeycomb-tmp4,invert=yes,dx=0,dy=0,size=0,"
                     "x_anchor=0,y_anchor=0,rotation=0,mirror=none")
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER('honeycomb-tmp4','yes')
        # === 让出角线位置
        self.GEN.ADD_PAD(sr_xmin,sr_ymin,'s5000',pol='negative')
        self.GEN.ADD_PAD(sr_xmax,sr_ymin,'s5000',pol='negative')
        self.GEN.ADD_PAD(sr_xmin,sr_ymax,'s5000',pol='negative')
        self.GEN.ADD_PAD(sr_xmax,sr_ymax,'s5000',pol='negative')

        self.GEN.COM("sel_contourize,accuracy=50.8,break_to_islands=yes,clean_hole_size=76.2,clean_hole_mode=x_and_y")
        self.GEN.COM('clip_area_strt')
        self.GEN.COM('clip_area_end,layers_mode=affected_layers,layer=,area=profile,area_type=rectangle,inout=outside,contour_cut=no,margin=0,feat_types=line\;pad\;surface\;arc\;text')
        # === 外围一圈线
        self.GEN.COM("copy_layer,source_job=%s,source_step=panel,source_layer=honeycomb-tmp4,"
                     "dest=layer_name,dest_layer=honeycomb-tmp5,mode=replace,invert=no" % self.JOB)
        # self.GEN.SEL_COPY('honeycomb-tmp2')
        self.GEN.CLEAR_LAYER()

        # --整体化tmp2
        self.GEN.COM("clear_layers")
        self.GEN.COM("affected_layer,mode=all,affected=no")
        self.GEN.COM("affected_layer,name=honeycomb-tmp2,mode=single,affected=yes")
        self.GEN.COM("sel_contourize,accuracy=50.8,break_to_islands=yes,clean_hole_size=76.2,clean_hole_mode=x_and_y")
        self.GEN.SEL_COPY('honeycomb-tmp3')
        # --挑选出排版间距之间的铺铜
        self.GEN.COM("filter_reset,filter_name=popup")
        self.GEN.COM("filter_set,filter_name=popup,update_popup=no,feat_types=surface")
        self.GEN.COM("filter_set,filter_name=popup,update_popup=no,polarity=positive")
        self.GEN.COM("affected_layer,name=honeycomb-tmp4,mode=single,affected=yes")
        self.GEN.FILTER_SELECT()

        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            # === 为区分正反面，增加层别 ===
            self.GEN.COM('sel_clear_feat')
            if add_eagle_panel == '是':
                if self.GEN.LAYER_EXISTS("eagle-clear-pitch") == 'yes':
                    self.GEN.COM("copy_layer,source_job=%s,source_step=panel,source_layer=eagle-clear-pitch,"
                             "dest=layer_name,dest_layer=honeycomb-tmp2,mode=append,invert=yes" % self.JOB)
                    self.GEN.COM("affected_layer,name=honeycomb-tmp2,mode=single,affected=no")

            # === top面 ===
            line_length = 5
            line_gap = 2
            split_length = line_length + line_gap
            gap_sym = 's%s' % (line_gap * 1000)
            # 用线去填充.
            loop_num_y = int((sr_ymax - sr_ymin) / split_length)
            loop_num_x = int((sr_xmax - sr_xmin) / split_length)

            fix_start_x = sr_xmin - 3
            fix_end_x = sr_xmax + 3
            fix_start_y = sr_ymin - 3
            fix_end_y = sr_ymax + 3
            # --线水平方向
            if direct == 'vertical':
                for i in range(1, loop_num_y + 1):
                    s_pad_y = sr_ymin + split_length * i
                    self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=%s,polarity=negative,"
                                 "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                                 % (fix_start_x, s_pad_y, fix_end_x, s_pad_y, gap_sym))
            # --线垂直方向
            if direct == 'horizontal':
                for i in range(1, loop_num_x + 1):
                    s_pad_x = sr_xmin + split_length * i
                    self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=%s,polarity=negative,"
                                 "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                                 % (s_pad_x, fix_start_y, s_pad_x, fix_end_y, gap_sym))
                # === V2.00 按需求3689 取消 ===
                # gold_finger_c = self.JOB[7]
                # if gold_finger_c == "n":
                #     self.GEN.COM ("sel_delete")


            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('honeycomb-tmp2','yes')
            self.GEN.FILTER_SET_POL(pol='positive')
            self.GEN.FILTER_SELECT()
            if self.GEN.GET_SELECT_COUNT():
                self.GEN.FILTER_RESET()
                self.GEN.COM("filter_area_end,layer=,filter_name=popup,operation=unselect,area_type=none,inside_area=no,intersect_area=no")
                self.GEN.COM("sel_contourize,accuracy=50.8,break_to_islands=yes,clean_hole_size=76.2,clean_hole_mode=x_and_y")
                self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=%s,invert=no,dx=0,dy=0,size=0,"
                             "x_anchor=0,y_anchor=0,rotation=0,mirror=none" % target_top)
            self.GEN.CLEAR_LAYER()

            self.GEN.AFFECTED_LAYER('honeycomb-tmp4','yes')
            self.GEN.FILTER_SET_POL(pol='positive')
            self.GEN.FILTER_SELECT()
            if self.GEN.GET_SELECT_COUNT():
                self.GEN.FILTER_RESET()
                self.GEN.COM("filter_area_end,layer=,filter_name=popup,operation=unselect,area_type=none,inside_area=no,intersect_area=no")
                self.GEN.COM("sel_contourize,accuracy=50.8,break_to_islands=yes,clean_hole_size=76.2,clean_hole_mode=x_and_y")
                self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=%s,invert=no,dx=0,dy=0,size=0,"
                             "x_anchor=0,y_anchor=0,rotation=0,mirror=none" % target_top)
            self.GEN.CLEAR_LAYER()


            self.GEN.AFFECTED_LAYER('honeycomb-tmp3', 'yes')
            self.GEN.AFFECTED_LAYER('honeycomb-tmp5','yes')

            if add_eagle_panel == '是':
                if self.GEN.LAYER_EXISTS("eagle-clear-pitch") == 'yes':
                    self.GEN.COM("copy_layer,source_job=%s,source_step=panel,source_layer=eagle-clear-pitch,"
                             "dest=layer_name,dest_layer=honeycomb-tmp3,mode=append,invert=yes" % self.JOB)
                    self.GEN.AFFECTED_LAYER('honeycomb-tmp3', 'no')

            # === bot 面 ===
            line_length = 5
            line_gap = 2
            split_length = line_length + line_gap
            gap_sym = 's%s' % (line_gap * 1000)
            # 用线去填充.
            loop_num_y = int((sr_ymax - sr_ymin) / split_length)
            loop_num_x = int((sr_xmax - sr_xmin) / split_length)
            fix_start_x = sr_xmin - 3
            fix_end_x = sr_xmax + 3
            fix_start_y = sr_ymin - 3
            fix_end_y = sr_ymax + 3
            # --线水平方向
            if direct == 'vertical':
                for i in range(1, loop_num_y + 1):
                    s_pad_y = sr_ymin + split_length * i - 2
                    self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=%s,polarity=negative,"
                                 "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                                 % (fix_start_x, s_pad_y, fix_end_x, s_pad_y, gap_sym))
            # --线垂直方向
            if direct == 'horizontal':
                for i in range(1, loop_num_x + 1):
                    s_pad_x = sr_xmin + split_length * i - 2
                    self.GEN.COM("add_line,attributes=no,xs=%s,ys=%s,xe=%s,ye=%s,symbol=%s,polarity=negative,"
                                 "bus_num_lines=0,bus_dist_by=pitch,bus_distance=0,bus_reference=left"
                                 % (s_pad_x, fix_start_y, s_pad_x, fix_end_y, gap_sym))
            # === V2.00 按需求3689 取消 ===
            # gold_finger_c = self.JOB[7]
            # if gold_finger_c == "n":
            #     self.GEN.COM ("sel_delete")



            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('honeycomb-tmp3','yes')
            self.GEN.FILTER_SET_POL(pol='positive')
            self.GEN.FILTER_SELECT()
            if self.GEN.GET_SELECT_COUNT():
                self.GEN.COM("filter_area_end,layer=,filter_name=popup,operation=unselect,area_type=none,inside_area=no,intersect_area=no")
                self.GEN.COM("sel_contourize,accuracy=50.8,break_to_islands=yes,clean_hole_size=76.2,clean_hole_mode=x_and_y")
                self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=%s,invert=no,dx=0,dy=0,size=0,x_anchor=0,y_anchor=0,rotation=0,mirror=none" % target_bot)
            self.GEN.FILTER_RESET()
            self.GEN.CLEAR_LAYER()

            self.GEN.AFFECTED_LAYER('honeycomb-tmp5','yes')
            self.GEN.FILTER_SET_POL(pol='positive')
            self.GEN.FILTER_SELECT()
            if self.GEN.GET_SELECT_COUNT():
                self.GEN.COM("filter_area_end,layer=,filter_name=popup,operation=unselect,area_type=none,inside_area=no,intersect_area=no")
                self.GEN.COM("sel_contourize,accuracy=50.8,break_to_islands=yes,clean_hole_size=76.2,clean_hole_mode=x_and_y")
                self.GEN.COM("sel_copy_other,dest=layer_name,target_layer=%s,invert=no,dx=0,dy=0,size=0,x_anchor=0,y_anchor=0,rotation=0,mirror=none" % target_bot)
            self.GEN.FILTER_RESET()
            self.GEN.CLEAR_LAYER()

        # self.GEN.PAUSE('XXXXXXXXXXXXXXXXXXXX')
    def create_tmp_layer(self, layer):
        """
        创建临时层别
        :return:
        :rtype:
        """
        info = self.GEN.DO_INFO('-t layer -e %s/panel/%s -d EXISTS' % (self.JOB, layer))
        if info['gEXISTS'] == "no":
            self.GEN.COM('create_layer,layer=%s,context=misc,type=signal,polarity=positive,ins_layer=' % layer)
        else:
            # --删除当前panel中内容物，这样不用创建新层，其它step中的内容会被保留
            self.GEN.AFFECTED_LAYER(layer, 'yes')
            self.GEN.COM('sel_delete')
            self.GEN.AFFECTED_LAYER(layer, 'no')

    def add_inn_eagle_pad(self):
        """
        在铺铜时已经添加好的层别进行鹰眼pad的copy
        :return:
        """

        fill_array = self.parm.fill_array

        self.GEN.CLEAR_LAYER()
        for fill_hash in fill_array:
            layer_name = fill_hash.layer_name
            layer_mode = fill_hash.layer_mode
            if layer_mode == 'sec':
                if self.GEN.LAYER_EXISTS('song-tmp', job=self.JOB, step='panel') == 'yes':
                    self.GEN.AFFECTED_LAYER('song-tmp', 'yes')
                    self.GEN.SEL_COPY(layer_name)
                self.GEN.CLEAR_LAYER()
                if self.GEN.LAYER_EXISTS('song-create-tmp', job=self.JOB, step='panel') == 'yes':
                    # --song-create-tmp板边的蝴蝶pad
                    self.GEN.AFFECTED_LAYER('song-create-tmp', 'yes')
                    # --删除与外层symbol相连接的鹰眼pad
                    self.GEN.FILTER_RESET()
                    self.GEN.SEL_REF_FEAT(layer_name, 'disjoint', f_type='line;pad;arc;text')
                    if int(self.GEN.GET_SELECT_COUNT()) > 0:
                        self.GEN.SEL_COPY(layer_name)
                self.GEN.CLEAR_LAYER()
        # === pad eagle
        self.GEN.DELETE_LAYER('song-tmp')
        self.GEN.DELETE_LAYER('song-create-tmp')


class out_word(STATIC_SYM):
    """
    外层文字备注信息
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        sh_site = self.parm.sh_site
        put_copper_out = self.parm.put_copper_out
        profile_ymax = self.parm.profile_ymax
        sr_xmax = self.parm.sr_xmax
        # 得到外层标签symbol坐标.
        out_word_x = sr_xmax + 3.5
        out_word_y = profile_ymax * 0.5 - 48
        if sh_site in ['胜宏三厂', '胜宏四厂', '胜宏五厂', '胜宏六厂']:
            # --三、四厂、五厂、六厂设计时，执行清除无用的Symbol,见del_unuse_symbol
            return info
        if put_copper_out == "no":
            # 2019.11.28李家兴依据story-view-690取消正片流程外层文字备注信息，防止掉膜碎,针对第三条目，常规板，只要是负片流程均删除
            info = {
                '外层c': self.convert_to_dict(x_list=[out_word_x], y_list=[out_word_y], symbol='sh-xh',
                                            polarity='negative',
                                            angle=270, mirror='no'),
                '外层s': self.convert_to_dict(x_list=[out_word_x], y_list=[out_word_y], symbol='sh-xh',
                                            polarity='negative',
                                            angle=90, mirror='yes'),
            }
            return info
        # --外层铺铜时，返回空字典
        return info


class silk_color(DYNAMIC_SYM):
    """
    文字颜色标示,因为小板边会与对位symbol重叠,所以改成动态symbol添加
    """
    priority = 16

    def __init__(self, frozen_json=None, avoidArea=None, priority=16):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        profile_ymax = self.parm.profile_ymax
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        sr_width = self.parm.sr_width
        silk_top_color = self.parm.silk_top_color
        silk_bot_color = self.parm.silk_bot_color
        top_lenth = 0
        bot_lenth = 0
        if silk_top_color is not None:
            top_lenth = len(silk_top_color)
        if silk_bot_color is not None:
            bot_lenth = len(silk_bot_color)
        if silk_top_color is None and silk_bot_color is None:
            # --没有文字时
            info = {}
            return info

        max_len = max(top_lenth, bot_lenth)
        rect_lenth = 6
        if max_len == 6:
            rect_width = 13.5
        else:
            rect_width = 18.5
        rect_sym = "rect%sx%s" % (rect_lenth * 1000, rect_width * 1000)
        silk_color_x_org = sr_xmax + 6.5 - rect_lenth / 2
        silk_color_y_org = profile_ymax * 0.5 + 155 + rect_width / 2
        # --可移动范围定义
        area_ymin = sr_ymax - sr_width / 2 + 0.5
        # --最多可以平移到sr_width/3处,防焊对位symbol最多可向下移21mm,原始41.1mm,62.1=41.1+21,5mm安全距离
        area_ymax = sr_ymax - 62.1 - 0.5 - 5
        # --获取长边左侧移动优化后的坐标
        silk_color_x, silk_color_y = self.optimize_coord(rect_sym, x=silk_color_x_org, y=silk_color_y_org,
                                                         area_ymin=area_ymin,
                                                         area_ymax=area_ymax)
        if silk_color_x == silk_color_x_org and silk_color_y == silk_color_y_org:
            # --坐标与优化前相比没有变化,将文字颜色symbol放到下方白油块附近
            # --距离文字白油块10mm
            silk_color_y = sr_ymin + 102 + 0.5 * 2 + rect_width / 2 + 10

        # --c面文字
        oli_color_x_top = silk_color_x
        oli_color_y_top = silk_color_y
        if silk_top_color == '白色':
            sym_top = 'silk_bai_se'
        elif silk_top_color == '黄色':
            sym_top = 'silk_huang_se'
        elif silk_top_color == "黑色":
            sym_top = 'silk_hei_se'
        elif silk_top_color == "红色":
            sym_top = 'silk_hong_se'
        elif silk_top_color == "绿色":
            sym_top = 'silk_lu_se'
        elif silk_top_color == "蓝色":
            sym_top = 'silk_lan_se'
        elif silk_top_color == "粉色":
            sym_top = 'silk_fen_se'
        elif silk_top_color == "橘色":
            sym_top = 'silk_ju_se'
        elif silk_top_color == "灰色":
            sym_top = 'silk_hui_se'
        elif silk_top_color == "亮黑色":
            sym_top = 'silk_liang_hei_se'
        elif silk_top_color == "亮红色":
            sym_top = 'silk_liang_hong_se'
        elif silk_top_color == "雾红色":
            sym_top = 'silk_wu_hong_se'
        elif silk_top_color == "深灰色":
            sym_top = 'silk_shen_hui_se'
        elif silk_top_color == "冷灰色":
            sym_top = 'silk_leng_hui_se'
        elif silk_top_color == "蓝绿色":
            sym_top = 'silk_lan_lu_se'
        else:
            sym_top = None
        # --s面文字
        oli_color_x_bot = oli_color_x_top
        oli_color_y_bot = silk_color_y
        if silk_bot_color == '白色':
            sym_bot = 'silk_bai_se'
        elif silk_bot_color == '黄色':
            sym_bot = 'silk_huang_se'
        elif silk_bot_color == "黑色":
            sym_bot = 'silk_hei_se'
        elif silk_bot_color == "红色":
            sym_bot = 'silk_hong_se'
        elif silk_bot_color == "绿色":
            sym_bot = 'silk_lu_se'
        elif silk_bot_color == "蓝色":
            sym_bot = 'silk_lan_se'
        elif silk_bot_color == "粉色":
            sym_bot = 'silk_fen_se'
        elif silk_bot_color == "橘色":
            sym_bot = 'silk_ju_se'
        elif silk_bot_color == "灰色":
            sym_bot = 'silk_hui_se'
        elif silk_bot_color == "亮黑色":
            sym_bot = 'silk_liang_hei_se'
        elif silk_bot_color == "亮红色":
            sym_bot = 'silk_liang_hong_se'
        elif silk_bot_color == "雾红色":
            sym_bot = 'silk_wu_hong_se'
        elif silk_bot_color == "深灰色":
            sym_bot = 'silk_shen_hui_se'
        elif silk_bot_color == "冷灰色":
            sym_bot = 'silk_leng_hui_se'
        elif silk_bot_color == "蓝绿色":
            sym_bot = 'silk_lan_lu_se'
        else:
            sym_bot = None
        info = {
            'panel_map': self.convert_to_dict(x_list=[silk_color_x], y_list=[silk_color_y], symbol=rect_sym),
            '文字c': self.convert_to_dict(x_list=[oli_color_x_top], y_list=[oli_color_y_top], symbol=sym_top,
                                        angle=270, mirror='no'),
            '文字s': self.convert_to_dict(x_list=[oli_color_x_bot], y_list=[oli_color_y_bot], symbol=sym_bot,
                                        angle=90, mirror='yes'),
        }
        return info


class silk_auto_dw_sym(DYNAMIC_SYM):
    """
    文字自动对位symbol
    """
    priority = 2.4

    def __init__(self, frozen_json=None, avoidArea=None, priority=2.4):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        # 添加文字自动对位symbol.
        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        sel_finger = self.parm.sel_finger
        add_first_plant = self.parm.add_first_plant
        add_hj_panel = self.parm.add_hj_panel
        add_px_panel = self.parm.add_px_panel
        silk_auto_dwx1 = sr_xmin - 3.5
        silk_auto_dwx2 = sr_xmax + 3.5
        silk_auto_dwy1 = sr_ymin + 15 + 25 + 2.5 + 12
        silk_auto_dwy2 = sr_ymax - 15
        if sel_finger == '是' and add_first_plant == "no":
            silk_auto_dwy2 = sr_ymax - 15 - 4

        silk_auto_dwx2, silk_auto_dwy2 = self.optimize_static('s3650', x_org=silk_auto_dwx2, y_org=silk_auto_dwy2,
                                                              area_ymin=(sr_ymax * 2 / 3), area_ymax=(sr_ymax - 15))

        silk_auto_dwx1, silk_auto_dwy1 = self.optimize_static('s3650', x_org=silk_auto_dwx1, y_org=silk_auto_dwy1,
                                                              area_ymin=(sr_ymax * 1 / 3), area_ymax=(sr_ymin + 15))
        flow_content = self.parm.flow_content
        put_copper_out = self.parm.put_copper_out
        put_copper_md = self.parm.put_copper_md

        # --生成坐标列表
        silk_auto_xlist = [silk_auto_dwx1, silk_auto_dwx2]
        silk_auto_ylist = [silk_auto_dwy1, silk_auto_dwy2]
        # --生成info
        # if put_copper_out == 'yes' and flow_content == '一次铜':
        #     # --替换sh_silk_autodw为sh_silk_autodw_2020，边框15mil,防止卡板切铜时切断symbol
        #     outer_sym = 'sh_silk_autodw_2020'
        # else:
        outer_sym = 'sh_silk_autodw'
        # 周涌通知去对位pad 2024.7.22 -ynh
        info = {}
        # info = {
        #     '文字': self.convert_to_dict(x_list=silk_auto_xlist, y_list=silk_auto_ylist, symbol='sh-dwsd2014'),
        #     '外层': self.convert_to_dict(x_list=silk_auto_xlist, y_list=silk_auto_ylist, symbol=outer_sym),
        #     '防焊': self.convert_to_dict(x_list=silk_auto_xlist, y_list=silk_auto_ylist, symbol='r2516'),
        # }
        if put_copper_md == 'no':
            # --档点不铺铜时,文字自动对位点处铺方块
            info['档点'] = self.convert_to_dict(x_list=silk_auto_xlist, y_list=silk_auto_ylist, symbol='s3280')
        # if add_hj_panel == "是" or add_px_panel == "是":
        #     info['文字'].extend (self.convert_to_dict (x_list=silk_auto_xlist, y_list=silk_auto_ylist, symbol='r1000'))
        info['选化'] = self.convert_to_dict(x_list=silk_auto_xlist, y_list=silk_auto_ylist, symbol='s4178',
                                          polarity='negative')
        return info


class zheng_zi(STATIC_SYM):
    """
    防焊正字
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        return {}
        # http://192.168.2.120:82/zentao/story-view-4941.html
        # 1，防焊板边料号名旁边有正字样，目前都是不用菲林的不需要此字样 20221130 by lyh
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        sr_xmax = self.parm.sr_xmax
        zheng_word_x = sr_xmax + 3.5
        zheng_word_y = profile_ymax * 0.5 + 105

        info = {
            '防焊c': self.convert_to_dict(x_list=[zheng_word_x], y_list=[zheng_word_y], symbol='zheng-2016',
                                        angle=270, mirror='no'),
            '防焊s': self.convert_to_dict(x_list=[zheng_word_x], y_list=[zheng_word_y], symbol='zheng-2016',
                                        angle=90, mirror='yes'),
        }
        return info


class sm_outline(STATIC_SYM):
    """
    防焊框线
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = None
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        put_copper_md = self.parm.put_copper_md
        add_first_plant = self.parm.add_first_plant
        profile_xmax = self.parm.profile_xmax
        profile_xmin = self.parm.profile_xmin
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        board_thick = self.parm.board_thick
        sm_outline_ymax = sr_ymax + 2.54
        sm_outline_xmax = sr_xmax + 2.54
        sm_outline_ymin = sr_ymin - 2.54
        sm_outline_xmin = sr_xmin - 2.54
        # sm_outline_xmin2 = sm_outline_xmin + 5.0
        # sm_outline_xmax2 = sm_outline_xmax - 5.0
        # sm_outline_ymin2 = sm_outline_ymin + 5.0
        # sm_outline_ymax2 = sm_outline_ymax - 5.0
        near_sr_xs_list = [sm_outline_xmin, sm_outline_xmax, sm_outline_xmax, sm_outline_xmin]
        near_sr_ys_list = [sm_outline_ymin, sm_outline_ymin, sm_outline_ymax, sm_outline_ymax]
        near_sr_xe_list = [sm_outline_xmax, sm_outline_xmax, sm_outline_xmin, sm_outline_xmin]
        near_sr_ye_list = [sm_outline_ymin, sm_outline_ymax, sm_outline_ymax, sm_outline_ymin]
        # # --20210118王海燕总要求靠内profile的框线只留角落5mm长即可
        # near_sr_xs_list = [sm_outline_xmin,sm_outline_xmax,sm_outline_xmax,sm_outline_xmax,sm_outline_xmax2,sm_outline_xmin2,sm_outline_xmin,sm_outline_xmin]
        # near_sr_ys_list = [sm_outline_ymin,sm_outline_ymin,sm_outline_ymin,sm_outline_ymax,sm_outline_ymax,sm_outline_ymax,sm_outline_ymax,sm_outline_ymin2]
        # near_sr_xe_list = [sm_outline_xmin2,sm_outline_xmax2,sm_outline_xmax,sm_outline_xmax,sm_outline_xmax,sm_outline_xmin,sm_outline_xmin,sm_outline_xmin]
        # near_sr_ye_list = [sm_outline_ymin,sm_outline_ymin,sm_outline_ymin2,sm_outline_ymax2,sm_outline_ymax,sm_outline_ymax,sm_outline_ymax2,sm_outline_ymin]

        on_prof_xs_list = [profile_xmin, profile_xmax, profile_xmax, profile_xmin]
        on_prof_ys_list = [profile_ymin, profile_ymin, profile_ymax, profile_ymax]
        on_prof_xe_list = [profile_xmax, profile_xmax, profile_xmin, profile_xmin]
        on_prof_ye_list = [profile_ymin, profile_ymax, profile_ymax, profile_ymin]
        info = {}
        # # --http://192.168.2.120:82/zentao/story-view-3396.html 取消此框线，防止上金
        # info = {
        #     '防焊': self.convert_to_dict(x_list=near_sr_xs_list,y_list=near_sr_ys_list,xe_list=near_sr_xe_list,
        #                                ye_list=near_sr_ye_list,symbol='r254'),
        # }
        # # --http://192.168.2.120:82/zentao/story-view-3396.html 取消此框线
        # if put_copper_md == 'no':
        #     # --档点不铺铜时,防焊r254框线copy到档点层
        #     info['档点'] = self.convert_to_dict(x_list=near_sr_xs_list,y_list=near_sr_ys_list,xe_list=near_sr_xe_list,
        #                                ye_list=near_sr_ye_list,symbol='r254')

        return info

    def change_symbol(self):
        board_thick = self.parm.board_thick
        info = {}
        # if math.modf(board_thick) > 0.4:
        if board_thick > 0.4:
            return info
        profile_xmax = self.parm.profile_xmax
        sr_ymax = self.parm.sr_ymax
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_xmin = self.parm.sr_xmin

        sm_outline_ymax = sr_ymax + 2.54
        sm_outline_xmax = sr_xmax + 2.54
        sm_outline_ymin = sr_ymin - 2.54
        sm_outline_xmin = sr_xmin - 2.54

        # --20201015李家兴依据story-view-2035添加，板中心两边45mm需要挖开8mm不开窗

        left_xs = profile_xmax * 0.5 - 45 - 0.25
        left_xe = left_xs - 7.5
        right_xs = profile_xmax * 0.5 + 45 + 0.25
        right_xe = right_xs + 7.5
        upper_y = sm_outline_ymax
        lower_y = sm_outline_ymin
        neg_line_xs_list = [left_xs, right_xs, left_xs, right_xs]
        neg_line_ys_list = [upper_y, upper_y, lower_y, lower_y]
        neg_line_xe_list = [left_xe, right_xe, left_xe, right_xe]
        neg_line_ye_list = [upper_y, upper_y, lower_y, lower_y]
        info = {
            '防焊': self.convert_to_dict(x_list=neg_line_xs_list, y_list=neg_line_ys_list, xe_list=neg_line_xe_list,
                                       ye_list=neg_line_ye_list, symbol='s500', polarity='negative'),
        }
        self.add_symbol(info)


# --文字
class silk_bar(STATIC_SYM):
    """
    添加文字白油块
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        silk_bar_x = sr_xmax + 3.5
        silk_bar_y = sr_ymin + 100
        info = {}
        info['c1'] = self.convert_to_dict(x_list=[silk_bar_x], y_list=[silk_bar_y], symbol='s4000')
        info['cc'] = self.convert_to_dict(x_list=[silk_bar_x], y_list=[silk_bar_y], symbol='s4000')
        return info


class twice_wz(STATIC_SYM):
    """
    二次文字板边添加标识
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        twice_wz_panel = self.parm.twice_wz_panel
        fir_silk_station = self.parm.fir_silk_station
        sec_silk_station = self.parm.sec_silk_station
        thd_silk_station = self.parm.thd_silk_station
        L_margin = self.parm.L_margin
        R_margin = self.parm.R_margin
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax

        job_signal_numbers = self.parm.job_signal_numbers

        if twice_wz_panel == '否':
            return info
        if job_signal_numbers == 2:
            # === 2021.09.03 双面板，锣后尺寸使用板尺寸 ===
            rout_x = profile_xmax
            rout_y = profile_ymax

        cut_x = (profile_xmax - rout_x) * 0.5
        cut_y = (profile_ymax - rout_y) * 0.5
        # === 左下 ===
        # === 为了和pin_donut 避让，写死算法
        if L_margin > 20 and R_margin > 20:
            add_y_value = max(sr_ymin - 4.3 + 5, cut_y + 7.323) - cut_y - 7.323
        else:
            add_y_value = 0
        # fyp_x1 = cut_x + 7.323
        # fyp_y1 = cut_y + 7.323 + add_y_value
        fyp_x1 = cut_x + 7.323
        fyp_y1 = sr_ymin - 4.3 + 25
        # --左上角
        fyp_x2 = cut_x + 7.323
        fyp_y2 = sr_ymax + 4.3 - 25
        # fyp_y2 = profile_ymax - cut_y - 7.323 - add_y_value
        # --右上角
        fyp_x3 = profile_xmax - cut_x - 7.323
        fyp_y3 = sr_ymax + 4.3 - 25
        # fyp_y3 = profile_ymax - cut_y - 7.323 - add_y_value
        # --右下角
        fyp_x4 = profile_xmax - cut_x - 7.323
        fyp_y4 = sr_ymin - 4.3 + 25
        # fyp_y4 = cut_y + 7.323 + add_y_value
        # --上短边中心
        fyp_x5 = profile_xmax * 0.5
        # fyp_y5 = fyp_y2 + add_y_value
        fyp_y5 = profile_ymax - cut_y - 7.323
        # --下短边中心
        fyp_x6 = profile_xmax * 0.5
        # fyp_y6 = fyp_y1 - add_y_value
        fyp_y6 = cut_y + 7.323 
        # --左长边中心
        fyp_x7 = sr_xmin - 3.5
        fyp_y7 = profile_ymax * 0.5
        # --左长边中心
        fyp_x8 = sr_xmax + 3.5
        fyp_y8 = profile_ymax * 0.5

        fyp_x_list = [fyp_x1, fyp_x2, fyp_x3, fyp_x4, fyp_x5, fyp_x6, fyp_x7, fyp_x8]
        fyp_y_list = [fyp_y1, fyp_y2, fyp_y3, fyp_y4, fyp_y5, fyp_y6, fyp_y7, fyp_y8]

        fypl_xs_list = []
        fypl_ys_list = []
        fypl_xe_list = []
        fypl_ye_list = []
        # http://192.168.2.120:82/zentao/story-view-5814.html
        # 白油块距偏移框改为7mil 20230724 by lyh
        for i in range(len(fyp_x_list)):
            s4000_x = fyp_x_list[i]
            s4000_y = fyp_y_list[i]
            line_x1 = s4000_x - 2.2286
            line_x2 = s4000_x + 2.2286
            line_y1 = s4000_y - 2.2286
            line_y2 = s4000_y + 2.2286
            line_x3 = line_x1 + 0.90345
            line_x4 = line_x2 - 0.90345
            line_y3 = line_y1 + 0.90345
            line_y4 = line_y2 - 0.90345
            fypl_xs_list += [line_x1, line_x1, line_x2, line_x2, line_x1, line_x1, line_x2, line_x2]
            fypl_xe_list += [line_x3, line_x1, line_x4, line_x2, line_x3, line_x1, line_x4, line_x2]
            fypl_ys_list += [line_y1, line_y1, line_y1, line_y1, line_y2, line_y2, line_y2, line_y2]
            fypl_ye_list += [line_y1, line_y3, line_y1, line_y3, line_y2, line_y4, line_y2, line_y4]

        two_lc_x = sr_xmax + 3.5
        two_lc_y1 = profile_ymax * 0.5 + 105 + 28 - 1
        two_lc_y2 = profile_ymax * 0.5 + 105 + 28 - 6
        two_lc_y3 = profile_ymax * 0.5 + 105 + 28 - 11

        two_uc_x1 = profile_xmax * 0.5 + 50 + 1
        two_uc_x2 = profile_xmax * 0.5 + 50 + 6
        two_uc_x3 = profile_xmax * 0.5 + 50 + 11
        two_wc_y = profile_ymax - cut_y - 7.323

        two_lc_x_list = [two_lc_x, two_lc_x] + [two_uc_x1,two_uc_x2]
        two_lc_y_list = [two_lc_y1, two_lc_y2] + [two_wc_y,two_wc_y]
        sym1_list = ['num_1', 's4000'] * 2
        sym1_pol = ['positive', 'negative'] * 2
        sym2_list = ['s4000', 'num_2'] * 2
        sym2_pol = ['negative', 'positive'] * 2
        angle_top = [270, 270] + [0,0]
        angle_bot = [90, 90] + [180,180]
        if thd_silk_station == sec_silk_station == '文字印刷':
            two_lc_x_list = [two_lc_x, two_lc_x, two_lc_x] + [two_uc_x1,two_uc_x2,two_uc_x3]
            two_lc_y_list = [two_lc_y1, two_lc_y2, two_lc_y3] + [two_wc_y,two_wc_y,two_wc_y]
            sym1_list = ['num_1', 's4000', 's4000'] * 2
            sym1_pol = ['positive', 'negative', 'negative'] * 2
            sym2_list = ['s4000', 'num_2', 'num_3'] * 2
            sym2_pol = ['negative', 'positive','positive'] * 2
            angle_top = [270, 270, 270] + [0, 0, 0]
            angle_bot = [90, 90, 90] + [180, 180, 180]

        info['c1'] = self.convert_to_dict(x_list=two_lc_x_list, y_list=two_lc_y_list, symbol=sym1_list,
                                          angle=angle_top, polarity=sym1_pol)
        info['c1'].extend(self.convert_to_dict(x_list=fypl_xs_list, y_list=fypl_ys_list, xe_list=fypl_xe_list,
                                               ye_list=fypl_ye_list, symbol='r101.6'))
        # === V2.08 兼容两种层别命名方式 c11|c1-1===
        info['c1-1'] = self.convert_to_dict(x_list=two_lc_x_list, y_list=two_lc_y_list, symbol=sym1_list,
                                          angle=angle_top, polarity=sym1_pol)
        info['c1-1'].extend(self.convert_to_dict(x_list=fypl_xs_list, y_list=fypl_ys_list, xe_list=fypl_xe_list,
                                               ye_list=fypl_ye_list, symbol='r101.6'))
        # --c面二次文字
        info['c1-2'] = self.convert_to_dict(x_list=two_lc_x_list, y_list=two_lc_y_list, symbol=sym2_list,
                                            angle=angle_top, polarity=sym2_pol)
        info['c1-2'].extend(self.convert_to_dict(x_list=fyp_x_list, y_list=fyp_y_list, symbol='s4000'))

        info['c2'] = self.convert_to_dict(x_list=two_lc_x_list, y_list=two_lc_y_list, symbol=sym1_list,
                                          angle=angle_bot, mirror='yes', polarity=sym1_pol)
        info['c2'].extend(self.convert_to_dict(x_list=fypl_xs_list, y_list=fypl_ys_list, xe_list=fypl_xe_list,
                                               ye_list=fypl_ye_list, symbol='r101.6'))
        # === V2.08 兼容两种层别命名方式 c12|c2-1===

        info['c2-1'] = self.convert_to_dict(x_list=two_lc_x_list, y_list=two_lc_y_list, symbol=sym1_list,
                                          angle=angle_bot, mirror='yes', polarity=sym1_pol)
        info['c2-1'].extend(self.convert_to_dict(x_list=fypl_xs_list, y_list=fypl_ys_list, xe_list=fypl_xe_list,
                                               ye_list=fypl_ye_list, symbol='r101.6'))

        # --s面二次文字
        info['c2-2'] = self.convert_to_dict(x_list=two_lc_x_list, y_list=two_lc_y_list, symbol=sym2_list,
                                            angle=angle_bot, mirror='yes', polarity=sym2_pol)
        info['c2-2'].extend(self.convert_to_dict(x_list=fyp_x_list, y_list=fyp_y_list, symbol='s4000'))
        return info


class twice_fh(STATIC_SYM):
    """
    二次防焊板边添加标识
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        sr_xmax = self.parm.sr_xmax
        twice_fh_top = self.parm.twice_fh_top
        profile_ymax = self.parm.profile_ymax
        twice_fh_panel = self.parm.twice_fh_panel
        if twice_fh_panel == '否':
            return info

        two_lc_x = sr_xmax + 3.5
        two_lc_y1 = profile_ymax * 0.5 + 105 + 28 + 13
        two_lc_y2 = profile_ymax * 0.5 + 105 + 28 + 18

        two_lc_x_list = [two_lc_x, two_lc_x]
        two_lc_y_list = [two_lc_y1, two_lc_y2]
        sym1_list = ['num_1', 's4000']
        sym1_pol = ['positive', 'negative']
        sym2_list = ['s4000', 'num_2']
        sym2_pol = ['negative', 'positive']
        angle_top = [90, 90]
        angle_bot = [270, 270]
        info['m1'] = self.convert_to_dict(x_list=two_lc_x_list, y_list=two_lc_y_list, symbol=sym1_list,
                                          angle=angle_top,
                                          polarity=sym1_pol)
        # --c面二次防焊
        info[twice_fh_top] = self.convert_to_dict(x_list=two_lc_x_list, y_list=two_lc_y_list, symbol=sym2_list,
                                                  angle=angle_top, polarity=sym2_pol)
        info['m2'] = self.convert_to_dict(x_list=two_lc_x_list, y_list=two_lc_y_list, symbol=sym1_list,
                                          angle=angle_bot,
                                          mirror='yes', polarity=sym1_pol)
        # --s面二次防焊
        info['m2-2'] = self.convert_to_dict(x_list=two_lc_x_list, y_list=two_lc_y_list, symbol=sym2_list,
                                            angle=angle_bot, mirror='yes', polarity=sym2_pol)
        return info


class md_w_word(STATIC_SYM):
    """
    档点w字
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        return {}
    
        # http://192.168.2.120:82/zentao/story-view-4941.html
        # 档点短边下发的w字样也不需要 20221130 by lyh
        
        sr_ymin = self.parm.sr_ymin
        profile_xmax = self.parm.profile_xmax
        pn_seven = self.JOB[6]
        w_fac_x = profile_xmax * 0.5 + 6
        w_fac_y = sr_ymin - 5
        # --第七码是e的为化金+碳油流程,2021.2.17刘文东要求添加
        if pn_seven in ['g', 'h', 'l', 'e']:
            polarity = 'positive'
        else:
            polarity = 'negative'
        info = {
            '档点': self.convert_to_dict(x_list=[w_fac_x], y_list=[w_fac_y], text='w', x_size=3.5, y_size=3.5,
                                       w_factor=1.25, polarity=polarity, fontname='simplex'),
        }
        return info

class add_xh_text(STATIC_SYM):
    """
    选化一次 二次字样添加 20221123 by lyh V2.14
    """
    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        sr_xmax = self.parm.sr_xmax
        profile_ymax = self.parm.profile_ymax
        pn_seven = self.JOB[6]
        
        if self.parm.linek_flow_1 or \
           self.parm.linek_flow_2:
        
            if pn_seven not in ['h', 'l']:
                xh_word_x = sr_xmax + 4.5
            else:
                xh_word_x = sr_xmax + 4.5 + 1.0406125
                
            xh_word_y = profile_ymax * 0.5 + 48 + 50
            
            polarity = 'negative'
            if self.parm.linek_flow_1:
                info["linek-c-1"] = self.convert_to_dict(x_list=[xh_word_x], y_list=[xh_word_y], symbol="xh_num_1",
                                                    angle=270,
                                                    polarity=polarity)
                info["linek-s-1"] = self.convert_to_dict(x_list=[xh_word_x], y_list=[xh_word_y], symbol="xh_num_1",
                                                    angle=270,mirror="yes", 
                                                    polarity=polarity)
            if self.parm.linek_flow_2:
                info["linek-c-2"] = self.convert_to_dict(x_list=[xh_word_x], y_list=[xh_word_y+12], symbol="xh_num_2",
                                                    angle=270,
                                                    polarity=polarity)
                info["linek-s-2"] = self.convert_to_dict(x_list=[xh_word_x], y_list=[xh_word_y+12], symbol="xh_num_2",
                                                    angle=270,mirror="yes", 
                                                    polarity=polarity)         
        return info

# --蚀刻引线
class sh_op1(STATIC_SYM):
    """
    化金和蚀刻引线层加sh-op1
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        op1_symbol_x = profile_xmax + 4
        op1_symbol_y = profile_ymax * 0.5 + 48
        info = {
            '化金c': self.convert_to_dict(x_list=[op1_symbol_x], y_list=[op1_symbol_y], symbol='sh-op3',
                                        polarity='negative', angle=270, mirror='no'),
            '化金s': self.convert_to_dict(x_list=[op1_symbol_x], y_list=[op1_symbol_y], symbol='sh-op3',
                                        polarity='negative', angle=90, mirror='yes'),
            '蚀刻引线c': self.convert_to_dict(x_list=[op1_symbol_x], y_list=[op1_symbol_y], symbol='sh-op3',
                                          polarity='negative', angle=270, mirror='no'),
            '蚀刻引线s': self.convert_to_dict(x_list=[op1_symbol_x], y_list=[op1_symbol_y], symbol='sh-op3',
                                          polarity='negative', angle=90, mirror='yes'),
            '印选化油c': self.convert_to_dict(x_list=[op1_symbol_x], y_list=[op1_symbol_y], symbol='sh-op3',
                                          polarity='negative', angle=270, mirror='no'),
            '印选化油s': self.convert_to_dict(x_list=[op1_symbol_x], y_list=[op1_symbol_y], symbol='sh-op3',
                                          polarity='negative', angle=90, mirror='yes'),
        }
        # 选化有印油+曝光流程20221123 by lyh V2.14
        if self.parm.xh_xlym:
            sr_xmax = self.parm.sr_xmax
            op1_symbol_x = sr_xmax + 4.5
            op1_symbol_y = profile_ymax * 0.5 + 48   
            info.update({
                'xlym-c': self.convert_to_dict(x_list=[op1_symbol_x], y_list=[op1_symbol_y], symbol='sh-op3',
                                            polarity='negative', angle=270, mirror='no'),                
                
                'xlym-s': self.convert_to_dict(x_list=[op1_symbol_x], y_list=[op1_symbol_y], symbol='sh-op3',
                                            polarity='negative', angle=90, mirror='yes'),
            })
        if self.parm.xh_xlym2:
            sr_xmax = self.parm.sr_xmax
            op1_symbol_x = sr_xmax + 4.5
            op1_symbol_y = profile_ymax * 0.5 + 48   
            info.update({
                'xlym-c-2': self.convert_to_dict(x_list=[op1_symbol_x], y_list=[op1_symbol_y], symbol='sh-op3',
                                            polarity='negative', angle=270, mirror='no'),                
                
                'xlym-s-2': self.convert_to_dict(x_list=[op1_symbol_x], y_list=[op1_symbol_y], symbol='sh-op3',
                                            polarity='negative', angle=90, mirror='yes'),
            })            
            
        return info

# --钻孔
class text_drl_hole(DYNAMIC_SYM):
    """
    料号孔
    """
    priority = 10.1
    
    def __init__(self, frozen_json=None, avoidArea=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def set_attribute(self):
        """
        更改钻字属性
        :return:
        :rtype:
        """
        fill_array = self.parm.fill_array
        out_signael_array = self.parm.out_signal_array
        jx_drill_list = self.parm.jx_drill_list
        burry_list = self.parm.burry_list
        hdi_number = self.JOB[7]
        lr_layer = self.parm.lr_layer
        for jx_drill in jx_drill_list:
            # --m1-2,m7-8机械钻孔
            job_left = self.JOB[0:4]
            job_right = self.JOB[8:13]
            tmp = "-"
            text_content = job_left + tmp + job_right + tmp + jx_drill
            text_content = text_content.upper()
            self.GEN.COM(
                'set_attribute,type=layer,job=%s,name1=panel,name2=%s,name3=,attribute=zuanzi,value=%s,units=inch'
                % (self.JOB, jx_drill, text_content))

        for burry in burry_list:
            # --b27埋孔
            job_left = self.JOB[0:4]
            job_right = self.JOB[8:13]
            tmp = "-"
            # text_content = job_left + tmp + job_right + tmp + burry.replace('-','')
            text_content = job_left + tmp + job_right + tmp + burry
            text_content = text_content.upper()
            self.GEN.COM(
                'set_attribute,type=layer,job=%s,name1=panel,name2=%s,name3=,attribute=zuanzi,value=%s,units=inch'
                % (self.JOB, burry, text_content))
            # --埋孔铝片
            layer = "sz%s.lp" % burry[1:]
            text_tmp = job_left + "-" + job_right
            if hdi_number in ['r', 'f']:
                text_tmp = "wl" + text_tmp
            text_tmp = text_tmp.upper()
            self.GEN.VOF()
            # --层别可能不存在会报错
            self.GEN.COM(
                'set_attribute,type=layer,job=%s,name1=panel,name2=%s,name3=,attribute=zuanzi,value=%s,units=inch'
                % (self.JOB, layer, text_tmp))
            self.GEN.VON()

        # --save_job.pre中的更改钻字,因为genesis环境下可能没有hooks,所以移植到此处
        change_text_drl = ('drl', 'lp', 'sz.lp', 'bd-sz.lpc', 'bd-sz.lps', 'md1', 'md2')
        for layer in change_text_drl:
            ps_job_old3 = self.JOB[0:4]
            ps_job_old4 = self.JOB[8:13]
            text_tmp = ps_job_old3 + "-" + ps_job_old4
            if hdi_number in ['r', 'f']:
                text_tmp = "wl" + text_tmp
            text_tmp = text_tmp.upper()
            self.GEN.VOF()
            self.GEN.COM(
                'set_attribute,type=layer,job=%s,name1=panel,name2=%s,name3=,attribute=zuanzi,value=%s,units=inch'
                % (self.JOB, layer, text_tmp))
            self.GEN.VON()

        # --内层钻字,主要用来识别靶标附近料号名后五码
        text_content = self.JOB[8:13]
        for fill_hash in fill_array:
            layer_name = fill_hash.layer_name
            if layer_name not in out_signael_array:
                self.GEN.COM(
                    'set_attribute,type=layer,job=%s,name1=panel,name2=%s,name3=,attribute=zuanzi,value=%s,units=inch'
                    % (self.JOB, layer_name, text_content))

        if lr_layer:
            # --m12,m78机械钻孔
            job_left = self.JOB[0:4]
            job_right = self.JOB[8:13]
            tmp = "-"
            text_content = job_left + tmp + job_right + tmp + lr_layer
            text_content = text_content.upper()
            self.GEN.COM(
                'set_attribute,type=layer,job=%s,name1=panel,name2=%s,name3=,attribute=zuanzi,value=%s,units=inch'
                % (self.JOB, lr_layer, text_content))

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        put_copper_out = self.parm.put_copper_out
        flow_content = self.parm.flow_content
        top_after_margin = self.parm.top_after_margin
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        profile_xmax = self.parm.profile_xmax
        profile_xmin = self.parm.profile_xmin
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        
        sh_site = self.parm.sh_site
        job_signal_numbers = self.parm.job_signal_numbers
        hdi_number = self.JOB[7]
        add_hj_panel = self.parm.add_hj_panel
        sm_plug_yn = self.parm.SM_PLUG
        resin_plug_yn = self.parm.RESIN_PLUG
        blind_burry_by_lamin = self.parm.blind_burry_by_lamin
        lr_layer = self.parm.lr_layer
        lamination = self.parm.lamination
        sr_width = self.parm.sr_width

        text_dry, text_drx, text_angle = None, None, 0
        if job_signal_numbers <= 4:
            if top_after_margin < 7.5 and sr_xmin > 8:
                text_dry = sr_ymax - 65
                # text_drx = sr_xmin - 6.5 + 0.15
                
                text_drx = sr_xmin - 4 - 3.75
                # http://192.168.2.120:82/zentao/story-view-4965.html 20221220 by lyh
                # 距外形锣边不够5mm时 加到板中间
                if text_drx < profile_xmin + (profile_xmax - rout_x) * 0.5 + 5:
                    text_drx = profile_xmin + sr_xmin * 0.5
                    
                text_angle = 90
            else:
                # text_dry = sr_ymin - 6.5 + 0.15
                text_dry = sr_ymin - 4 - 3.75
                # http://192.168.2.120:82/zentao/story-view-4965.html 20221220 by lyh
                # 距外形锣边不够5mm时 加到板中间
                if text_dry < profile_ymin + (profile_ymax - rout_y) * 0.5 + 5:
                    text_dry = profile_ymin + sr_ymin * 0.5
                    
                text_drx = sr_xmin + 60.96 + 53.34 + 25 - 60
                               
        else:
            # text_dry = sr_ymin - 6.5 + 0.15            
            text_dry = sr_ymin - 4 - 3.75
            # http://192.168.2.120:82/zentao/story-view-4965.html 20221220 by lyh
            # 距外形锣边不够5mm时 加到板中间
            if text_dry < profile_ymin + (profile_ymax - rout_y) * 0.5 + 5:
                text_dry = profile_ymin + sr_ymin * 0.5
                
            text_drx = sr_xmin + 60.96 + 53.34 + 25 - 60
        
        if "-lyh" in self.JOB:
            job = gClasses.Job(self.JOB)
            step = gClasses.Step(job, "panel")
            step.removeLayer("check_area_tmp")
            step.createLayer("check_area_tmp")
        else:
            step = None
            
        text_drx,text_dry = self.get_auto_calc_area(profile_xmin, profile_ymin, sr_xmin, sr_ymin,
                                                    profile_xmax, profile_ymax, rout_x, rout_y,
                                                    "rect125000x3750", step, text_angle, text_drx,
                                                    text_dry)
        
        first_lamin = lamination[0]
        # === 判断是否短边加靶,料号孔X方向避让靶孔 ===
        if first_lamin.BAR4Y1 > sr_width and text_dry < sr_ymin:
            text_drx = max(text_drx, (profile_xmax - first_lamin.BAR4X2) * 0.5 + 2.54 + 5)

        lr_text_drx = text_drx
        lr_text_dry = sr_ymin - 6.5
        # === 埋孔的料号孔，可能情况下，向下错开 ===
        burry_text_dry = text_dry - 3.75
        if burry_text_dry < sr_ymin - top_after_margin:
            burry_text_dry = min(sr_ymin - top_after_margin, text_dry)

        if sr_ymin > 8.5:
            lr_text_dry = 2.5

        lr_layer = None
        tmp_check = [i for i in blind_burry_by_lamin if int(i.cur_yh_num) == 0]
        if len(tmp_check) == 1:
            zero_lamin = tmp_check[0]
            if hasattr(zero_lamin, 'blindLayer'):
                lr_layer = 'lr%s-%s' % (zero_lamin.start_num, zero_lamin.end_num)
        # --二次铜外层挖开外层,0.634425为孔边到孔边距离
        if hdi_number in ['r', 'f']:
            # --参考S985-038A1多加了一个WL在前面
            text_clear_lenth = 2.7178 * 12
        else:
            text_clear_lenth = 2.7178 * 10
        text_clear_width = 3.7846 + 0.1524
        rect_sym_clear = "rect%sx%s" % (text_clear_lenth * 1000, text_clear_width * 1000)
        rect_sym_clear_xh = "rect%sx%s" % (text_clear_lenth * 1000, (text_clear_width + 0.7)* 1000)
        rect_sym = "rect%sx%s" % (text_clear_lenth * 1000 + 1524, text_clear_width * 1000 + 762)
        text_clear_x = text_drx - 0.634425 / 2 + text_clear_lenth / 2
        text_clear_y = text_dry - 0.1524 / 2 + text_clear_width / 2
        if job_signal_numbers <= 4:
            if top_after_margin < 7.5 and sr_xmin > 8:
                text_clear_x = text_drx - 0.1524 / 2 + text_clear_width / 2
                text_clear_y = text_dry + 0.634425 / 2 - text_clear_lenth / 2
        text_clear_angle = text_angle

        # --lp层钻字坐标定义
        text_lpx = profile_xmax * 0.5 - 52
        # text_lpy = sr_ymin - 6.5
        # === V2.10 铝片钻字下移 
        text_lpy = sr_ymin - 19.15
        # === 铝片汉字 ===
        lphz_x = text_lpx - 52
        lphz_y = text_lpy - 2.5

        dq_string = 'DQ $$JOB $$LAYER $$date-mmddyy'
        cus_num = self.JOB[1:4]
        if cus_num == '029' and sh_site == '胜宏四厂':
            text_lpx = profile_xmax * 0.5 + 43
            text_string = 'S $$LAYER $$JOB $$date-mmddyy'
            mirror = "yes"
        else:
            text_string = 'C $$LAYER $$JOB $$date-mmddyy'
            mirror = "no"

        # --生成info,有多个属性时，用分号作分隔符隔开
        attribute = '.canned_text,option=non_plated,int=36;.nomenclature'
        info = {
            '通孔': self.convert_to_dict(x_list=[text_drx], y_list=[text_dry], text='$$zuanzi', x_size=2.7178,
                                       y_size=3.7846,
                                       w_factor=1.4829396009, angle=text_angle, fontname='canned_57',
                                       attribute=attribute),
            '埋孔': self.convert_to_dict(x_list=[text_drx], y_list=[burry_text_dry], text='$$zuanzi', x_size=2.7178,
                                       y_size=3.7846,
                                       w_factor=1.4829396009, angle=text_angle, fontname='canned_57',
                                       attribute=attribute),
            '机械盲孔': self.convert_to_dict(x_list=[text_drx], y_list=[text_dry], text='$$zuanzi', x_size=2.7178,
                                         y_size=3.7846,
                                         w_factor=1.4829396009, angle=text_angle, fontname='canned_57',
                                         attribute=attribute),
            '铝片': self.convert_to_dict(x_list=[text_lpx], y_list=[text_lpy], text=text_string,
                                       x_size=3.048, y_size=4.2672, w_factor=1.6666666269, angle=0,
                                       fontname='canned_57',
                                       mirror=mirror, attribute=attribute),
            '树脂导气': self.convert_to_dict(x_list=[text_lpx], y_list=[text_lpy], text=dq_string,
                                         x_size=3.048, y_size=4.2672, w_factor=1.6666666269, angle=0,
                                         fontname='canned_57',
                                         mirror=mirror, attribute=attribute),
            '埋孔铝片': self.convert_to_dict(x_list=[text_lpx], y_list=[text_lpy], text=text_string,
                                         x_size=3.048, y_size=4.2672, w_factor=1.6666666269, angle=0,
                                         fontname='canned_57',
                                         mirror=mirror, attribute=attribute),
            '埋孔导气': self.convert_to_dict(x_list=[text_lpx], y_list=[text_lpy], text=dq_string,
                                         x_size=3.048, y_size=4.2672, w_factor=1.6666666269, angle=0,
                                         fontname='canned_57',
                                         mirror=mirror, attribute=attribute),
            # '档点':self.convert_to_dict (x_list=[text_drx], y_list=[text_dry], text='$$zuanzi', x_size=2.7178,
            #                             y_size=3.7846,
            #                             w_factor=1.4829396009, angle=text_angle, fontname='canned_57',
            #                             attribute=attribute)
            '档点': self.convert_to_dict(x_list=[text_clear_x], y_list=[text_clear_y], symbol=rect_sym_clear,
                                       polarity='positive', angle=text_clear_angle),
            # 钻字孔也要套开 不下油
            '印选化油': self.convert_to_dict(x_list=[text_clear_x], y_list=[text_clear_y], symbol=rect_sym_clear_xh,
                                       polarity='negative', angle=text_clear_angle)            
        }

        # --二次铜外层挖开铜皮,不挖铜皮,不档油，仍维持原来的做法，小孔油墨不会入孔
        # if add_hj_panel == "是" and put_copper_out == "yes":
        #     # --0.0108为了修正使铜皮平齐
        #     info['外层'] = self.convert_to_dict(x_list=[text_clear_x], y_list=[text_clear_y-0.762/2-0.0108], symbol=rect_sym,
        #                                       polarity='positive', angle=text_clear_angle, attribute=attribute)
        # else:
        #     info['外层'] = []
        # --二次铜外层挖开铜皮,不挖铜皮,不档油，仍维持原来的做法，小孔油墨不会入孔
        # if put_copper_out == 'yes':
        #     info['外层'].extend(self.convert_to_dict(x_list=[text_clear_x],y_list=[text_clear_y],symbol=rect_sym_clear,
        #                                       polarity='negative',angle=text_clear_angle))
        #     info['档点'] = self.convert_to_dict(x_list=[text_clear_x],y_list=[text_clear_y],symbol=rect_sym_clear,
        #                                       polarity='positive',angle=text_clear_angle)

        if lr_layer:  # === 可能为空值，增加判断 ===
            info[lr_layer] = self.convert_to_dict(x_list=[lr_text_drx], y_list=[lr_text_dry], text='$$zuanzi',
                                                  x_size=2.7178,
                                                  y_size=3.7846, w_factor=1.4829396009, angle=text_angle,
                                                  fontname='canned_57',
                                                  attribute=attribute)
        info['sz.lp'] = self.convert_to_dict(x_list=[lphz_x], y_list=[lphz_y], symbol='szhz')
        info['lp'] = self.convert_to_dict(x_list=[lphz_x], y_list=[lphz_y], symbol='fhhz')
        info['埋孔铝片'].extend(self.convert_to_dict(x_list=[lphz_x], y_list=[lphz_y], symbol='szhz'))
        return info
    
    def get_auto_calc_area(self, profile_xmin,profile_ymin,sr_xmin, sr_ymin, 
                           profile_xmax, profile_ymax, rout_x, rout_y, 
                           symbolname, step, angle,add_x,add_y,
                           include_rect_area=[]):
        """先模拟计算所有可以添加的rect区域"""
        
        if angle == 0:
            # 左下角短边
            
            area_xmin = sr_xmin + 40
            area_xmax = profile_xmax - 150
            area_ymax = sr_ymin - 4
            area_ymin = profile_ymin + (profile_ymax - rout_y) * 0.5 + 5
            fx = "X"
            step_x = 0.2
            step_y = -0.2
        else:
            # 左下角长边
            
            area_xmax = sr_xmin - 4
            area_xmin = profile_xmin + (profile_xmax - rout_x) * 0.5 + 5
            area_ymax = profile_ymax - 150
            area_ymin = sr_ymin + 40
            fx = "Y"
            step_x = -0.2
            step_y = 0.2            
        
        if "-lyh" in self.JOB: 
            step.clearAll()
            step.affect("check_area_tmp")
            
        rect_area = self.optimize_coord_find_area_rect(symbolname, x=add_x, y=add_y, area_xmin=area_xmin,
                                                       area_xmax=area_xmax,area_ymin=area_ymin, area_ymax=area_ymax,
                                                       move_fx=fx, move_x_step=step_x, move_y_step=step_y, 
                                                       return_rect="yes",include_rect=include_rect_area,
                                                       four_corner2ll="no",                                            
                                                       step=step, to_feature_size=0.5)
        #测试
        if "-lyh" in self.JOB:
            if rect_area:
                step.clearAll()
                step.affect("check_area_tmp")
                for x, y, rect in rect_area:
                    step.addRectangle(rect.xmin, rect.ymin, rect.xmax, rect.ymax)
                    step.addPad(x, y, symbolname)
                    
        if rect_area:            
            # 周涌通知 取靠近锣边的值
            if len(rect_area) >= 2:
                index = -2
            else:
                index = 0
                
            if angle == 0:                
                x, y , rect = sorted(rect_area, key=lambda x: x[1] * -1)[index]
                return rect.xmin + 0.5, rect.ymin + 0.5
            else:
                x, y , rect = sorted(rect_area, key=lambda x: x[0] * -1)[index]
                return rect.xmin - 0.5, rect.ymin + 0.5
            
        return add_x,add_y
  
    def change_symbol(self):
        """
        防焊塞孔及树脂塞孔层别添加的字样要打散fhhz szhz
        :return:
        :rtype:
        """
        sm_plug_yn = self.parm.SM_PLUG
        resin_plug_yn = self.parm.RESIN_PLUG
        burry_sz_dict = self.parm.burry_sz_dict
        lp_layers = []
        if sm_plug_yn == 'yes':
            lp_layers.append('lp')
        if resin_plug_yn == 'yes':
            lp_layers.append('sz.lp')

        for item in burry_sz_dict:
            lp_layers.append(item.sz_layer)

        self.GEN.CLEAR_LAYER()
        for tmp_lp in lp_layers:
            self.GEN.AFFECTED_LAYER(tmp_lp, 'yes')
            self.GEN.FILTER_RESET()
            self.GEN.FILTER_SET_TYP('pad')
            self.GEN.FILTER_SET_INCLUDE_SYMS('fhhz\;szhz')
            self.GEN.FILTER_SELECT()
            self.GEN.FILTER_RESET()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_BREAK()
            self.GEN.COM('affected_layer,name=%s,mode=single,affected=no' % tmp_lp)


# --内层
class sh_wx(STATIC_SYM):
    """
    经纬向symbol
    """

    def __init__(self, frozen_json=None, priority=3):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        wei_xiang = self.parm.wei_xiang

        if wei_xiang == '纬向X':
            # --20210105刘文东建议向右移35mm
            wx_word_x = profile_xmax * 0.5 + 75 + 35 + 35
            wx_word_y = sr_ymax + 5
            wx_arror_x = wx_word_x - 7.5
            xCoord_list = [wx_word_x, wx_arror_x]
            yCoord_list = [wx_word_y, wx_word_y]
            angle_list = [90, 180]
        else:
            wx_word_y = profile_ymax * 0.5 - 100
            wx_word_x = sr_xmax + 5.5
            wx_arror_y = wx_word_y + 7.5
            xCoord_list = [wx_word_x, wx_word_x]
            yCoord_list = [wx_word_y, wx_arror_y]
            angle_list = [0, 270]

        symbol_list = ['sh-wx', 'sh-kn2013']
        mirror_top = ['no', 'no']
        mirror_bot = ['yes', 'no']
        info = {
            '内层c': self.convert_to_dict(x_list=xCoord_list, y_list=yCoord_list, angle=angle_list, symbol=symbol_list,
                                        mirror=mirror_top),
            '内层s': self.convert_to_dict(x_list=xCoord_list, y_list=yCoord_list, angle=angle_list, symbol=symbol_list,
                                        mirror=mirror_bot),
        }
        return info


class sh_csx_pad(STATIC_SYM):
    """
    添加测试线，测试pad symbol
    """

    def __init__(self, frozen_json=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        core_count = self.parm.core_count
        add_number_y = self.parm.add_number_y
        sr_xmax = self.parm.sr_xmax
        panel_y = self.parm.panel_y
        panel_y_inch = float(panel_y) * 0.03937
        ck_fid_y4 = (panel_y_inch * 0.5 + 1.6877919 - add_number_y) * 25.4
        test_line_x = sr_xmax + 3.429
        test_line_y = ck_fid_y4 + 15
        test_pad_x = test_line_x + 2.159
        test_pad_y = test_line_y + 5.03

        # --坐标list
        coord_x_list = []
        coord_y_list = []
        symbol_list = ['sh-csx', 'sh-ipd']
        if core_count >= 2:
            coord_x_list = [test_line_x, test_pad_x]
            coord_y_list = [test_line_y, test_pad_y]
        angle_list = [270, 0]
        info = {
            '内层': self.convert_to_dict(x_list=coord_x_list, y_list=coord_y_list, angle=angle_list, symbol=symbol_list),
            '辅助层': self.convert_to_dict(x_list=coord_x_list, y_list=coord_y_list, angle=angle_list,
                                        symbol=symbol_list),
        }
        return info


class oz_note(STATIC_SYM):
    """
    添加料号名 层名 铜厚标示.
    """

    def __init__(self, frozen_json=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        job_signal_numbers = self.parm.job_signal_numbers
        if job_signal_numbers == 2:
            return info
        panel_y = self.parm.panel_y
        panel_y_inch = float(panel_y) * 0.03937
        sr_xmax = self.parm.sr_xmax
        add_number_y = self.parm.add_number_y
        md_x = self.parm.mao_pin_x
        md_y = self.parm.mao_pin_y
        core_count = self.parm.core_count
        hdi_num = self.parm.hdi_num
        job_signal_numbers = self.parm.job_signal_numbers
        hdi_contain_tag_layer = self.parm.hdi_contain_tag_layer
        fill_array = self.parm.fill_array
        out_signal_array = self.parm.out_signal_array

        gm_array = self.parm.gm_array

        # sec_gm_starty = gm_array[len(gm_array) - 2].gm_starty
        sec_gm_endx = gm_array[len(gm_array) - 2].gm_endx - 5 - 1.75


        oz_note_job_x1 = sr_xmax + 3.62
        oz_note_job_x2 = oz_note_job_x1 + 1
        note_end_x = max((sr_xmax + 3.62 + 3.81 + 3.81),sec_gm_endx)
        if note_end_x == sec_gm_endx:
            oz_note_job_x1 = note_end_x  - 3.81 - 3.81
            oz_note_job_x2 = oz_note_job_x1 + 1
        rj_dw_y3 = (panel_y_inch * 0.5 - add_number_y) * 25.4
        if core_count >= 2 and hdi_num < 1:
            rj_pad_yc = rj_dw_y3 + 71.6
        else:
            rj_pad_yc = panel_y * 0.5 + 71.6 - add_number_y * 25.4
        # --溶胶Pad大小为12x10,symbol到symbol间距0.5mm
        oz_note_job_y1 = rj_pad_yc + 12.5 + 3.81 / 2
        oz_note_job_y2 = oz_note_job_y1 + 36 - 10
        oz_note_lyr_x1 = oz_note_job_x1 + 3.81
        oz_note_lyr_x2 = oz_note_job_x2 + 3.81
        md_note_x1, md_note_x2 = None, None
        md_note_y1t, md_note_y2t, md_note_y1b, md_note_y2b = None, None, None, None
        # if core_count < 2:
        if len(hdi_contain_tag_layer) == 0:
            # --四层板，不加冲孔tooling,且留边一般较小，不能横向并排添加，只能竖向并列添加
            oz_note_lyr_y2t = oz_note_job_y1 - 3.8
            oz_note_lyr_y1t = oz_note_job_y1 - 26 + 12
            oz_note_lyr_y2b = oz_note_job_y1 - 3.8
            oz_note_lyr_y1b = oz_note_job_y1 - 26 + 12

            sec_oz_note_lyr_y2t = oz_note_lyr_y2t - 5
            sec_oz_note_lyr_y1b = oz_note_lyr_y1b + 5
            
            oz_note_lyr_x1 = oz_note_job_x1
            oz_note_lyr_x2 = oz_note_job_x2
        else:
            # --两张core加冲孔tooling,留边足够横向并排加下三个note
            oz_note_lyr_y1t = oz_note_job_y1
            oz_note_lyr_y2t = oz_note_lyr_y1t + 26 - 12
            oz_note_lyr_y2b = oz_note_job_y2
            oz_note_lyr_y1b = oz_note_lyr_y2b - 26 + 12

            sec_oz_note_lyr_y2t = oz_note_lyr_y1t + 26 - 20
            sec_oz_note_lyr_y1b = oz_note_lyr_y2b - 26 + 20

            md_note_x1 = oz_note_lyr_x1 + 3.81
            md_note_x2 = md_note_x1 + 1
            md_note_y1t = oz_note_job_y1
            # --APE3000 0.25进制时负片盖不住文字,需要加长2.54mm  2022.10.26 V2.12 暂时取消
            # md_note_y2t = md_note_y1t + 18.288 + 2.54
            md_note_y2t = md_note_y1t + 18.288
            md_note_y2b = oz_note_job_y2
            # md_note_y1b = md_note_y2b - 18.288 - 2.54
            md_note_y1b = md_note_y2b - 18.288

        # --定义top面净空线坐标
        line_xs_top_list = [oz_note_job_x1, oz_note_lyr_x1]
        line_xe_top_list = [oz_note_job_x1, oz_note_lyr_x1]
        line_ys_top_list = [oz_note_job_y1, oz_note_lyr_y1t]
        line_ye_top_list = [oz_note_job_y2, oz_note_lyr_y2t]

        sec_line_ye_top_list = [oz_note_job_y2,  sec_oz_note_lyr_y2t]
        # --定义bot面净空线坐标
        line_xs_bot_list = [oz_note_job_x1, oz_note_lyr_x1]
        line_xe_bot_list = [oz_note_job_x1, oz_note_lyr_x1]
        line_ys_bot_list = [oz_note_job_y1, oz_note_lyr_y1b]
        sec_line_ys_bot_list = [oz_note_job_y1, sec_oz_note_lyr_y1b]

        line_ye_bot_list = [oz_note_job_y2, oz_note_lyr_y2b]
        # --定义文字信息
        text_list = ['$$JOB', '$$LAYER 0OZ']
        # --定义文字坐标
        text_x_top_list = [oz_note_job_x2, oz_note_lyr_x2]
        text_y_top_list = [oz_note_job_y1, oz_note_lyr_y1t]
        text_x_bot_list = [oz_note_job_x2, oz_note_lyr_x2]
        text_y_bot_list = [oz_note_job_y2, oz_note_lyr_y2b]
        # if core_count >= 2:
        if len(hdi_contain_tag_layer) > 0:
            # --两张core以上要加铆钉数据,定义铆钉净空线坐标
            md_line_xs_top_list = line_xs_top_list + [md_note_x1]
            md_line_xe_top_list = line_xe_top_list + [md_note_x1]
            md_line_ys_top_list = line_ys_top_list + [md_note_y1t]
            md_line_ye_top_list = line_ye_top_list + [md_note_y2t]
            md_line_xs_bot_list = line_xs_bot_list + [md_note_x1]
            md_line_xe_bot_list = line_xe_bot_list + [md_note_x1]
            md_line_ys_bot_list = line_ys_bot_list + [md_note_y1b]
            md_line_ye_bot_list = line_ye_bot_list + [md_note_y2b]

            # --定义铆钉数据文字
            md_text_list = text_list + ['%sx%s' % (md_x, md_y)]
            # --定义文字坐标
            md_text_x_top_list = text_x_top_list + [md_note_x2]
            md_text_y_top_list = text_y_top_list + [md_note_y1t]
            md_text_x_bot_list = text_x_bot_list + [md_note_x2]
            md_text_y_bot_list = text_y_bot_list + [md_note_y2b]

        for fill_hash in fill_array:
            layer_name = fill_hash.layer_name
            # copper_thick = fill_hash.copper_thick
            # cur_lamin_num = fill_hash.lamin_num
            # upper_name = layer_name.upper()
            layer_mode = fill_hash.layer_mode
            layer_side = fill_hash.layer_side
            if layer_name not in out_signal_array:
                if layer_name not in hdi_contain_tag_layer:
                    if layer_mode != 'inn':
                        tmp_line_ys_bot_list = sec_line_ys_bot_list
                        tmp_line_ye_bot_list = line_ye_bot_list
                        tmp_line_ys_top_list = line_ys_top_list
                        tmp_line_ye_top_list = sec_line_ye_top_list
                    else:
                        tmp_line_ys_bot_list = line_ys_bot_list
                        tmp_line_ye_bot_list = line_ye_bot_list
                        tmp_line_ys_top_list = line_ys_top_list
                        tmp_line_ye_top_list = line_ye_top_list
                    if layer_side == "反":
                        # --生成字典信息,键是层别类型,值是字典
                        info[layer_name] = self.convert_to_dict(x_list=line_xs_bot_list, y_list=tmp_line_ys_bot_list,
                                                                xe_list=line_xe_bot_list,
                                                                ye_list=tmp_line_ye_bot_list, symbol='s3500',
                                                                polarity='negative')
                        info[layer_name].extend(
                            self.convert_to_dict(x_list=text_x_bot_list, y_list=text_y_bot_list, text=text_list,
                                                 x_size='2.032', y_size='2.54', w_factor=1, angle=90, mirror='yes'))
                    elif layer_side == "正":
                        info[layer_name] = self.convert_to_dict(x_list=line_xs_top_list, y_list=tmp_line_ys_top_list,
                                                                xe_list=line_xe_top_list,
                                                                ye_list=tmp_line_ye_top_list, symbol='s3500',
                                                                polarity='negative')

                        info[layer_name].extend(
                            self.convert_to_dict(x_list=text_x_top_list, y_list=text_y_top_list, text=text_list,
                                                 x_size='2.032', y_size='2.54', w_factor=1, angle=270, mirror='no'))
                else:
                    if layer_side == "反":
                        # --生成字典信息,键是层别类型,值是字典
                        info[layer_name] = self.convert_to_dict(x_list=md_line_xs_bot_list, y_list=md_line_ys_bot_list,
                                                                xe_list=md_line_xe_bot_list,
                                                                ye_list=md_line_ye_bot_list, symbol='s3500',
                                                                polarity=['negative','negative','positive'])
                        info[layer_name].extend(
                            self.convert_to_dict(x_list=md_text_x_bot_list, y_list=md_text_y_bot_list,
                                                 text=md_text_list,polarity=['positive','positive','negative'],
                                                 x_size='2.032', y_size='2.54', w_factor=1, angle=90, mirror='yes'))
                    elif layer_side == "正":
                        info[layer_name] = self.convert_to_dict(x_list=md_line_xs_top_list, y_list=md_line_ys_top_list,
                                                                xe_list=md_line_xe_top_list,
                                                                ye_list=md_line_ye_top_list, symbol='s3500',
                                                                polarity=['negative','negative','positive'])

                        info[layer_name].extend(
                            self.convert_to_dict(x_list=md_text_x_top_list, y_list=md_text_y_top_list,
                                                 text=md_text_list,polarity=['positive','positive','negative'],
                                                 x_size='2.032', y_size='2.54', w_factor=1, angle=270, mirror='no'))
        return info

    def change_text(self):
        """
        每个层别的OZ标示都不一样，add_symbol是统一按0OZ添加的，所以每个层别均需要change_text
        :return:
        :rtype:
        """
        job_signal_numbers = self.parm.job_signal_numbers
        if job_signal_numbers == 2:
            # --双面板不需要加oz_note
            return
        fill_array = self.parm.fill_array
        out_signal_array = self.parm.out_signal_array
        for fill_hash in fill_array:
            layer_name = fill_hash.layer_name
            copper_thick = fill_hash.copper_thick
            layer_mode = fill_hash.layer_mode
            cur_lamin_num = fill_hash.lamin_num
            upper_name = layer_name.upper()

            oz_note_old = '%s 0OZ' % upper_name
            oz_note_new = '$$LAYER %s' % copper_thick
            if int(cur_lamin_num) != 0 or layer_mode != 'inn':
                # === 次外层不添加铜厚,非内层时
                oz_note_new = '$$LAYER'
            if not layer_name in out_signal_array:
                self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
                self.GEN.FILTER_RESET()
                self.GEN.COM('filter_set,filter_name=popup,update_popup=no,feat_types=text')
                self.GEN.COM('filter_set,filter_name=popup,update_popup=no,text=*%s*' % oz_note_old)
                self.GEN.COM('filter_area_strt')
                self.GEN.COM('filter_area_end,layer=,filter_name=popup,operation=select,area_type=none,'
                             'inside_area=no,intersect_area=no')
                self.GEN.FILTER_RESET()
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.COM('sel_change_txt,text=%s,x_size=2.032,y_size=2.54,w_factor=1,polarity=positive,'
                                 'mirror=no_change,fontname=standard' % oz_note_new)
                self.GEN.COM('affected_layer,name=%s,mode=single,affected=no' % layer_name)


class rh_mdk(STATIC_SYM):
    """
    溶合块及防爆孔
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        global rj_y_array
        info = {}
        
        # pin_lam模式 不跑此模块
        if self.parm.pan_lam == '是':
            return info
        
        core_count = self.parm.core_count
        pp3_layer = self.parm.pp3_layer
        if core_count < 2 and len(pp3_layer) == 0:
            return info
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        panel_x_inch = float(panel_x) * 0.03937
        panel_y_inch = float(panel_y) * 0.03937
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        profile_xmin = self.parm.profile_xmin
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        md_x = self.parm.mao_pin_x
        md_y = self.parm.mao_pin_y
        add_number_x = self.parm.add_number_x
        add_number_y = self.parm.add_number_y
        L_margin = self.parm.L_margin
        U_margin = self.parm.U_margin
        hdi_num = self.parm.hdi_num
        hdi_jie = self.parm.hdi_jie
        hdi_contain_tag_layer = self.parm.hdi_contain_tag_layer
        # add_rmyt_symbol = self.parm.add_rmyt_symbol
        job_signal_numbers = self.parm.job_signal_numbers
        out_signal_array = self.parm.out_signal_array
        jx_drill_list = self.parm.jx_drill_list
        jx_drill_start = self.parm.jx_drill_start
        jx_drill_end = self.parm.jx_drill_end

        # --PE3000冲孔进制(0.25inch或者0.5inch)
        ape3000_base = self.parm.ape3000_base
        # --冲孔光学点坐标，初始化时是inch单位，此处转换为mm单位
        ck_fid_x1 = self.parm.ck_fid_x1 * 25.4
        core_count = self.parm.core_count
        flow_content = self.parm.flow_content
        put_copper_out = self.parm.put_copper_out
        put_copper_md = self.parm.put_copper_md
        fill_array = self.parm.fill_array

        # --定义xa, xb, ya, yb的长度 : xa->top xb->bot ya->right yb->left
        xa = (md_y - 0.75) * 0.5
        xb = xa
        ya = (md_x - 0.75) * 0.5
        yb = ya

        # --设置溶胶定位孔的坐标.bot->top->left->right
        rj_dw_x1 = (panel_x_inch * 0.5 + 0.47 - add_number_x) * 25.4
        rj_dw_y1 = (panel_y_inch * 0.5 - xb) * 25.4
        rj_dw_y2 = (panel_y_inch * 0.5 + xa) * 25.4

        rj_dw_x3 = (panel_x_inch * 0.5 - yb) * 25.4
        rj_dw_y3 = (panel_y_inch * 0.5 - add_number_y) * 25.4

        rj_dw_x4 = (panel_x_inch * 0.5 + ya) * 25.4
        rj_dw_y4 = (panel_y_inch * 0.5 - add_number_y + 0.18799175) * 25.4

        # # --溶胶定位防呆孔,仅在短边top有，且如果与靶孔重叠时，可以不加，删除处理
        rj_dwfd_x = (panel_x_inch * 0.5 - add_number_x) * 25.4
        rj_dwfd_y = (panel_y_inch * 0.5 + xa) * 25.4

        rj_dw_x_array = [rj_dw_x1, rj_dw_x1, rj_dw_x3, rj_dw_x4, rj_dwfd_x]
        rj_dw_y_array = [rj_dw_y1, rj_dw_y2, rj_dw_y3, rj_dw_y4, rj_dwfd_y]
        # rj_dw_sym_top = ['sh-rj3-t','sh-rj3-t','sh-rj2-t','sh-rj2-t','sh-fdk']
        # rj_dw_sym_bot = ['sh-rj3-b','sh-rj3-b','sh-rj2-b','sh-rj2-b','sh-fdk']
        rj_dw_sym = ['sh-rj3', 'sh-rj3', 'sh-rj2', 'sh-rj2', 'sh-fdk']

        # # --sh-fdk是带c标的防呆孔，正方形，如果距sr大于8.5mm,可以改成chris-rj2-t/b
        # add_chris_rj2_dis = rj_dwfd_y - sr_ymax
        # if add_chris_rj2_dis >= 8.5:
        #     rj_dw_x_array = [rj_dw_x1, rj_dw_x1, rj_dw_x3, rj_dw_x4, rj_dwfd_x, rj_dwfd_x]
        #     rj_dw_y_array = [rj_dw_y1, rj_dw_y2, rj_dw_y3, rj_dw_y4, rj_dwfd_y, rj_dw_y1]
        #     rj_dw_sym_top = ['sh-rj3-t', 'sh-rj3-t', 'sh-rj2-t', 'sh-rj2-t', 'chris-rj2-t','chris-rj2-t']
        #     rj_dw_sym_bot = ['sh-rj3-b', 'sh-rj3-b', 'sh-rj2-b', 'sh-rj2-b', 'chris-rj2-b','chris-rj2-b']
        #
        # if profile_xmax >= 585:
        #     # --板边x大于590时，不加c靶防呆，因为会与靶孔冲突,参考需求http://192.168.2.120:82/zentao/story-view-2002.html
        #     # --参考h52506pncv7a2,将596->585
        #     rj_dw_x_array = [rj_dw_x1, rj_dw_x1, rj_dw_x3, rj_dw_x4]
        #     rj_dw_y_array = [rj_dw_y1, rj_dw_y2, rj_dw_y3, rj_dw_y4]
        #     rj_dw_sym_top = ['sh-rj3-t', 'sh-rj3-t', 'sh-rj2-t', 'sh-rj2-t']
        #     rj_dw_sym_bot = ['sh-rj3-b', 'sh-rj3-b', 'sh-rj2-b', 'sh-rj2-b']

        center_mdk_x_array = []
        center_mdk_y_array = []
        center_mdk_sym_top = []
        center_mdk_sym_bot = []
        if ape3000_base == '0.25inch':
            # --ape3000 0.25inch进制时,溶胶定位槽偏左0.47inch的位置加sh-mdk
            rj_dw_x_array = []
            rj_dw_y_array = []
            rj_dw_sym_top = []
            rj_dw_sym_bot = []
            center_mdk_x_array = [rj_dw_x1 - 0.47 * 25.4, rj_dw_x1 - 0.47 * 25.4, rj_dw_x3, rj_dw_x4]
            center_mdk_y_array = [rj_dw_y1, rj_dw_y2, rj_dw_y3, rj_dw_y4]
            center_mdk_sym_top = ['sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t']
            center_mdk_sym_bot = ['sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b']

        # --inn-pp层添加slot
        if ape3000_base == '0.5inch':
            rj_dw_sym_pp = 'drill_innpp'
            # -------------- 左 ----- 右 ---
            rj_dw_x_pp = [rj_dw_x3, rj_dw_x4]
            rj_dw_y_pp = [rj_dw_y3, rj_dw_y4]
        else:
            # --ape3000 0.25进制的inn-pp层不加slot槽
            rj_dw_sym_pp = None
            rj_dw_x_pp = []
            rj_dw_y_pp = []
        # 非NV系列采用旧熔合机
        # if self.JOB[1:4] in ['a86', 'd10']:
        #     add_new_rhj = True
        # else:
        #     add_new_rhj = False
        # 周涌通知全部采用新热熔机 2024-08-03 ynh
        add_new_rhj = True
        if not add_new_rhj :
            # 旧热熔机
            if L_margin >= 21:
                # --溶胶pad左方块距profile要求8mm,中间方块宽6mmm,距板内大于7mm,21mm留边正好满足距板内6mm,距板外8mm
                rj_pad_x2 = profile_xmin + 6 + 5
                rj_pad_x1 = profile_xmax - 6 - 5
                # 以下赋值测试用
                # rj_pad_x2 = (panel_x - rout_x) / 2 + 3.05
                # rj_pad_x1 = panel_x - (panel_x - rout_x) / 2 - 3.05
            else:
                # --小于21mm时，必须保证距板内7mm
                rj_pad_x2 = sr_xmin - 4.5 - 5
                rj_pad_x1 = sr_xmax + 4.5 + 5
        else:
            # 溶胶pad方块距profile要求5mm ，AV系列新熔合机,电磁热熔机
            rj_pad_x2 = profile_xmin + 5 + 2.5
            rj_pad_x1 = profile_xmax - 5 - 2.5
            rj_pad_short_y2 = profile_ymin + 5 + 2.5
            rj_pad_short_y1 = profile_ymax - 5 - 2.5
            if L_margin < 17:
                rj_pad_x2 = sr_xmin - 4.5 - 5
                rj_pad_x1 = sr_xmax + 4.5 + 5
            if U_margin < 17:
                rj_pad_short_y2 = sr_ymin - 4.5 - 5
                rj_pad_short_y1 = sr_ymax + 4.5 + 5

        # --定义溶胶块坐标
        rj_x_array = []
        rj_y_array = []
        if core_count >= 2 and hdi_num < 1:
            # --多层板,一次压合,两张core及以上，包括辅助层
            # --rj_dw_y3为左侧长边溶胶定位孔的y坐标
            rm_dw_sym_y1 = rj_dw_y3 + 71.6
            rm_dw_sym_y2 = rm_dw_sym_y1 + 65
            rm_dw_sym_y3 = rm_dw_sym_y2 + 65
            rm_dw_sym_y4 = rm_dw_sym_y3 + 65

            # --rj_dw_y3为左侧长边溶胶定位孔的y坐标
            rm_dw_sym_y5 = rj_dw_y3 - 76.4
            rm_dw_sym_y6 = rm_dw_sym_y5 - 65
            rm_dw_sym_y7 = rm_dw_sym_y6 - 65
            rm_dw_sym_y8 = rm_dw_sym_y7 - 65

            # --上下左右共16个
            if panel_y_inch > 20.55:
                # --左右共16个
                rj_y_array = [rm_dw_sym_y1, rm_dw_sym_y2, rm_dw_sym_y3, rm_dw_sym_y4,
                              rm_dw_sym_y5, rm_dw_sym_y6, rm_dw_sym_y7, rm_dw_sym_y8]
            else:
                # --左右共12个
                rj_y_array = [rm_dw_sym_y1, rm_dw_sym_y2, rm_dw_sym_y3,
                              rm_dw_sym_y5, rm_dw_sym_y6, rm_dw_sym_y7]

            # 周涌通知改回左右共16个模式，注释130mm的添加条件
            # if add_new_rhj:
            #     # 新热熔机130mm间距添加
            #     if panel_y_inch > 22.8:
            #         # --左右共8个
            #         rj_y_array = [rm_dw_sym_y2, rm_dw_sym_y4, rm_dw_sym_y6, rm_dw_sym_y8]
            #     else:
            #         # --左右共4个
            #         rj_y_array = [rm_dw_sym_y2, rm_dw_sym_y6]


        else:
            # --10层以下板，左右各10块，总共20块
            rj_pad_y5 = panel_y * 0.5 + 71.6 - add_number_y * 25.4
            rj_pad_y4 = panel_y * 0.5 + 136.6 - add_number_y * 25.4
            rj_pad_y3 = panel_y * 0.5 + 201.6 - add_number_y * 25.4
            rj_pad_y2 = panel_y * 0.5 + 266.6 - add_number_y * 25.4
            # rj_pad_y1 = panel_y * 0.5 - 9.905492*25.4 - add_number_y*25.4

            rj_pad_y6 = panel_y * 0.5 - 76.4 - add_number_y * 25.4
            rj_pad_y7 = panel_y * 0.5 - 141.4 - add_number_y * 25.4
            rj_pad_y8 = panel_y * 0.5 - 206.4 - add_number_y * 25.4
            rj_pad_y9 = panel_y * 0.5 - 271.4 - add_number_y * 25.4
            # rj_pad_y10 = panel_y * 0.5 + 10.094468*25.4 - add_number_y*25.4
            if panel_y_inch > 20.55:
                # --上下左右共16个
                rj_y_array = [rj_pad_y5, rj_pad_y4, rj_pad_y3, rj_pad_y2,
                              rj_pad_y6, rj_pad_y7, rj_pad_y8, rj_pad_y9]
            else:
                # --上下左右共12个
                rj_y_array = [rj_pad_y5, rj_pad_y4, rj_pad_y3,
                              rj_pad_y6, rj_pad_y7, rj_pad_y8]
            # 周涌通知改回左右共16个模式，注释130mm的添加条件
            # if add_new_rhj:
            #     if panel_y_inch > 22.8:
            #         # --左右共8个
            #         rj_y_array = [rj_pad_y4, rj_pad_y2, rj_pad_y7, rj_pad_y9]
            #     else:
            #         # --左右共4个
            #         rj_y_array = [rj_pad_y4,  rj_pad_y7]

        # 短边加4个融合块  已rj_dwfd_x为基准左右各115mm ,
        if add_new_rhj:
            # rj_short_xcent = profile_xmin + (profile_xmax - profile_xmin) / 2
            rj_short_x_array = [rj_dwfd_x - 115, rj_dwfd_x - 115, rj_dwfd_x + 115, rj_dwfd_x + 115]
            # rj_short_x_array = [rj_short_xcent - 100, rj_short_xcent - 100, rj_short_xcent + 100, rj_short_xcent + 100]
            rj_short_y_array = [rj_pad_short_y1, rj_pad_short_y2, rj_pad_short_y1, rj_pad_short_y2]
            rj_short_angle = [90, 270, 90, 270]


        # === V2.07 一张Core 3张pp不加溶胶区，仅添加铆钉孔
        if core_count == 1 and len(pp3_layer) > 0:
            rj_y_array = []

        # --定义防爆孔坐标
        rm_hole_x_list = []
        rm_hole_y_list = [i - 9 for i in rj_y_array]
        rm_hole_nx = 1
        rm_hole_ny = 7
        rm_hole_dx = 0
        rm_hole_dy = 0
        # --左侧
        pad_x2 = rj_pad_x2
        middle_x1 = pad_x2 - 2
        middle_x2 = pad_x2 + 2
        # --右侧
        pad_x1 = rj_pad_x1
        middle_x3 = pad_x1 - 2
        middle_x4 = pad_x1 + 2
        rout_to_pad_x = pad_x2 - (panel_x - rout_x) / 2
        out_rj_sym = 'rect6762x20762'

        # 翟鸣通知 防爆孔只能在融合块中心，外层检测是否被锣到的删除掉 20231110 by lyh
        # http://192.168.2.120:82/zentao/story-view-6182.html
        # if rout_to_pad_x > 5:
        add_fs = 'double'
        rm_hole_nx = 2
        rm_hole_ny = 7
        rm_hole_dx = 4000
        rm_hole_dy = 3000
        # NV系列更改间距
        if add_new_rhj:
            middle_x1 = pad_x2 - 1.5
            middle_x3 = pad_x1 - 1.5
            rm_hole_dx = 3000
            middle_short_x1 = rj_dwfd_x - 115 - 9
            middle_short_x2 = rj_dwfd_x + 115 - 9
            # middle_short_x1 = rj_short_xcent - 100 - 9
            # middle_short_x2 = rj_short_xcent + 100 - 9
            middle_short_y1 = rj_pad_short_y1 + 1.5
            middle_short_y2 = rj_pad_short_y2 + 1.5

        rm_hole_x_list = [middle_x1 for i in rj_y_array]
        rm_hole_x_list.extend([middle_x3 for i in rj_y_array])


        # 如防爆孔未被锣到且距最后一次锣边距离小于8 mil的，可內移到8 mil距离。实际就是防爆孔边要距成型8mil
        if 2.99 < rout_to_pad_x <= 3 + 8 * 0.0254:
            add_fs = 'right'
            middle_x2 = (panel_x - rout_x) / 2 + 1 + 8 * 0.0254
            middle_x3 = panel_x - (panel_x - rout_x) / 2 - (1 + 8 * 0.0254 + 3.5)
            rm_hole_x_list = [middle_x2 for i in rj_y_array]
            rm_hole_x_list.extend([middle_x3 for i in rj_y_array])
            rm_hole_nx = 2
            rm_hole_ny = 7
            rm_hole_dx = 3500
            rm_hole_dy = 3000

        # elif rout_to_pad_x > 1:
        # add_fs = 'right'
        # middle_x2 = (panel_x - rout_x) / 2 + 3.2
        # middle_x3 = panel_x - (panel_x - rout_x) / 2 - 6.7
        # rm_hole_x_list = [middle_x2 for i in rj_y_array]
        # rm_hole_x_list.extend([middle_x3 for i in rj_y_array])
        # rm_hole_nx = 2
        # rm_hole_ny = 7
        # rm_hole_dx = 3500
        # rm_hole_dy = 3000
        # else:
        ## --TODO 提示防爆孔无法避开锣边，但仍然添加，由人员决定是否手动删除
        ## msg_box = msgBox()
        ## msg_box.critical(self, '警告', '长边防暴孔距离成型小于2mm,已经无法避开！', QMessageBox.Ok)
        # msg_dict = {'type': 'critical',
        # 'windowTitle': '警告',
        # 'content': '长边防暴孔距离成型小于2mm,已经无法避开！'}
        # self.msg_array.append(msg_dict)
        # add_fs = 'none'
        # rm_hole_x_list = [middle_x2 for i in rj_y_array]
        # rm_hole_x_list.extend([middle_x3 for i in rj_y_array])
        # rm_hole_nx = 1
        # rm_hole_ny = 7
        # rm_hole_dy = 3000

        rm_hole_y_list.extend(rm_hole_y_list)
        #  添加短边防爆孔
        if add_new_rhj:
            rm_hole_short_x_list = [middle_short_x1, middle_short_x1, middle_short_x2, middle_short_x2]
            rm_hole_short_y_list = [middle_short_y1, middle_short_y2, middle_short_y1, middle_short_y2]

        # --定义铆钉孔坐标
        mdk_x1 = (panel_x_inch * 0.5 - yb) * 25.4
        mdk_x2 = (panel_x_inch * 0.5 - 0.52999894 - add_number_x) * 25.4
        mdk_x3 = (panel_x_inch * 0.5 + ya) * 25.4

        mdk_y1 = (panel_y_inch * 0.5 - xb) * 25.4
        mdk_y2 = (panel_y_inch * 0.5 - 7.5 - add_number_y) * 25.4
        mdk_y3 = (panel_y_inch * 0.5 - 0.52999894 - add_number_y) * 25.4
        mdk_fdy3 = (panel_y_inch * 0.5 - 0.34200719 - add_number_y) * 25.4
        mdk_y4 = (panel_y_inch * 0.5 + 7.5 - add_number_y) * 25.4
        mdk_y5 = (panel_y_inch * 0.5 + xa) * 25.4
        if ape3000_base == '0.25inch':
            # --APE3000 0.25inch进制,上下两铆钉距中心与x方向距中心相等
            mdk_y2 = (panel_y_inch * 0.5 - 7.5 - add_number_y) * 25.4
            mdk_y4 = (panel_y_inch * 0.5 + 7.5 - add_number_y) * 25.4

        # --铆钉孔坐标列表,正常HDI长边三个孔，多层板长边5个孔
        mdk_x_array = [mdk_x1, mdk_x1, mdk_x1, mdk_x2, mdk_x2, mdk_x3, mdk_x3, mdk_x3]
        mdk_y_array = [mdk_y2, mdk_y3, mdk_y4, mdk_y1, mdk_y5, mdk_y2, mdk_fdy3, mdk_y4]
        mdk_top_array = ['hdi1-mdk-t', 'hdi1-mdk-t', 'hdi1-mdk-t', 'hdi1-mdk-t', 'hdi1-mdk-t', 'hdi1-mdk-t',
                         'hdi1-mdk-t', 'hdi1-mdk-t']
        mdk_bot_array = ['hdi1-mdk-b', 'hdi1-mdk-b', 'hdi1-mdk-b', 'hdi1-mdk-b', 'hdi1-mdk-b', 'hdi1-mdk-b',
                         'hdi1-mdk-b', 'hdi1-mdk-b']

        # --定义冲孔对位symbol sh-bb/sh-bb1坐标
        ck_fid_y1 = (panel_y_inch * 0.5 - xb) * 25.4
        ck_fid_y2 = (panel_y_inch * 0.5 + xa) * 25.4
        ck_fid_x2 = ck_fid_x1
        # --冲孔光学点yy方向距sr
        fid_dis_y = sr_ymin - ck_fid_y1
        ck_fid_sym_top_UD = "sh-bb"
        ck_fid_sym_bot_UD = "sh-bb1"
        ck_fid_sym_top_LR = "sh-bb"
        ck_fid_sym_bot_LR = "sh-bb1"
        if fid_dis_y > 6:
            ck_fid_angle1 = 0
            ck_fid_angle2 = 0
        else:
            ck_fid_sym_top_UD = "sh-b2013"
            ck_fid_sym_bot_UD = "sh-b12013"
            ck_fid_angle1 = 90
            ck_fid_angle2 = 270
        ck_fid_x3 = (panel_x_inch * 0.5 - yb) * 25.4
        ck_fid_y3 = (panel_y_inch * 0.5 + 1.499997 - add_number_y) * 25.4
        ck_fid_x4 = (panel_x_inch * 0.5 + ya) * 25.4
        ck_fid_y4 = (panel_y_inch * 0.5 + 1.6877919 - add_number_y) * 25.4
        # --冲孔光学点yy方向距sr
        fid_dis_x = sr_xmin - ck_fid_x3
        if fid_dis_x > 6:
            ck_fid_angle3 = 0
            ck_fid_angle4 = 0
        else:
            ck_fid_sym_top_LR = "sh-b2013"
            ck_fid_sym_bot_LR = "sh-b12013"
            ck_fid_angle3 = 180
            ck_fid_angle4 = 0
        # --冲孔光学点坐标及symbol列表
        ck_fid_x_array = [ck_fid_x1, ck_fid_x2, ck_fid_x3, ck_fid_x4]
        ck_fid_y_array = [ck_fid_y1, ck_fid_y2, ck_fid_y3, ck_fid_y4]
        ck_fid_a_array = [ck_fid_angle1, ck_fid_angle2, ck_fid_angle3, ck_fid_angle4]
        ck_fid_sym_top = [ck_fid_sym_top_UD, ck_fid_sym_top_UD, ck_fid_sym_top_LR, ck_fid_sym_top_LR]
        ck_fid_sym_bot = [ck_fid_sym_bot_UD, ck_fid_sym_bot_UD, ck_fid_sym_bot_LR, ck_fid_sym_bot_LR]

        # --定义rm_rh_sm坐标
        rm_rh_x_array = []
        rm_rh_y_array = []
        rm_rh_symbol = []

        if ape3000_base == '0.25inch':
            # --0.25inch APE3000冲孔时,在slot槽位置加铆钉symbol
            mdk_x_array.extend(center_mdk_x_array)
            mdk_y_array.extend(center_mdk_y_array)
            mdk_top_array.extend(center_mdk_sym_top)
            mdk_bot_array.extend(center_mdk_sym_bot)

        # --多加四个铆钉孔,板边y小于20.55inch时不加,会加到profile外面,ape3000 0.25inch进制的不需要额外添加铆钉
        # == TODO 待审查HDI以下部分 ===
        if core_count >= 2 and hdi_num < 1 and panel_y_inch > 20.55 and ape3000_base == '0.5inch':
            # --多层板, 一次压合, 两张core及以上，包括辅助层
            add_mdk_y1 = rj_dw_y3 + 9.2 * 25.4
            add_mdk_y2 = rj_dw_y3 - 9.2 * 25.4
            mdk_x_array.extend([mdk_x1, mdk_x1, mdk_x3, mdk_x3])
            mdk_y_array.extend([add_mdk_y1, add_mdk_y2, add_mdk_y1, add_mdk_y2])
            mdk_top_array.extend(['sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t'])
            mdk_bot_array.extend(['sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b'])

        # --生成字典信息,键是层别类型,值是字典
        rj_x1_array = [rj_pad_x1 for i in rj_y_array]
        rj_angle_1 = [180 for i in rj_y_array]
        rj_x2_array = [rj_pad_x2 for i in rj_y_array]
        rj_angle_2 = [0 for i in rj_y_array]
        rj_y_array.extend(rj_y_array)
        rj_x_array.extend(rj_x1_array)
        rj_x_array.extend(rj_x2_array)
        rj_angle = rj_angle_1 + rj_angle_2

        # === V2.07 3张PP不添加溶胶区，仅添加铆钉  ===
        if core_count == 1 and len(pp3_layer) > 0:
            rj_y_array = []
            rj_x_array = []
            rj_short_x_array = []
            rj_short_y_array = []
            rm_hole_short_x_list = []
            rm_hole_short_y_list = []

        # --先添加rm_rh_sym,放在最底层
        # 确定需要添加symbol名称,芯板中只要有大于2OZ只加一面-- 应用于新熔合机
        add_rh_symbol = {}
        if add_new_rhj:
            job_sql = self.JOB.upper().split('-')[0] if '-' in self.JOB else self.JOB.upper()
            stack_data = get_StackupData(job_sql)
            for dict in stack_data:
                mrp_name = str(dict['MRP_NAME'])
                if '-' in mrp_name:
                    top_layer = 'l' + str(int(mrp_name.split('-')[1][1:3]))
                    bot_layer = 'l' + str(int(mrp_name.split('-')[1][3:5]))
                else:
                    top_layer = 'l1'
                    bot_layer = 'l{0}'.format(int(self.JOB[4:6]))
                cu_list = []
                for fill_hash in fill_array:
                    copper_thick = fill_hash.copper_thick
                    copper_thick_f = float(copper_thick.strip('OZ').replace('H', '0.5').replace('1/3', '0.33'))
                    if fill_hash.layer_name in [top_layer, bot_layer]:
                        cu_list.append(copper_thick_f)
                cu_2oz = [cu_oz for cu_oz in cu_list if cu_oz > 1.97]
                if len(cu_2oz) > 1:
                    add_rh_symbol[top_layer] = 'et_rj_pad_p'
                    add_rh_symbol[bot_layer] = 'et_rj_pad_n'
                else:
                    add_rh_symbol[top_layer] = 'et_rj_pad_p'
                    add_rh_symbol[bot_layer] = 'et_rj_pad_p'

        for i, layer in enumerate(hdi_contain_tag_layer):
            cur_lyr_add_rj_yn = 'yes'
            # === V1.10 周涌要求外层的辅助层，不添加溶胶区,但需增加PE冲孔
            # === V2.07 周涌又说工艺要求加了cur_lyr_add_rj_yn = 'no' 改为 'yes'避免下次出尔反尔===
            # === 钉钉沟通，暂无需求 ===
            if re.search(r'fz', layer):
                fz_source_layer = 'l%s' % layer.strip('-fz').split('-')[0][1:]
                if fz_source_layer in out_signal_array:
                    cur_lyr_add_rj_yn = 'yes'

            info[layer] = self.convert_to_dict(x_list=rm_rh_x_array, y_list=rm_rh_y_array, symbol=rm_rh_symbol)
            if cur_lyr_add_rj_yn == 'yes':
                if add_new_rhj:
                    key_layer = layer.split('-')[0]
                    rhj_symbol = add_rh_symbol[key_layer]
                else:
                    rhj_symbol = 'chris-rjpad'
                # --添加溶胶块
                # 长边熔合块
                info[layer].extend(
                    self.convert_to_dict(x_list=rj_x_array, y_list=rj_y_array, symbol=rhj_symbol, angle=rj_angle))
                # 短边熔合块
                if add_new_rhj:
                    info[layer].extend(
                        self.convert_to_dict(x_list=rj_short_x_array, y_list=rj_short_y_array, angle=rj_short_angle,
                                             symbol=rhj_symbol))
            # --添加溶胶定位孔
            info[layer].extend(self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=rj_dw_sym,
                                                    attribute='.out_scale'))

            for fill_hash in fill_array:
                layer_name = fill_hash.layer_name
                layer_side = fill_hash.layer_side
                panel_fill = fill_hash.panel_fill
                copper_thick = fill_hash.copper_thick
                copper_thick_f = float(copper_thick.strip('OZ').replace('H', '0.5').replace('1/3', '0.33'))

                if layer_name == layer:
                    if layer_side == "正":
                        # --增加铆钉孔对应的symbol
                        info[layer].extend(
                            self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol=mdk_top_array,
                                                 attribute='.out_scale'))
                        # --增加冲孔光学点
                        info[layer].extend(
                            self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array, symbol=ck_fid_sym_top,
                                                 angle=ck_fid_a_array, attribute='.out_scale'))
                        # === 2021.09.20如果层别铜厚大于2oz，则添加r35mil的光学点pad r889===
                        if copper_thick_f > 1.97:
                            info[layer].extend(
                                self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array, symbol='r889',
                                                     angle=ck_fid_a_array, attribute='.out_scale'))
                    elif layer_side == "反":
                        info[layer].extend(
                            self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol=mdk_bot_array,
                                                 attribute='.out_scale'))

                        info[layer].extend(
                            self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array, symbol=ck_fid_sym_bot,
                                                 angle=ck_fid_a_array, attribute='.out_scale'))
        # info = {
        #     '内层c': self.convert_to_dict(x_list=rm_rh_x_array, y_list=rm_rh_y_array, symbol=rm_rh_symbol),
        #     '内层s': self.convert_to_dict(x_list=rm_rh_x_array, y_list=rm_rh_y_array, symbol=rm_rh_symbol),
        # }
        # --添加溶胶块
        # info['内层c'].extend(self.convert_to_dict(x_list=rj_x_array, y_list=rj_y_array, symbol='chris-rjpad'))
        # info['内层s'].extend(self.convert_to_dict(x_list=rj_x_array, y_list=rj_y_array, symbol='chris-rjpad'))
        if flow_content == '二次铜':
            # --五厂铺铜,请参考a39/142a2
            # if flow_content == '二次铜' or put_copper_out == "yes":
            info['外层'] = self.convert_to_dict(x_list=rj_x_array, y_list=rj_y_array, symbol=out_rj_sym)
        # --选化sgt-c sgt-s板边5mm不盖干膜，防暴孔位置整块套开
        # === V2.09 取消选化层的防爆孔套干膜
        # info['选化'] = self.convert_to_dict(x_list=rj_x_array, y_list=rj_y_array, symbol=out_rj_sym, polarity='negative')

        # # --添加溶胶定位孔
        # info['内层c'].extend(self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=rj_dw_sym))
        # info['内层s'].extend(self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=rj_dw_sym))
        #
        # # --增加铆钉孔对应的symbol
        # info['内层c'].extend(self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol=mdk_top_array))
        # info['内层s'].extend(self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol=mdk_bot_array))

        # ---正常多层料号和HDI料号都一样
        if self.JOB[6] in ['l', 'h']:
            info['通孔'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r4000')
            info['通孔'].extend(self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r6000'))
            if put_copper_md == 'no':
                # --档点不铺铜时,D+20正极性copy到档点
                # --20210301刘文东要求修改为1:1档油
                info['档点'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r6000')
            # --防焊D+20套负片,依据story-view-2735,防止上锡
            info['防焊'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r6508',
                                              polarity='negative')
            # --选化D+20套负片 === V2.09 取消选化层铆钉孔套负片
            # info['选化'].extend(
            #     self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r6508', polarity='negative'))
        else:
            # 周涌通知取消此2.0的孔 20240416 by lyh
            # info['通孔'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r2000')
            info['通孔'] = []

            if put_copper_md == 'no':
                # --档点不铺铜时,D+20正极性copy到档点
                # --20210301刘文东要求修改为1:1档油
                info['档点'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r2000')
            # --选化D+20套负片
            # info['选化'].extend(
            info['选化'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r2508',
                                              polarity='negative')

        # --inn-pp层symbol坐标列表定义
        info['inn-pp'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r3600')
        info['inn-pp'].extend(self.convert_to_dict(x_list=rj_dw_x_pp, y_list=rj_dw_y_pp, symbol=rj_dw_sym_pp))
        
        mai_hole_size = "r1500"
        #http://192.168.2.120:82/zentao/story-view-6860.html 20240726
        #  NV系列四阶以上压合次数多，埋孔防爆孔位置容易缺胶。
        if self.JOB[1:4] in ["a86", "d10"] and hdi_jie > 4:
            mai_hole_size = "r500"
            
        # --添加防爆孔
        clip_2pp = 'no'
        cusNo = self.JOB[1:4]
        # pp2_layer = self.parm.pp2_layer
        # for out_layer in out_signal_array:
        #     if out_layer in pp2_layer:
        #         clip_2pp = 'yes'
        #         break
        if cusNo in ["a11"] and clip_2pp == 'yes':
            # === http://192.168.2.120:82/zentao/story-view-1765.html
            # === A11系列外夹层PP≥2张 取消热熔快上防爆孔
            pass
        else:
            info['通孔'].extend(self.convert_to_dict(x_list=rm_hole_x_list, y_list=rm_hole_y_list, symbol='r2000',
                                                   nx=rm_hole_nx, ny=rm_hole_ny, dx=rm_hole_dx, dy=rm_hole_dy,
                                                   attribute='.string,text=fbk'))
            
            
            info['埋孔'] = self.convert_to_dict(x_list=rm_hole_x_list, y_list=rm_hole_y_list, symbol=mai_hole_size,
                                              nx=rm_hole_nx, ny=rm_hole_ny, dx=rm_hole_dx, dy=rm_hole_dy,
                                              attribute='.string,text=fbk')
            # 加短边防爆孔
            if add_new_rhj:
                info['通孔'].extend(
                    self.convert_to_dict(x_list=rm_hole_short_x_list, y_list=rm_hole_short_y_list, symbol='r2000',
                                         nx=rm_hole_ny, ny=rm_hole_nx, dx=rm_hole_dy, dy=-rm_hole_dx,
                                         attribute='.string,text=fbk'))
                info['埋孔'].extend(
                    self.convert_to_dict(x_list=rm_hole_short_x_list, y_list=rm_hole_short_y_list, symbol=mai_hole_size,
                                         nx=rm_hole_ny, ny=rm_hole_nx, dx=rm_hole_dy, dy=-rm_hole_dx,
                                         attribute='.string,text=fbk'))
            # === TODO V2.0 版本开发如下语句，暂不上线，此种特殊叠构料号不多
            # for i, cur_jx_layer in enumerate (jx_drill_list):
            #     # --考虑到两次埋孔，所以加了个index,坐标顺序是按jx_drill_list的顺序压入数组的，不担心会错乱
            #     layer_start = int (jx_drill_start[i][1:])
            #     layer_end = int (jx_drill_end[i][1:])
            #     # === 非core层钻带不需要更改 ===
            #     if abs (layer_end - layer_start) == 1:
            #         continue
            #     # === V2.00 盲孔加防爆孔C22-006
            #     info[cur_jx_layer] = self.convert_to_dict (x_list=rm_hole_x_list, y_list=rm_hole_y_list, symbol='r1500',
            #                                        nx=rm_hole_nx, ny=rm_hole_ny, dx=rm_hole_dx, dy=rm_hole_dy,
            #                                        attribute='.string,text=fbk')
        if put_copper_md == 'no':
            # --档点不铺铜时,D+20正极性copy到档点
            # --20210301刘文东要求修改为1:1档油
            info['档点'].extend(self.convert_to_dict(x_list=rm_hole_x_list, y_list=rm_hole_y_list, symbol='r2000',
                                                   nx=rm_hole_nx, ny=rm_hole_ny, dx=rm_hole_dx, dy=rm_hole_dy,
                                                   attribute='.string,text=fbk'))

        # # --增加冲孔光学点
        # info['内层c'].extend(self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array, symbol=ck_fid_sym_top,
        #                                         angle=ck_fid_a_array))
        # info['内层s'].extend(self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array, symbol=ck_fid_sym_bot,
        #                                         angle=ck_fid_a_array))
        return info

    def change_symbol(self):
        """
        将inn-pp层添加的symbol打散
        :return:
        :rtype:
        """
        if self.parm.core_count >= 2 and self.parm.ape3000_base == '0.5inch':
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('inn-pp', 'yes')
            self.GEN.COM('sel_break')
            self.GEN.CLEAR_LAYER()

        self.delete_fbk_for_rout_limit()

    def delete_fbk_for_rout_limit(self):
        """删除被修边锣到的防爆孔 20231110
        http://192.168.2.120:82/zentao/story-view-6182.html"""
        job = gClasses.Job(self.JOB)
        step = gClasses.Step(job, "panel")
        step.open()

        worklayer = "drl"
        if step.isLayer(worklayer):
            step.clearAll()
            step.affect(worklayer)
            step.resetFilter()
            step.setAttrFilter(".string,text=fbk")
            step.selectAll()
            if step.featureSelected():
                step.removeLayer(worklayer + "_fbk_tmp")
                step.moveSel(worklayer + "_fbk_tmp")
                panel_x = self.parm.panel_x
                panel_y = self.parm.panel_y
                rout_x = self.parm.rout_x
                rout_y = self.parm.rout_y
                lb_x = (panel_x - rout_x) * 0.5
                lb_y = (panel_y - rout_y) * 0.5
                step.clearAll()
                step.removeLayer("rout_check_surface")
                step.createLayer("rout_check_surface")
                step.affect("rout_check_surface")
                step.reset_fill_params()
                step.addRectangle(lb_x, lb_y, panel_x - lb_x, panel_y - lb_y)

                step.clearAll()
                step.affect(worklayer + "_fbk_tmp")
                step.resetFilter()
                step.setAttrFilter(".string,text=fbk")
                step.refSelectFilter("rout_check_surface", mode="cover")
                step.COM("sel_reverse")
                if step.featureSelected():
                    step.selectDelete()

                step.moveSel(worklayer)
                step.removeLayer(worklayer + "_fbk_tmp")
                step.removeLayer("rout_check_surface")

        step.resetFilter()
        step.clearAll()

class rj_sym(STATIC_SYM):
    """
    http://192.168.2.120:82/zentao/story-view-6789.html
    添加六处的 pin lam 溶胶块及防爆孔添加
    """
    def __init__(self,frozen_json=None,priority=1.2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        STATIC_SYM.__init__(self,priority=priority,avoidType=self.avoidType)

    def get_long_rj_array(self):
        """
        获取长边溶胶块y坐标列表,因为后面多次用到，所以独立出来一个函数
        :return:
        :rtype:
        """
        global rj_y_array

        rj_mapping = {}


        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        add_number_y = self.parm.add_number_y
        core_count = self.parm.core_count
        hdi_num = self.parm.hdi_num
        job_signal_numbers = self.parm.job_signal_numbers
        hdi_contain_tag_layer = self.parm.hdi_contain_tag_layer
        sh_site = self.parm.sh_site
        panel_y_inch = float(panel_y) * 0.03937
        
        L_margin = self.parm.L_margin
        profile_xmin = self.parm.profile_xmin
        profile_xmax = self.parm.profile_xmax
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        # --热溶方式(韩松热溶或者电磁热溶)
        fusion_mode = self.parm.fusion_mode
        
        rj_dw_y3 = (panel_y_inch * 0.5 - add_number_y)*25.4
        #外层流程
        flow_content = self.parm.flow_content
        Flows = eval(self.parm.all_flows)
        # --赋初值
        rj_x_inner = []
        rj_y_inner = []
        rj_x_clear = []
        rj_y_clear = []
        rj_x_outer = []
        rj_y_outer = []
        rj_sym_clear = []
        rj_angle = []
        ###多层溶胶不用hdi形态  梁涛要求 http://192.168.2.120:82/zentao/story-view-5954.html
        #if core_count >= 2 and hdi_num < 1:
        if core_count >= 2 :
            # --多层板,一次压合,两张core及以上，包括辅助层
            # --rj_dw_y3为左侧长边溶胶定位孔的y坐标
            rm_dw_sym_y1 = rj_dw_y3 + 71.6
            rm_dw_sym_y2 = rm_dw_sym_y1 + 65
            rm_dw_sym_y3 = rm_dw_sym_y2 + 65
            rm_dw_sym_y4 = rm_dw_sym_y3 + 65

            # --rj_dw_y3为左侧长边溶胶定位孔的y坐标
            rm_dw_sym_y5 = rj_dw_y3 - 76.4
            rm_dw_sym_y6 = rm_dw_sym_y5 - 65
            rm_dw_sym_y7 = rm_dw_sym_y6 - 65
            rm_dw_sym_y8 = rm_dw_sym_y7 - 65

            # --上下左右共16个
            if panel_y_inch > 20.55:
                # --上下左右共16个
                rj_y_array = [rm_dw_sym_y1, rm_dw_sym_y2, rm_dw_sym_y3, rm_dw_sym_y4,
                              rm_dw_sym_y5, rm_dw_sym_y6, rm_dw_sym_y7, rm_dw_sym_y8]
            else:
                # --上下左右共12个
                rj_y_array = [rm_dw_sym_y1, rm_dw_sym_y2, rm_dw_sym_y3,
                              rm_dw_sym_y5, rm_dw_sym_y6, rm_dw_sym_y7]
        else:
            # --一般为HDI形态
            if job_signal_numbers >= 10:
                # --10层及以上板,左右各8块，总共16块
                rj_pad_y5 = panel_y * 0.5 - 71.6
                rj_pad_y4 = panel_y * 0.5 - 136.6
                rj_pad_y3 = panel_y * 0.5 - 201.6
                rj_pad_y2 = panel_y * 0.5 - 266.6

                rj_pad_y6 = panel_y * 0.5 + 76.4
                rj_pad_y7 = panel_y * 0.5 + 141.4
                rj_pad_y8 = panel_y * 0.5 + 206.4
                rj_pad_y9 = panel_y * 0.5 + 271.4
                if panel_y_inch > 20.55:
                    # --上下左右共16个
                    rj_y_array = [rj_pad_y5, rj_pad_y4, rj_pad_y3, rj_pad_y2,
                                  rj_pad_y6, rj_pad_y7, rj_pad_y8, rj_pad_y9]
                else:
                    # --上下左右共12个
                    rj_y_array = [rj_pad_y5, rj_pad_y4, rj_pad_y3,
                                  rj_pad_y6, rj_pad_y7, rj_pad_y8]
            else:
                # --10层以下板，左右各10块，总共20块
                rj_pad_y5 = panel_y * 0.5 - 2.818892*25.4 - add_number_y*25.4
                rj_pad_y4 = panel_y * 0.5 - 4.590542*25.4 - add_number_y*25.4
                rj_pad_y3 = panel_y * 0.5 - 6.362192*25.4 - add_number_y*25.4
                rj_pad_y2 = panel_y * 0.5 - 8.133842*25.4 - add_number_y*25.4
                rj_pad_y1 = panel_y * 0.5 - 9.905492*25.4 - add_number_y*25.4

                rj_pad_y6 = panel_y * 0.5 + 3.007868*25.4 - add_number_y*25.4
                rj_pad_y7 = panel_y * 0.5 + 4.779518*25.4 - add_number_y*25.4
                rj_pad_y8 = panel_y * 0.5 + 6.551168*25.4 - add_number_y*25.4
                rj_pad_y9 = panel_y * 0.5 + 8.322818*25.4 - add_number_y*25.4
                rj_pad_y10 = panel_y * 0.5 + 10.094468*25.4 - add_number_y*25.4
                if panel_y_inch > 20.55:
                    # --上下左右共20个
                    rj_y_array = [rj_pad_y5, rj_pad_y4, rj_pad_y3, rj_pad_y2, rj_pad_y1,
                                  rj_pad_y6, rj_pad_y7, rj_pad_y8, rj_pad_y9, rj_pad_y10]
                else:
                    # --上下左右共16个
                    rj_y_array = [rj_pad_y5, rj_pad_y4, rj_pad_y3, rj_pad_y2,
                                  rj_pad_y6, rj_pad_y7, rj_pad_y8, rj_pad_y9]

        if (L_margin >= 21) :
            # --溶胶pad左方块距profile要求8mm,中间方块宽6mmm,距板内大于7mm,21mm留边正好满足距板内6mm,距板外8mm
            #--20220713 更改  留边》=18 时  溶胶pad左方块距profile要求5mm,中间方块宽6mmm,距板内大于7mm,18mm留边正好满足距板内6mm,距板外8mm

            rj_pad_x2 = profile_xmin + 6 + 5
            rj_pad_x1 = profile_xmax - 6 - 5
        elif (flow_content=='一次铜' and L_margin >= 18):
            rj_pad_x2 = profile_xmin + 3 + 5
            rj_pad_x1 = profile_xmax - 3 - 5

        else:
            # --小于21mm时，必须保证距板内7mm
            rj_pad_x2 = sr_xmin - 4.5 - 5
            rj_pad_x1 = sr_xmax + 4.5 + 5


        # --五厂电磁热溶块,长边坐标定义
        global et_rj_pad_x1
        global et_rj_pad_x2

        if (L_margin >= 16.5) :
            # --电磁热溶symbol负片总宽度10mm,成型区距铺铜2.5mm,铜pad跑开料5mm(负片边缘跑开料3mm),铜pad距板内6.5mm(2.5铺铜+1mm+3mm负片)
            # --最佳宽度   成型区到铺铜边  铺铜边到symbol负片边缘  symbol负片宽度  负片距开料边
            # --16.5mm  =   2.5mm      +      1mm            +    10mm      +   3mm
            # --电磁溶胶pad线距profile要求5mm,线距中心3mm
            et_rj_pad_x2 = profile_xmin + 5 + 3
            et_rj_pad_x1 = profile_xmax - 5 - 3
        elif (flow_content=='一次铜' and L_margin >= 18):
            rj_pad_x2 = profile_xmin + 3 + 5
            rj_pad_x1 = profile_xmax - 3 - 5
        else:
            # --小于16.5mm时，必须保证距板内6.5mm,铜pad线距中心2mm
            et_rj_pad_x2 = sr_xmin - 6.5 - 2
            et_rj_pad_x1 = sr_xmax + 6.5 + 2


        # --定义防爆孔坐标
        rm_hole_y_list = [i - 9 for i in rj_y_array]
        rm_hole_dx = 0
        # --长边左侧防曝孔坐标定义
        if fusion_mode == '电磁热溶':
            # --五厂电磁热溶,中心不在网格中心,偏移了0.5mm
            pad_x2 = et_rj_pad_x2 - 0.5
            middle_x1 = pad_x2 - 1.5
            middle_x2 = pad_x2 + 1.5
        else:
            pad_x2 = rj_pad_x2
            middle_x1 = pad_x2 - 2
            middle_x2 = pad_x2 + 2
        # --长边右侧防曝孔坐标定义
        if fusion_mode == '电磁热溶':
            # --五厂电磁热溶,中心不在网格中心,偏移了0.5mm
            pad_x1 = et_rj_pad_x1 + 0.5
            middle_x3 = pad_x1 - 1.5
        else:
            pad_x1 = rj_pad_x1
            middle_x3 = pad_x1 - 2

        # --长边防暴孔坐标定义
        rout_to_pad_x = pad_x2 - (panel_x - rout_x)/2
        # if rout_to_pad_x>4:
        #     rout_to_pad_x = 2.4
        if fusion_mode == '电磁热溶':
            out_rj_sym = 'rect5762x20762'
            md_rj_sym = 'rect6016x21016'
            double_limits = 4.5
            middle_limits = 2.5
            right_limits = 0.5
        else:
            out_rj_sym = 'rect6762x20762'
            md_rj_sym = 'rect7016x21016'
            double_limits = 5
            middle_limits = 3
            right_limits = 1
        # 周涌通知 多层的pin_lam融合防爆孔全部按两排添加 20240726 by lyh
        if rout_to_pad_x > double_limits and not ("等离子除胶渣" in Flows and "树脂塞孔" in Flows):
            add_fs = 'double'
            global Isdouble_fbk_long
            Isdouble_fbk_long = True
            self.parm.add_fs='double'
            rm_hole_x_list = [middle_x1 for i in rj_y_array]
            rm_hole_x_list.extend([middle_x3 for i in rj_y_array])
            rm_hole_nx = 2
            rm_hole_ny = 7
            if fusion_mode == '电磁热溶':
                # --五厂电磁热孔间距只有3mm
                rm_hole_dx = 3000
            else:
                rm_hole_dx = 4000
            rm_hole_dy = 3000

        elif rout_to_pad_x > middle_limits or ("等离子除胶渣" in Flows and "树脂塞孔" in Flows):
            add_fs = 'middle'
            out_rj_sym = 'rect2762x20762'
            md_rj_sym = 'rect3016x21016'
            rm_hole_x_list = [pad_x2 for i in rj_y_array]
            rm_hole_x_list.extend([pad_x1 for i in rj_y_array])
            rm_hole_nx = 2
            rm_hole_ny = 7
            if fusion_mode == '电磁热溶':
                # --五厂电磁热孔间距只有3mm
                rm_hole_dx = 3000
            else:
                rm_hole_dx = 4000            
            rm_hole_dy = 0
        elif rout_to_pad_x > right_limits:
            add_fs = 'right'
            rm_hole_x_list = [middle_x1 for i in rj_y_array]
            rm_hole_x_list.extend([middle_x3 for i in rj_y_array])
            rm_hole_nx = 2
            rm_hole_ny = 7
            if fusion_mode == '电磁热溶':
                # --五厂电磁热孔间距只有3mm
                rm_hole_dx = 3000
            else:
                rm_hole_dx = 4000            
            rm_hole_dy = 3000
        else:
            # --TODO 提示防爆孔无法避开锣边，但仍然添加，由人员决定是否手动删除
            # msg_box = msgBox()
            # msg_box.critical(self, '警告', '长边防暴孔距离成型小于2mm,已经无法避开！', QMessageBox.Ok)
            msg_dict = {'type'       : 'critical',
                        'windowTitle': '警告',
                        'content'    : '长边防暴孔距离成型小于2mm,已经无法避开！'}
            self.msg_array.append(msg_dict)
            add_fs = 'none'
            rm_hole_x_list = [middle_x1 for i in rj_y_array]
            rm_hole_x_list.extend([middle_x3 for i in rj_y_array])
            rm_hole_nx = 2
            rm_hole_ny = 7
            if fusion_mode == '电磁热溶':
                # --五厂电磁热孔间距只有3mm
                rm_hole_dx = 3000
            else:
                rm_hole_dx = 4000            
            rm_hole_dy = 3000
        # --将长边防爆孔y坐标压入数组
        rm_hole_y_list.extend(rm_hole_y_list)
        # --将长边防爆孔nx,ny,dx,dy等压入数组
        rm_hole_nx_list = [rm_hole_nx for i in rm_hole_y_list]
        rm_hole_ny_list = [rm_hole_ny for i in rm_hole_y_list]
        rm_hole_dx_list = [rm_hole_dx for i in rm_hole_y_list]
        rm_hole_dy_list = [rm_hole_dy for i in rm_hole_y_list]
        # --将外层symbol压入数组
        rj_sym_outer = [out_rj_sym for i in rm_hole_y_list]
        # --将档点symbol压入数组
        rj_sym_md = [md_rj_sym for i in rm_hole_y_list]

        # --生成字典信息,键是层别类型,值是字典
        if fusion_mode == '电磁热溶':
            # --电磁热溶
            rj_x1_inner = [et_rj_pad_x1 for i in rj_y_array]
            # --外层symbol向右偏移0.5mm
            rj_x1_outer = [et_rj_pad_x1 + 0.5 for i in rj_y_array]
            # --右侧symbol旋转180度
            rj_x1_angle = [180 for i in rj_y_array]
            rj_x2_inner = [et_rj_pad_x2 for i in rj_y_array]
            # --外层symbol向左偏移0.5mm
            rj_x2_outer = [et_rj_pad_x2 - 0.5 for i in rj_y_array]
            # --左侧symbol不用旋转
            rj_x2_angle = [0 for i in rj_y_array]
            inn_rj_sym = 'et_rj_pad'
        else:
            # --韩松热溶
            rj_x1_inner = [rj_pad_x1 for i in rj_y_array]
            rj_x1_outer = [rj_pad_x1 for i in rj_y_array]
            rj_x1_angle = [0 for i in rj_y_array]
            rj_x2_inner = [rj_pad_x2 for i in rj_y_array]
            rj_x2_outer = [rj_pad_x2 for i in rj_y_array]
            rj_x2_angle = [0 for i in rj_y_array]
            inn_rj_sym = 'chris-rjpad'

        # --溶胶块y坐标前面定义了左侧，现在加入右侧坐标
        rj_y_inner.extend(rj_y_array)
        rj_y_inner.extend(rj_y_array)
        # --溶胶块x坐标分别加入左右两侧坐标
        rj_x_inner.extend(rj_x1_inner)
        rj_x_inner.extend(rj_x2_inner)
        # --外层对应防暴孔整块铺铜或者净空,x坐标
        rj_x_outer.extend(rj_x1_outer)
        rj_x_outer.extend(rj_x2_outer)
        # --外层对应防暴孔整块铺铜或者净空,y坐标
        rj_y_outer.extend(rj_y_array)
        rj_y_outer.extend(rj_y_array)
        # --电磁热溶有旋转角度,但韩松热溶都是0度
        rj_angle.extend(rj_x1_angle)
        rj_angle.extend(rj_x2_angle)
        # --将内层symbol压入数组
        rj_sym_inner = [inn_rj_sym for i in rm_hole_y_list]

        # --外侧铜皮宽度不足1.5mm时，需要静空处理
        neg_clear = 'no'
        sym_clear = 'rect10000x31000'
        to_profile = et_rj_pad_x2 - 5 - profile_xmin
        et_neg_x2 = profile_xmin
        et_neg_x1 = profile_xmax
        if to_profile < 3.5:
            neg_clear = 'yes'
            rj_x1_clear = [et_neg_x1 for i in rj_y_array]
            rj_x2_clear = [et_neg_x2 for i in rj_y_array]
            rj_x_clear.extend(rj_x1_clear)
            rj_x_clear.extend(rj_x2_clear)
            rj_y_clear.extend(rj_y_array)
            rj_y_clear.extend(rj_y_array)
            rj_sym_clear = [sym_clear for i in rm_hole_y_list]

        # --定义字典的各项值
        rj_mapping['rj_x_inner'] = rj_x_inner
        rj_mapping['rj_y_inner'] = rj_y_inner
        rj_mapping['rj_sym_inner'] = rj_sym_inner
        rj_mapping['rj_x_outer'] = rj_x_outer
        rj_mapping['rj_y_outer'] = rj_y_outer
        rj_mapping['rj_sym_outer'] = rj_sym_outer
        rj_mapping['rj_sym_md'] = rj_sym_md
        # --防暴孔
        rj_mapping['rm_hole_x_list'] = rm_hole_x_list
        rj_mapping['rm_hole_y_list'] = rm_hole_y_list
        rj_mapping['rm_hole_nx'] = rm_hole_nx_list
        rj_mapping['rm_hole_ny'] = rm_hole_ny_list
        rj_mapping['rm_hole_dx'] = rm_hole_dx_list
        rj_mapping['rm_hole_dy'] = rm_hole_dy_list
        rj_mapping['rj_angle'] = rj_angle
        # --是否需要添加静空pad
        rj_mapping['neg_clear'] = neg_clear
        rj_mapping['rj_x_clear'] = rj_x_clear
        rj_mapping['rj_y_clear'] = rj_y_clear
        rj_mapping['rj_sym_clear'] = rj_sym_clear
        return rj_mapping

    def get_short_rj_array(self):
        """
        获取短边溶胶块坐标列表
        :return:
        :rtype:
        """
        rj_mapping = {}
        sh_site = self.parm.sh_site
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        rout_y = self.parm.rout_y
        add_number_x = self.parm.add_number_x
        panel_x_inch = float(panel_x) * 0.03937
        U_margin = self.parm.U_margin
        profile_ymin = self.parm.profile_ymin
        profile_ymax = self.parm.profile_ymax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        short_top_et = self.parm.short_top_et
        short_bot_et = self.parm.short_bot_et
        # --热溶方式(韩松热溶或者电磁热溶)
        fusion_mode = self.parm.fusion_mode
        # 外层流程
        flow_content = self.parm.flow_content

        if fusion_mode != '电磁热溶' or self.parm.short_mao_yes=="是":
            # --电磁热溶短边才加热溶块
            return rj_mapping
        if panel_x < 480:
            ##梁涛要求五处也和六处一样更新
            if sh_site == '胜宏六厂'  or sh_site == '胜宏五厂' or sh_site == 'HDI一厂':
                # --依据story-view-3304要求，即使短边<480,仍要添加，优先右侧
                pass
            else:
                ##
                # --panel_x>=480mm时才可以在短边加电磁溶胶块
                return rj_mapping

        # --溶胶定位防呆孔,仅在短边top有，且如果与靶孔重叠时，可以不加，删除处理,此坐标为短边溶胶块参考中心
        rj_dwfd_x = (panel_x_inch * 0.5 - add_number_x) * 25.4

        # --五厂电磁热溶块,短边坐标定义
        if (U_margin >= 16.5) or(flow_content=='一次铜' and U_margin >= 18) :
            # --电磁溶胶pad线距profile要求5mm,线距中心3mm
            rj_pad_y2 = profile_ymin + 5 + 3
            rj_pad_y1 = profile_ymax - 5 - 3
        elif U_margin >= 13.5 and U_margin < 16.5:
            # --小于16.5mm时，必须保证距板内6mm,铜pad线距中心2mm
            rj_pad_y2 = sr_ymin - 6.5 - 2
            rj_pad_y1 = sr_ymax + 6.5 + 2
        else:
            # --小于13.5mm 也需要加 http://192.168.2.120:82/zentao/story-view-3304.html
            rj_pad_y2 = sr_ymin - 6.5 - 2
            rj_pad_y1 = sr_ymax + 6.5 + 2

        # --定义防爆孔坐标,短边下侧,五厂电磁热溶,中心不在网格中心,偏移了0.5mm
        pad_y2 = rj_pad_y2 - 0.5
        middle_y1 = pad_y2 - 1.5
        middle_y2 = pad_y2 + 1.5
        # --定义防爆孔坐标,短边上侧,五厂电磁热溶,中心不在网格中心,偏移了0.5mm
        pad_y1 = rj_pad_y1 + 0.5
        middle_y3 = pad_y1 - 1.5

        # --定义防爆孔坐标,短边防暴孔坐标定义
        rout_to_pad_y = pad_y2 - (panel_y - rout_y)/2
        # if rout_to_pad_y>4:
        #     rout_to_pad_y = 2.4
        out_rj_sym = 'rect5762x20762'
        md_rj_sym = 'rect6016x21016'
        inn_rj_sym = 'et_rj_pad'
        double_limits = 4.5
        middle_limits = 2.5
        right_limits = 0.5
        rm_hole_dy = 0
        # 周涌通知 多层的pin_lam融合防爆孔全部按两排添加 20240726 by lyh
        if rout_to_pad_y > double_limits:
            add_fs = 'double'
            global Isdouble_fbk_sort
            Isdouble_fbk_sort = True
            rm_hole_y_list = [middle_y3, middle_y3, middle_y1, middle_y1]
            rm_hole_nx = 7
            rm_hole_ny = 2
            rm_hole_dx = 3000
            rm_hole_dy = 3000
        elif rout_to_pad_y > middle_limits:
            add_fs = 'middle'
            out_rj_sym = 'rect2762x20762'
            md_rj_sym = 'rect3016x21016'
            rm_hole_y_list = [pad_y1, pad_y1, pad_y2, pad_y2]
            rm_hole_nx = 7
            rm_hole_ny = 2
            rm_hole_dx = 3000
            rm_hole_dy = 0
        elif rout_to_pad_y > right_limits:
            add_fs = 'bottom'
            rm_hole_y_list = [middle_y3, middle_y3, middle_y1, middle_y1]
            rm_hole_nx = 7
            rm_hole_ny = 2
            rm_hole_dx = 3000
            rm_hole_dy = 3000
        else:
            # --TODO 提示防爆孔无法避开锣边，但仍然添加，由人员决定是否手动删除
            msg_dict = {'type'       : 'critical',
                        'windowTitle': '警告',
                        'content'    : '短边防暴孔距离成型小于2mm,已经无法避开！'}
            self.msg_array.append(msg_dict)
            add_fs = 'none'
            rm_hole_y_list = [middle_y3, middle_y3, middle_y1, middle_y1]
            rm_hole_nx = 7
            rm_hole_ny = 2
            rm_hole_dx = 3000
            rm_hole_dy = 3000
        # --电磁溶胶块相关参数表达式生成
        rm_hole_nx_list = [rm_hole_nx for i in rm_hole_y_list]
        rm_hole_ny_list = [rm_hole_ny for i in rm_hole_y_list]
        rm_hole_dx_list = [rm_hole_dx for i in rm_hole_y_list]
        rm_hole_dy_list = [rm_hole_dy for i in rm_hole_y_list]
        # --短边电磁热溶块外层symbol列表
        rj_sym_outer = [out_rj_sym for i in rm_hole_y_list]
        # --短边电磁热溶块档点symbol列表
        rj_sym_md = [md_rj_sym for i in rm_hole_y_list]
        # --短边电磁热溶块内层symbol列表
        rj_sym_inner = [inn_rj_sym for i in rm_hole_y_list]
        rj_angle = [90, 90, 270, 270]

        rj_pad_xL = rj_dwfd_x - 115
        rj_pad_xR = rj_dwfd_x + 115
        # --短边电磁热溶块内层坐标列表
        rj_y_inner = [rj_pad_y1, rj_pad_y1, rj_pad_y2, rj_pad_y2]
        rj_x_inner = [rj_pad_xL, rj_pad_xR, rj_pad_xL, rj_pad_xR]
        # --短边电磁热溶块外层坐标列表
        rj_x_outer = [rj_pad_xL, rj_pad_xR, rj_pad_xL, rj_pad_xR]
        rj_y_outer = [rj_pad_y1 + 0.5, rj_pad_y1 + 0.5, rj_pad_y2 - 0.5, rj_pad_y2 - 0.5]
        # --短边电磁热溶块防暴孔x坐标列表
        rm_hole_x_list = [rj_pad_xL - 9, rj_pad_xR - 9, rj_pad_xL - 9, rj_pad_xR - 9]

        # --外侧铜皮宽度不足1.5mm时，需要静空处理,5mm为中心到负片边缘的距离
        neg_clear = 'no'
        sym_clear = 'rect31000x10000'
        to_profile = rj_pad_y2 - 5 - profile_ymin
        et_neg_y2 = profile_ymin
        et_neg_y1 = profile_ymax
        if to_profile < 3.5:
            neg_clear = 'yes'
            rj_x_clear = [rj_pad_xL, rj_pad_xR, rj_pad_xL, rj_pad_xR]
            rj_y_clear = [et_neg_y1, et_neg_y1, et_neg_y2, et_neg_y2]
            rj_sym_clear = [sym_clear for i in rm_hole_y_list]
        else:
            rj_x_clear = []
            rj_y_clear = []
            rj_sym_clear = []

        if not short_top_et and not short_bot_et:
            index_list = [1,3]
        elif not short_top_et:
            index_list = [1,2,3]
        elif not short_bot_et:
            index_list = [0,1,3]
        else:
            index_list = [0,1,2,3]
        # --定义字典的各项值
        rj_mapping['rj_x_inner'] = [rj_x_inner[i] for i in index_list]
        rj_mapping['rj_y_inner'] = [rj_y_inner[i] for i in index_list]
        rj_mapping['rj_sym_inner'] = [rj_sym_inner[i] for i in index_list]
        rj_mapping['rj_x_outer'] = [rj_x_outer[i] for i in index_list]
        rj_mapping['rj_y_outer'] = [rj_y_outer[i] for i in index_list]
        rj_mapping['rj_sym_outer'] = [rj_sym_outer[i] for i in index_list]
        rj_mapping['rj_sym_md'] = [rj_sym_md[i] for i in index_list]
        rj_mapping['rm_hole_x_list'] = [rm_hole_x_list[i] for i in index_list]
        rj_mapping['rm_hole_y_list'] = [rm_hole_y_list[i] for i in index_list]
        rj_mapping['rm_hole_nx'] = [rm_hole_nx_list[i] for i in index_list]
        rj_mapping['rm_hole_ny'] = [rm_hole_ny_list[i] for i in index_list]
        rj_mapping['rm_hole_dx'] = [rm_hole_dx_list[i] for i in index_list]
        rj_mapping['rm_hole_dy'] = [rm_hole_dy_list[i] for i in index_list]
        rj_mapping['rj_angle'] = [rj_angle[i] for i in index_list]
        # --是否需要添加静空pad
        if neg_clear == 'no':
            rj_mapping['neg_clear'] = neg_clear
            rj_mapping['rj_x_clear'] = rj_x_clear
            rj_mapping['rj_y_clear'] = rj_y_clear
            rj_mapping['rj_sym_clear'] = rj_sym_clear
        else:
            rj_mapping['neg_clear'] = neg_clear
            rj_mapping['rj_x_clear'] = [rj_x_clear[i] for i in index_list]
            rj_mapping['rj_y_clear'] = [rj_y_clear[i] for i in index_list]
            rj_mapping['rj_sym_clear'] = [rj_sym_clear[i] for i in index_list]
        return rj_mapping

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        if self.parm.pan_lam != '是':
            return info
        
        rout_drl=False
        core_count = self.parm.core_count
        if core_count < 2:
            return info
        fill_array = self.parm.fill_array
        out_signal_array = self.parm.out_signal_array
        hdi_contain_tag_layer = self.parm.hdi_contain_tag_layer
        hdi_jie = self.parm.hdi_jie
        flow_content = self.parm.flow_content
        put_copper_md = self.parm.put_copper_md
        sh_site = self.parm.sh_site
        long_param = FrozenJSON(self.get_long_rj_array())
        short_param = FrozenJSON(self.get_short_rj_array())
        #获取料号的工站信息
    # Flows = InPlan(self.JOB).GetInpalFlow()
        Flows= eval(self.parm.all_flows)
        # --热溶方式(韩松热溶或者电磁热溶)
        fusion_mode = self.parm.fusion_mode

        if short_param.has_key('rj_x_inner') :
            # --如果短边加电磁热溶块
            rj_x_clear = long_param.rj_x_clear + short_param.rj_x_clear
            rj_y_clear = long_param.rj_y_clear + short_param.rj_y_clear
            rj_sym_clear = long_param.rj_sym_clear + short_param.rj_sym_clear
            rj_x_inner = long_param.rj_x_inner + short_param.rj_x_inner
            rj_y_inner = long_param.rj_y_inner + short_param.rj_y_inner
            rj_sym_inner = long_param.rj_sym_inner + short_param.rj_sym_inner
            rj_x_outer = long_param.rj_x_outer + short_param.rj_x_outer
            rj_y_outer = long_param.rj_y_outer + short_param.rj_y_outer
            rj_sym_outer = long_param.rj_sym_outer + short_param.rj_sym_outer
            rj_sym_md = long_param.rj_sym_md + short_param.rj_sym_md

            ##防爆孔新规则2023 11 02  http://192.168.2.120:82/zentao/story-view-4952.html
            if "等离子除胶渣" in Flows and "树脂塞孔" in Flows:
                # pass
                # rout_drl=True
                # x_list=long_param.rj_x_inner+short_param.rj_x_inner
                # y_list=long_param.rj_y_inner+short_param.rj_y_inner
                #
                # info['通孔'] = self.convert_to_dict(x_list=long_param.rj_x_inner, y_list=long_param.rj_y_inner, symbol='fbk_normal',attribute='.string,text=fbk_sz',angle=90)
                # info['通孔'].extend(self.convert_to_dict(x_list=short_param.rj_x_inner,y_list=short_param.rj_y_inner,symbol='fbk_normal',attribute='.string,text=fbk_sz'))
                #
                # top_after_margin = self.parm.top_after_margin
                # left_after_margin = self.parm.left_after_margin

                #if sh_site == "胜宏六厂" and "等离子除胶渣" in Flows and "树脂塞孔" in Flows:
                #六处 流程有等离子除胶+树脂塞孔 需要加三排防爆孔 需求： http://192.168.2.120:82/zentao/story-view-4952.html for 吕康侠
                #self.GEN.PAUSE(json.dumps(long_param.rm_hole_x_list))
                #计算裁边边大小
                rou_x = (self.parm.panel_x - self.parm.rout_x) * 0.5
                rou_y = (self.parm.panel_y - self.parm.rout_y) * 0.5
                x_cb = self.parm.sr_xmin - rou_x
                y_cb = self.parm.sr_ymin - rou_y
                long_x= [x+1.2 if x<100 else x-1.2 for x in long_param.rm_hole_x_list ]
                long_y=long_param.rm_hole_y_list

                #self.GEN.PAUSE("ssss")
                sort_x=short_param.rm_hole_x_list
                sort_y=[x+1.2 if x<100 else x-1.2 for x in short_param.rm_hole_y_list ]

                jjx=3 if x_cb > 11.5 else 2.5
                jjy = 3 if y_cb > 11.5 else 2.5


                long_x=long_x+[x-jjx for x in long_x]+[x+jjx for x in long_x]
                long_y*=3
                sort_x*=3
                sort_y = sort_y + [y - jjy for y in sort_y] + [y +jjy for y in sort_y]

                ##x是否需要移动
                if min(long_x)-2.5<rou_x:
                    #根据留边大小来决定移动间距和排数
                    # if x_cb > 11.5:
                        #11.5能确保三排孔有位置加 2.0的孔径1的间距2*3+1*2+1.5+2=11.5 正常移动
                    dist=rou_x+2.5-min(long_x)
                    long_x=[x+dist if x<self.parm.panel_x*0.5 else x-dist for x in long_x]
                if min(sort_y)-2.5<rou_y:
                    #根据留边大小来决定移动间距和排数
                    # if y_cb > 11.5:
                    #     #11.5能确保三排孔有位置加 2.0的孔径1的间距2*3+1*2+1.5+2=11.5 正常移动
                    dist=rou_y+2.5-min(sort_y)
                    sort_y=[y+dist if y<self.parm.panel_y*0.5 else y-dist for y in sort_y]




                bun,di=( (6,9) if self.parm.plate_type else (4,6))

                rm_hole_x_list=long_x+[x-di for x in sort_x]
                rm_hole_y_list=[y-di for y in long_y]+sort_y

                rm_hole_nx=long_param.rm_hole_nx*3 + [x+bun for x in short_param.rm_hole_nx]*3
                rm_hole_ny = [y+bun for y in long_param.rm_hole_ny]*3 + short_param.rm_hole_ny*3
                rm_hole_dx = long_param.rm_hole_dx*3 + short_param.rm_hole_dx*3
                rm_hole_dy = long_param.rm_hole_dy*3 + short_param.rm_hole_dy*3
                ##防爆孔新规则2023 11 02 移至TS_fbk类处理
                # rm_hole_x_list = []
                # rm_hole_y_list = []
                # rm_hole_nx = []
                # rm_hole_ny = []
                # rm_hole_dx = []
                # rm_hole_dy = []

            else:
                rm_hole_x_list = long_param.rm_hole_x_list + short_param.rm_hole_x_list
                rm_hole_y_list = long_param.rm_hole_y_list + short_param.rm_hole_y_list
                rm_hole_nx = long_param.rm_hole_nx + short_param.rm_hole_nx
                rm_hole_ny = long_param.rm_hole_ny + short_param.rm_hole_ny
                rm_hole_dx = long_param.rm_hole_dx + short_param.rm_hole_dx
                rm_hole_dy = long_param.rm_hole_dy + short_param.rm_hole_dy
            rj_angle = long_param.rj_angle + short_param.rj_angle

        else:
            # if self.parm.short_mao_yes=="否":
            rj_x_clear = long_param.rj_x_clear
            rj_y_clear = long_param.rj_y_clear
            rj_sym_clear = long_param.rj_sym_clear
            rj_x_inner = long_param.rj_x_inner
            rj_y_inner = long_param.rj_y_inner
            rj_sym_inner = long_param.rj_sym_inner
            rj_x_outer = long_param.rj_x_outer
            rj_y_outer = long_param.rj_y_outer
            rj_sym_outer = long_param.rj_sym_outer
            rj_sym_md = long_param.rj_sym_md
            rm_hole_x_list = long_param.rm_hole_x_list
            rm_hole_y_list = long_param.rm_hole_y_list
            rm_hole_nx = long_param.rm_hole_nx
            rm_hole_ny = long_param.rm_hole_ny
            rm_hole_dx = long_param.rm_hole_dx
            rm_hole_dy = long_param.rm_hole_dy
            rj_angle = long_param.rj_angle
            if not vars().has_key("rm_hole_x_list") :return info
            ##三排防爆孔单独处理类TS_fbk
            if "等离子除胶渣" in Flows and "树脂塞孔" in Flows:
            #if sh_site == "胜宏六厂" and "等离子除胶渣" in Flows and "树脂塞孔" in Flows:
                #六处 流程有等离子除胶+树脂塞孔 需要加三排防爆孔 需求： http://192.168.2.120:82/zentao/story-view-4952.html for 吕康侠

                #计算裁边边大小
                rou_x = (self.parm.panel_x - self.parm.rout_x) * 0.5
                rou_y = (self.parm.panel_y - self.parm.rout_y) * 0.5
                x_cb = self.parm.sr_xmin - rou_x
                y_cb = self.parm.sr_ymin - rou_y

                bun, di = ((6, 9) if self.parm.plate_type else (4, 6))

                rm_hole_y_list = [y -di for y in rm_hole_y_list] *3
                rm_hole_x_list=[x + 1.2 if x < 100 else x - 1.2 for x in rm_hole_x_list]


                jjx = 3 if x_cb > 11.5 else 2.5
                rm_hole_x_list = rm_hole_x_list + [x - jjx for x in rm_hole_x_list] + [x + jjx for x in rm_hole_x_list]


                ##x是否需要移动
                if min(rm_hole_x_list) - 2.5 < rou_x:
                    # 根据留边大小来决定移动间距和排数
                    # if x_cb > 11.5:
                    # 11.5能确保三排孔有位置加 2.0的孔径1的间距2*3+1*2+1.5+2=11.5 正常移动
                    dist = rou_x + 2.5 - min(rm_hole_x_list)
                    long_x = [x + dist if x < self.parm.panel_x * 0.5 else x - dist for x in rm_hole_x_list]


                rm_hole_nx = rm_hole_nx*3
                rm_hole_ny = [y+bun for y in rm_hole_ny]*3
                rm_hole_dx = rm_hole_dx*3
                rm_hole_dy = rm_hole_dy*3
                # rout_drl = True
                #
                # info['通孔'] = self.convert_to_dict(x_list=rj_x_inner, y_list=rj_y_inner, symbol='fbk_normal',attribute='.string,text=fbk_sz',angle=90)
                # rm_hole_x_list = []
                # rm_hole_y_list = []
                # rm_hole_nx = []
                # rm_hole_ny = []
                # rm_hole_dx = []
                # rm_hole_dy = []


        if fusion_mode == '电磁热溶':
            for index, fill_hash in enumerate(fill_array):
                layer_name = fill_hash.layer_name
                layer_side = fill_hash.layer_side
                copper_thick = fill_hash.copper_thick
                if layer_name in hdi_contain_tag_layer:
                    if copper_thick in ['1/3OZ', 'HOZ', '1OZ', '1.5OZ', '2OZ', '2.5OZ']:
                        # --铜厚小于3oz时,core的上下两面均加溶胶pad
                        # --添加净空块
                        info[layer_name] = self.convert_to_dict(x_list=rj_x_clear, y_list=rj_y_clear,
                                                                symbol=rj_sym_clear, polarity='negative',
                                                                attribute='.string,text=et_rj_clear')
                        # --添加溶胶块
                        info[layer_name].extend( self.convert_to_dict(x_list=rj_x_inner, y_list=rj_y_inner,
                                                                      symbol=rj_sym_inner, angle=rj_angle))
                    else:
                        # --铜厚>=3oz时,core的top面加溶胶pad,bot面不加
                        if layer_side == '正':
                            # --添加净空块
                            info[layer_name] = self.convert_to_dict(x_list=rj_x_clear, y_list=rj_y_clear,
                                                                    symbol=rj_sym_clear, polarity='negative',
                                                                    attribute='.string,text=et_rj_clear')
                            info[layer_name].extend(self.convert_to_dict(x_list=rj_x_inner, y_list=rj_y_inner,
                                                                         symbol=rj_sym_inner, angle=rj_angle))
                        else:
                            # pass
                            # --添加净空块
                            # --内层铜厚≥3OZ时，板边熔合位设计优化 AresHe 2021.11.10
                            # --来源需求:http://192.168.2.120:82/zentao/story-view-3665.html
                            info[layer_name] = self.convert_to_dict(x_list=rj_x_clear, y_list=rj_y_clear,
                                                                    symbol=rj_sym_clear, polarity='negative',
                                                                    attribute='.string,text=et_rj_clear')
                            info[layer_name].extend(self.convert_to_dict(x_list=rj_x_inner, y_list=rj_y_inner,
                                                                         symbol=rj_sym_clear, polarity='negative',
                                                                    attribute='.string,text=et_rj_clear'))
        else:
            for index, fill_hash in enumerate(fill_array):
                layer_name = fill_hash.layer_name
                layer_side = fill_hash.layer_side
                copper_thick = fill_hash.copper_thick
                if not info.has_key(layer_name):
                    info[layer_name] = []                
                if layer_name in hdi_contain_tag_layer:
                    if layer_side == '正':
                        info[layer_name] = self.convert_to_dict(x_list=rj_x_inner, y_list=rj_y_inner, symbol=rj_sym_inner, angle=rj_angle)
                    else:
                        info[layer_name] = self.convert_to_dict(x_list=rj_x_inner, y_list=rj_y_inner, symbol=rj_sym_inner, angle=rj_angle)
        #防爆孔外层后续用孔以ring的方式来添加 故注释以下代码 2023 08 30
        # if flow_content == '二次铜':
        #     # --五厂铺铜,请参考a39/142a2
        #     # if flow_content == '二次铜' or put_copper_out == "yes":
        #     info['外层'] = self.convert_to_dict(x_list=rj_x_outer, y_list=rj_y_outer, symbol=rj_sym_outer, angle=rj_angle)
        # # --选化sgt-c sgt-s板边5mm不盖干膜，防暴孔位置整块套开
        # info['选化'] = self.convert_to_dict(x_list=rj_x_outer, y_list=rj_y_outer, symbol=rj_sym_outer,polarity='negative', angle=rj_angle)

        mai_hole_size = "r1500"
        #http://192.168.2.120:82/zentao/story-view-6860.html 20240726
        #  NV系列四阶以上压合次数多，埋孔防爆孔位置容易缺胶。
        if self.JOB[1:4] in ["a86", "d10"] and hdi_jie > 4:
            mai_hole_size = "r500"
            
        # --定义外层是否夹两张pp变量clip_2pp
        clip_2pp = 'no'
        cusNo = self.JOB[1:4]
        pp2_layer = self.parm.pp2_layer
        for out_layer in out_signal_array:
            if out_layer in pp2_layer:
                clip_2pp = 'yes'
                break
        # --通孔添加防爆孔
        if cusNo in ["a11"] and clip_2pp == 'yes':
            # === http://192.168.2.120:82/zentao/story-view-1765.html
                        # === A11系列外夹层PP≥2张 取消热熔快上防爆孔
            pass
        else:
            # if not rout_drl:

            info['通孔'] = self.convert_to_dict(x_list=rm_hole_x_list, y_list=rm_hole_y_list, symbol='r2000',
                                                  nx=rm_hole_nx, ny=rm_hole_ny, dx=rm_hole_dx, dy=rm_hole_dy,
                                                       attribute='.string,text=fbk')
            
            info['埋孔'] = self.convert_to_dict(x_list=rm_hole_x_list, y_list=rm_hole_y_list, symbol=mai_hole_size,
                                                  nx=rm_hole_nx, ny=rm_hole_ny, dx=rm_hole_dx, dy=rm_hole_dy,
                                                       attribute='.string,text=fbk')
            info['档点'] = self.convert_to_dict(x_list=rm_hole_x_list, y_list=rm_hole_y_list, symbol='r2508',
                                                   nx=rm_hole_nx, ny=rm_hole_ny, dx=rm_hole_dx, dy=rm_hole_dy,
                                                   attribute='.string,text=fbk')            
        # --防爆孔对应档点 挡点按 版本4.51 防爆孔优化
        # if put_copper_md == 'no':
        #     # --档点不铺铜时,D+20正极性copy到档点
        #     ##梁涛要求挡点防爆孔挡点不添加负性 2023 08.23 添加 and Flase by consenmy
        #     if self.parm.vgaChange and False:
        #         # --vgaChange为卡板切铜函数，此时档点整块不档油，防止上金上锡(参考料号e880/888a1)
        #         info['档点'] = self.convert_to_dict(x_list=rj_x_outer, y_list=rj_y_outer, symbol=rj_sym_md,
        #                                           angle=rj_angle, polarity='negative')
        #     else:
        #         info['档点'] = []
        #     # --20210301刘文东要求修改为1:1档油
        #     info['档点'].extend(self.convert_to_dict(x_list=rm_hole_x_list, y_list=rm_hole_y_list, symbol='r2000',
        #                                            nx=rm_hole_nx, ny=rm_hole_ny, dx=rm_hole_dx, dy=rm_hole_dy,
        #                                            attribute='.string,text=fbk'))

        return info
    
class rj_dw_sym(STATIC_SYM):
    """
    溶胶定位tooling
    """
    def __init__(self,frozen_json=None,priority=1.3):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        STATIC_SYM.__init__(self,priority=priority,avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        if self.parm.pan_lam != '是':
            return info
        
        core_count = self.parm.core_count
        if core_count < 2:
            return info
        fill_array = self.parm.fill_array
        hdi_contain_tag_layer = self.parm.hdi_contain_tag_layer
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        panel_x_inch = float(panel_x) * 0.03937
        panel_y_inch = float(panel_y) * 0.03937
        sr_ymax = self.parm.sr_ymax
        profile_xmax = self.parm.profile_xmax
        profile_ymax=self.parm.profile_ymax
        md_x = self.parm.mao_pin_x
        md_y = self.parm.mao_pin_y
        add_number_x = self.parm.add_number_x
        add_number_y = self.parm.add_number_y        
        L_margin = self.parm.L_margin
        R_margin = self.parm.R_margin
        U_margin = self.parm.U_margin
        D_margin = self.parm.D_margin
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        hdi_jie = self.parm.hdi_jie


        # --PE3000冲孔进制(0.25inch或者0.5inch)
        ape3000_base = self.parm.ape3000_base

        ##是否锚短边
        IsShortMao=self.parm.short_mao_yes

        # --定义xa, xb, ya, yb的长度 : xa->top xb->bot ya->right yb->left
        xa = (md_y - 0.75) * 0.5
        xb = xa
        ya = (md_x - 0.75) * 0.5
        yb = ya

        # --设置溶胶定位孔的坐标.bot->top->left->right
        rj_dw_x1 = (panel_x_inch * 0.5 + 0.47 - add_number_x)*25.4
        rj_dw_y1 = (panel_y_inch * 0.5 - xb)*25.4
        rj_dw_y2 = (panel_y_inch * 0.5 + xa)*25.4

        # --长边左侧溶胶定位槽x坐标及y坐标
        rj_dw_x3 = (panel_x_inch * 0.5 - yb)*25.4
        rj_dw_y3 = (panel_y_inch * 0.5 - add_number_y)*25.4

        # --长边右侧溶胶定位槽x坐标及y坐标
        rj_dw_x4 = (panel_x_inch * 0.5 + ya)*25.4
        rj_dw_y4 = (panel_y_inch * 0.5 - add_number_y + 0.18799175)*25.4

        # --溶胶定位防呆孔,仅在短边top有，且如果与靶孔重叠时，可以不加，删除处理
        rj_dwfd_x = (panel_x_inch * 0.5 - add_number_x)*25.4
        rj_dwfd_y = (panel_y_inch * 0.5 + xa)*25.4

        rj_dw_x_array = [rj_dw_x1,rj_dw_x1,rj_dw_x3,rj_dw_x4,rj_dwfd_x]
        rj_dw_y_array = [rj_dw_y1,rj_dw_y2,rj_dw_y3,rj_dw_y4,rj_dwfd_y]
        rj_dw_sym_top = ['sh-rj3-t','sh-rj3-t','sh-rj2-t','sh-rj2-t','sh-fdk']
        rj_dw_sym_bot = ['sh-rj3-b','sh-rj3-b','sh-rj2-b','sh-rj2-b','sh-fdk']
        ##垫pad
        DP_SYM=['s8000', 's8000','rect12100x9520','rect12100x9520','s1']

        # --sh-fdk是带c标的防呆孔，正方形，如果距sr大于8.5mm,可以改成chris-rj2-t/b(槽)
        add_chris_rj2_dis = rj_dwfd_y - sr_ymax
        if add_chris_rj2_dis >= 8:
            rj_dw_x_array = [rj_dw_x1, rj_dw_x1, rj_dw_x3, rj_dw_x4, rj_dwfd_x, rj_dwfd_x]
            rj_dw_y_array = [rj_dw_y1, rj_dw_y2, rj_dw_y3, rj_dw_y4, rj_dwfd_y, rj_dw_y1]
            rj_dw_sym_top = ['sh-rj3-t', 'sh-rj3-t', 'sh-rj2-t', 'sh-rj2-t', 'chris-rj2-t','chris-rj2-t']
            rj_dw_sym_bot = ['sh-rj3-b', 'sh-rj3-b', 'sh-rj2-b', 'sh-rj2-b', 'chris-rj2-b','chris-rj2-b']
            DP_SYM = ['s8000', 's8000', 'rect12100x9520', 'rect12100x9520', 'rect9520x12100','rect9520x12100']

        if profile_xmax > 580:
            # --板边x大于580时，不加c靶防呆，因为会与靶孔冲突,参考需求http://192.168.2.120:82/zentao/story-view-2002.html
            # --参考料号338/481a1,x开料581mm
            rj_dw_x_array = [rj_dw_x1, rj_dw_x1, rj_dw_x3, rj_dw_x4]
            rj_dw_y_array = [rj_dw_y1, rj_dw_y2, rj_dw_y3, rj_dw_y4]
            rj_dw_sym_top = ['sh-rj3-t', 'sh-rj3-t', 'sh-rj2-t', 'sh-rj2-t']
            rj_dw_sym_bot = ['sh-rj3-b', 'sh-rj3-b', 'sh-rj2-b', 'sh-rj2-b']
            DP_SYM = ['rect12100x9520', 'rect12100x9520', 'rect12100x9520', 'rect12100x9520']
        # --inn-pp层添加slot
        if ape3000_base == '0.5inch':
            rj_dw_sym_pp = 'drill_innpp'
            # -------------- 左 ----- 右 ---
            rj_dw_x_pp = [rj_dw_x3,rj_dw_x4]
            rj_dw_y_pp = [rj_dw_y3,rj_dw_y4]
        else:
            # --ape3000 0.25进制的inn-pp层不加slot槽
            rj_dw_sym_pp = None
            rj_dw_x_pp = []
            rj_dw_y_pp = []
            # --ape3000 0.25inch进制时,溶胶定位槽偏左0.47inch的位置加sh-mdk
            rj_dw_x_array = []
            rj_dw_y_array = []
            rj_dw_sym_top = []
            rj_dw_sym_bot = []
        #锚短边去掉长边的坐标
        if IsShortMao=='是':
            rj_dw_x_pp=[]
            rj_dw_y_pp = []
            rj_dw_x_array_new,rj_dw_y_array_new,rj_dw_sym_top_new,rj_dw_sym_bot_new=[],[],[],[]

            for i in range(len(rj_dw_x_array)):
                if panel_x/4.0<rj_dw_x_array[i]< panel_x-(panel_x/4.0):

                    rj_dw_x_array_new.append(rj_dw_x_array[i])
                    rj_dw_y_array_new.append(rj_dw_y_array[i])
                    rj_dw_sym_top_new.append(rj_dw_sym_top[i])
                    rj_dw_sym_bot_new.append(rj_dw_sym_bot[i])
            rj_dw_x_array, rj_dw_y_array, rj_dw_sym_top, rj_dw_sym_bot=rj_dw_x_array_new,rj_dw_y_array_new,rj_dw_sym_top_new,rj_dw_sym_bot_new

        # --添加溶胶定位孔
        #info['内层c'] = self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=rj_dw_sym_top)
        #info['内层s'] = self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=rj_dw_sym_bot)
        for index, fill_hash in enumerate(fill_array):
            layer_name = fill_hash.layer_name
            layer_side = fill_hash.layer_side
            copper_thick = fill_hash.copper_thick
            if not info.has_key(layer_name):
                info[layer_name] = []            
            if layer_name in hdi_contain_tag_layer:
                if layer_side == '正':
                    info[layer_name] = self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=rj_dw_sym_top)
                else:
                    info[layer_name] = self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=rj_dw_sym_bot)

        ##垫pad窄边会加到进板露铜,垫pad往板外移动1mm

        dpmdk_x_array = rj_dw_x_array
        dpmdk_y_array = rj_dw_y_array
        for i in range(len(dpmdk_x_array)):
            if U_margin < 13 and sr_xmin < dpmdk_x_array[i] < sr_xmax and dpmdk_y_array[i] > panel_y / 2: dpmdk_y_array[i] += 1
            if D_margin < 13 and sr_xmin < dpmdk_x_array[i] < sr_xmax and dpmdk_y_array[i] < panel_y / 2: dpmdk_y_array[i] -= 1
            if L_margin < 13 and sr_ymin < dpmdk_y_array[i] < sr_ymax and dpmdk_x_array[i] < panel_x / 2: dpmdk_x_array[i] -= 1
            if R_margin < 13 and sr_ymin < dpmdk_y_array[i] < sr_ymax and dpmdk_x_array[i] > panel_x / 2: dpmdk_x_array[i] += 1

        #info['内层c']=self.convert_to_dict(x_list=dpmdk_x_array, y_list=dpmdk_y_array, symbol=DP_SYM, attribute='.string,text=dp')+info['内层c']
        #info['内层s']=self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=DP_SYM ,attribute='.string,text=dp')+info['内层s']
        for index, fill_hash in enumerate(fill_array):
            layer_name = fill_hash.layer_name
            layer_side = fill_hash.layer_side
            copper_thick = fill_hash.copper_thick
            if not info.has_key(layer_name):
                info[layer_name] = []            
            if layer_name in hdi_contain_tag_layer:
                if layer_side == '正':
                    info[layer_name]=self.convert_to_dict(x_list=dpmdk_x_array, y_list=dpmdk_y_array, symbol=DP_SYM, attribute='.string,text=dp') + info[layer_name]
                else:
                    info[layer_name]=self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=DP_SYM ,attribute='.string,text=dp') + info[layer_name]
                                            
        info['inn-pp'] = self.convert_to_dict(x_list=rj_dw_x_pp, y_list=rj_dw_y_pp, symbol=rj_dw_sym_pp)
        if self.parm.pan_lam == '是':
            #info['内层c'].extend(self.convert_to_dict(x_list=[rj_dw_x3, rj_dw_x4,rj_dwfd_x, rj_dwfd_x], y_list=[rj_dw_y3, rj_dw_y4,rj_dwfd_y, rj_dw_y1], symbol=["rect8500x6501","rect8500x6501","rect6501x8500","rect6501x8500"]))
            #info['内层s'].extend(self.convert_to_dict(x_list=[rj_dw_x3, rj_dw_x4,rj_dwfd_x, rj_dwfd_x], y_list=[rj_dw_y3, rj_dw_y4,rj_dwfd_y, rj_dw_y1], symbol=["rect8500x6501","rect8500x6501","rect6501x8500","rect6501x8500"]))
            for index, fill_hash in enumerate(fill_array):
                layer_name = fill_hash.layer_name
                layer_side = fill_hash.layer_side
                copper_thick = fill_hash.copper_thick
                if not info.has_key(layer_name):
                    info[layer_name] = []                
                if layer_name in hdi_contain_tag_layer:
                    if layer_side == '正':            
                        info[layer_name].extend(self.convert_to_dict(x_list=[rj_dw_x3, rj_dw_x4,rj_dwfd_x, rj_dwfd_x], y_list=[rj_dw_y3, rj_dw_y4,rj_dwfd_y, rj_dw_y1], symbol=["rect8500x6501","rect8500x6501","rect6501x8500","rect6501x8500"]))
                    else:
                        info[layer_name].extend(self.convert_to_dict(x_list=[rj_dw_x3, rj_dw_x4,rj_dwfd_x, rj_dwfd_x], y_list=[rj_dw_y3, rj_dw_y4,rj_dwfd_y, rj_dw_y1], symbol=["rect8500x6501","rect8500x6501","rect6501x8500","rect6501x8500"]))
                        
            #增加检测距离是否满足距板内10mm
            #for x,y in zip([rj_dw_x3, rj_dw_x4,rj_dwfd_x, rj_dwfd_x],[rj_dw_y3, rj_dw_y4,rj_dwfd_y, rj_dw_y1]):
                #if x in [rj_dw_x3, rj_dw_x4]:
            if sr_xmin - rj_dw_x3 < 10 or rj_dw_x4 - sr_xmax < 10:
                msg_dict = {'type'       : 'critical',
                            'windowTitle': '警告',
                            'content'    : '长边的PINSLOT中心距单元内的距离小于10mm，请反馈领导是否需要改拼版尺寸！'}
                self.msg_array.append(msg_dict)
                
            if rj_dw_x3 < 5.5 or panel_x - rj_dw_x4 < 5.5:
                msg_dict = {'type'       : 'critical',
                            'windowTitle': '警告',
                            'content'    : '长边的PINSLOT中心距pnl板边的距离小于5.5mm，请反馈领导是否需要改拼版尺寸！'}
                self.msg_array.append(msg_dict)                
            
            if rj_dwfd_y - sr_ymax < 10 or sr_ymin - rj_dw_y1 < 10:
                msg_dict = {'type'       : 'critical',
                            'windowTitle': '警告',
                            'content'    : '短边的PINSLOT中心距单元内的距离小于10mm，请反馈领导是否需要改拼版尺寸！'}
                self.msg_array.append(msg_dict)
                
            if rj_dw_y1 < 8 or panel_y - rj_dwfd_y < 8:
                msg_dict = {'type'       : 'critical',
                            'windowTitle': '警告',
                            'content'    : '短边的PINSLOT中心距pnl板边的距离小于8mm，请反馈领导是否需要改拼版尺寸！'}
                self.msg_array.append(msg_dict)
                
            #测试
            #if "-lyh" in self.JOB:
                #if sr_xmin - rj_dw_x3 < 16 or rj_dw_x4 - sr_xmax < 16:
                    #msg_dict = {'type'       : 'critical',
                                #'windowTitle': '警告',
                                #'content'    : '长边的PINSLOT中心距单元内的距离小于10mm，请反馈领导是否需要改拼版尺寸！{0}'.format([sr_xmin - rj_dw_x3, rj_dw_x4 - sr_xmax])}
                    #self.msg_array.append(msg_dict)
                    
                #if rj_dw_x3 < 8 or panel_x - rj_dw_x4 < 8:
                    #msg_dict = {'type'       : 'critical',
                                #'windowTitle': '警告',
                                #'content'    : '长边的PINSLOT中心距pnl板边的距离小于5.5mm，请反馈领导是否需要改拼版尺寸！{0}'.format([rj_dw_x3, panel_x - rj_dw_x4])}
                    #self.msg_array.append(msg_dict)                
                
                #if rj_dwfd_y - sr_ymax < 16 or sr_ymin - rj_dw_y1 < 16:
                    #msg_dict = {'type'       : 'critical',
                                #'windowTitle': '警告',
                                #'content'    : '短边的PINSLOT中心距单元内的距离小于10mm，请反馈领导是否需要改拼版尺寸！{0}'.format([rj_dwfd_y - sr_ymax, sr_ymin - rj_dw_y1])}
                    #self.msg_array.append(msg_dict)
                    
                #if rj_dw_y1 < 10 or panel_y - rj_dwfd_y < 10:
                    #msg_dict = {'type'       : 'critical',
                                #'windowTitle': '警告',
                                #'content'    : '短边的PINSLOT中心距pnl板边的距离小于8mm，请反馈领导是否需要改拼版尺寸！{0}'.format([rj_dw_y1, panel_y - rj_dwfd_y])}
                    #self.msg_array.append(msg_dict)                
                    
                        
            ##pin_lam周围需要加一圈防爆孔
            # 1)防爆孔大小为2.0mm
            # 2)孔与孔之间间距为0.5mm
            # 3)防爆孔离pin孔的距离 0.5mm
            mai_hole_size = "r1500"
            #http://192.168.2.120:82/zentao/story-view-6860.html 20240726
            #  NV系列四阶以上压合次数多，埋孔防爆孔位置容易缺胶。
            if self.JOB[1:4] in ["a86", "d10"] and hdi_jie > 4:
                mai_hole_size = "r500"            

            for x,y in zip([rj_dw_x3, rj_dw_x4,rj_dwfd_x, rj_dwfd_x],[rj_dw_y3, rj_dw_y4,rj_dwfd_y, rj_dw_y1]):
                fbk_listx = []
                fbk_listy = []
                if x in [rj_dw_x3, rj_dw_x4]:
                    fbk_listx.extend([
                        "-0.0546759",
                        "0.0438794",
                        "0.1361784",
                        "0.1880504",
                        "0.177536",
                        "0.1095644",
                        "0.0125699",
                        "-0.0857045",
                        "-0.1647678",
                        "-0.1922258",
                        "-0.1550936",
                    ])
                    fbk_listy.extend([
                        "0.1513794",
                        "0.1522058",
                        "0.1178441",
                        "0.0339094",
                        '-0.0642371',
                        "-0.1353765",
                        "-0.1523922",
                        "-0.1450244",
                        "-0.0864626",
                        '0.0079948',
                        "0.0997684",
                    ])

                else:
                    fbk_listx.extend([
                        "0.0494305",
                        "0.1271201",
                        "0.1523795",
                        "0.1492759",
                        "0.0990301",
                        "0.0074663",
                        "-0.0869588",
                        "-0.1454437",
                        "-0.1523696",
                        "-0.1284168",
                        '-0.0493324'

                    ])
                    fbk_listy.extend([
                        "0.1835905",
                        "0.1230426",
                        "0.0279594",
                        "-0.0705474",
                        "-0.1554117",
                        "-0.1917124",
                        "-0.1638052",
                        "-0.0844906",
                        "0.0291585",
                        "0.1247822",
                        "0.1836953",

                    ])

                fbk_listx = [x + float(tmp) * 25.4 for tmp in fbk_listx]
                fbk_listy = [y + float(tmp) * 25.4 for tmp in fbk_listy]
                if not "通孔" in info.keys():
                    info['通孔'] = self.convert_to_dict(x_list=fbk_listx, y_list=fbk_listy, symbol='r2000',attribute='.string,text=fbk')                    
                else:
                    info['通孔'].extend(self.convert_to_dict(x_list=fbk_listx,y_list=fbk_listy,symbol='r2000',attribute='.string,text=fbk'))
                    
                if not "埋孔" in info.keys():
                    info['埋孔'] = self.convert_to_dict(x_list=fbk_listx, y_list=fbk_listy, symbol=mai_hole_size,attribute='.string,text=fbk')
                else:
                    info['埋孔'].extend(self.convert_to_dict(x_list=fbk_listx,y_list=fbk_listy,symbol=mai_hole_size,attribute='.string,text=fbk'))
                
                if not "档点" in info.keys():
                    info['档点'] = self.convert_to_dict(x_list=fbk_listx, y_list=fbk_listy, symbol='r2508',attribute='.string,text=fbk')
                else:
                    info['档点'].extend(self.convert_to_dict(x_list=fbk_listx, y_list=fbk_listy, symbol='r2508',attribute='.string,text=fbk'))

        return info

    def change_symbol(self):
        """
        将inn-pp层添加的symbol打散
        :return:
        :rtype:
        """
        if self.parm.core_count >= 2 and self.parm.ape3000_base == '0.5inch':
            self.GEN.CLEAR_LAYER()
            self.GEN.AFFECTED_LAYER('inn-pp','yes')
            self.GEN.COM('sel_break')
            self.GEN.CLEAR_LAYER()
            
        self.delete_fbk_for_rout_limit()
        
    def delete_fbk_for_rout_limit(self):
        """删除被修边锣到的防爆孔 20231110
        http://192.168.2.120:82/zentao/story-view-6182.html"""
        job = gClasses.Job(self.JOB)
        step = gClasses.Step(job, "panel")
        step.open()

        worklayer = "drl"
        if step.isLayer(worklayer):
            step.clearAll()
            step.affect(worklayer)
            step.resetFilter()
            step.setAttrFilter(".string,text=fbk")
            step.selectAll()
            if step.featureSelected():
                step.removeLayer(worklayer + "_fbk_tmp")
                step.moveSel(worklayer + "_fbk_tmp")
                panel_x = self.parm.panel_x
                panel_y = self.parm.panel_y
                rout_x = self.parm.rout_x
                rout_y = self.parm.rout_y
                lb_x = (panel_x - rout_x) * 0.5
                lb_y = (panel_y - rout_y) * 0.5
                step.clearAll()
                step.removeLayer("rout_check_surface")
                step.createLayer("rout_check_surface")
                step.affect("rout_check_surface")
                step.reset_fill_params()
                step.addRectangle(lb_x, lb_y, panel_x - lb_x, panel_y - lb_y)

                step.clearAll()
                step.affect(worklayer + "_fbk_tmp")
                step.resetFilter()
                step.setAttrFilter(".string,text=fbk")
                step.refSelectFilter("rout_check_surface", mode="cover")
                step.COM("sel_reverse")
                if step.featureSelected():
                    step.selectDelete()

                step.moveSel(worklayer)
                step.removeLayer(worklayer + "_fbk_tmp")
                step.removeLayer("rout_check_surface")

        step.resetFilter()
        step.clearAll()

class add_liujiao(STATIC_SYM):
    def __init__(self, frozen_json=None, priority=0.1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        info={}
        if self.parm.pan_lam != '是':
            return info

        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin


        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        panel_x_inch = float(panel_x) * 0.03937
        panel_y_inch = float(panel_y) * 0.03937
        sr_ymax = self.parm.sr_ymax
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        md_x = self.parm.mao_pin_x
        md_y = self.parm.mao_pin_y
        add_number_x = self.parm.add_number_x
        add_number_y = self.parm.add_number_y
        L_margin = self.parm.L_margin
        R_margin = self.parm.R_margin
        U_margin = self.parm.U_margin
        D_margin = self.parm.D_margin
        fill_array = self.parm.fill_array
        hdi_contain_tag_layer = self.parm.hdi_contain_tag_layer        

        xa = (md_y - 0.75) * 0.5
        xb = xa
        ya = (md_x - 0.75) * 0.5
        yb = ya
            # --设置溶胶定位孔的坐标.bot->top->left->right
        rj_dw_x1 = (panel_x_inch * 0.5 + 0.47 - add_number_x) * 25.4
        rj_dw_y1 = (panel_y_inch * 0.5 - xb) * 25.4
        rj_dw_y2 = (panel_y_inch * 0.5 + xa) * 25.4

        # --长边左侧溶胶定位槽x坐标及y坐标
        rj_dw_x3 = (panel_x_inch * 0.5 - yb) * 25.4
        rj_dw_y3 = (panel_y_inch * 0.5 - add_number_y) * 25.4

        # --长边右侧溶胶定位槽x坐标及y坐标
        rj_dw_x4 = (panel_x_inch * 0.5 + ya) * 25.4
        rj_dw_y4 = (panel_y_inch * 0.5 - add_number_y + 0.18799175) * 25.4

        # --溶胶定位防呆孔,仅在短边top有，且如果与靶孔重叠时，可以不加，删除处理
        rj_dwfd_x = (panel_x_inch * 0.5 - add_number_x) * 25.4
        rj_dwfd_y = (panel_y_inch * 0.5 + xa) * 25.4

            ##pin-lam流胶槽
        #长边左边四个四根
        x1s,y1s=-1,rj_dw_y3-23
        x1e,y1e=sr_xmin-2.5,rj_dw_y3

        x2s, y2s = -1, rj_dw_y3-7-23
        x2e, y2e = sr_xmin - 2.5, rj_dw_y3 -7

        x3s, y3s = -1, rj_dw_y3+23
        x3e, y3e = sr_xmin - 2.5, rj_dw_y3

        x4s, y4s = -1, rj_dw_y3 + 7+23
        x4e, y4e = sr_xmin - 2.5, rj_dw_y3 +7

        #长边右边四根
        x5s, y5s = profile_xmax+1, rj_dw_y4-23
        x5e, y5e = sr_xmax + 2.5, rj_dw_y4

        x6s, y6s =  profile_xmax+1, rj_dw_y4-7-23
        x6e, y6e = sr_xmax + 2.5, rj_dw_y4 -7

        x7s, y7s = profile_xmax + 1, rj_dw_y4+23
        x7e, y7e = sr_xmax + 2.5, rj_dw_y4

        x8s, y8s = profile_xmax + 1, rj_dw_y4 + 7+23
        x8e, y8e = sr_xmax + 2.5, rj_dw_y4 +  7

        #短边上边四根
        x9s, y9s = rj_dwfd_x-23 , profile_ymax+1
        x9e, y9e = rj_dwfd_x , sr_ymax+2.5

        x10s, y10s = rj_dwfd_x-7-23, profile_ymax + 1
        x10e, y10e = rj_dwfd_x -7, sr_ymax + 2.5

        x11s, y11s = rj_dwfd_x+23, profile_ymax + 1
        x11e, y11e = rj_dwfd_x , sr_ymax + 2.5

        x12s, y12s = rj_dwfd_x + 7+23, profile_ymax + 1
        x12e, y12e = rj_dwfd_x + 7, sr_ymax + 2.5

        ##短边下边四条
        x13s, y13s = rj_dwfd_x-23,   1
        x13e, y13e = rj_dwfd_x, sr_ymin - 2.5

        x14s, y14s = rj_dwfd_x-7-23, 1
        x14e, y14e = rj_dwfd_x -7, sr_ymin - 2.5

        x15s, y15s = rj_dwfd_x+23, 1
        x15e, y15e = rj_dwfd_x , sr_ymin - 2.5

        x16s, y16s = rj_dwfd_x + 7+23, 1
        x16e, y16e = rj_dwfd_x + 7, sr_ymin - 2.5

        line_xs1_list=[x1s,x2s,x3s,x4s,x5s,x6s,x7s,x8s,x9s,x10s,x11s,x12s,x13s,x14s,x15s,x16s]
        line_ys1_list=[y1s,y2s,y3s,y4s,y5s,y6s,y7s,y8s,y9s,y10s,y11s,y12s,y13s,y14s,y15s,y16s]
        line_xe1_list=[x1e,x2e,x3e,x4e,x5e,x6e,x7e,x8e,x9e,x10e,x11e,x12e,x13e,x14e,x15e,x16e]
        line_ye1_list=[y1e,y2e,y3e,y4e,y5e,y6e,y7e,y8e,y9e,y10e,y11e,y12e,y13e,y14e,y15e,y16e]

        line_xs2_list = [x1s, x2s, x3s, x4s, x5s, x6s, x7s, x8s, x9s+3.5, x10s+3.5, x11s+3.5, x12s+3.5, x13s+3.5, x14s+3.5, x15s+3.5, x16s+3.5]
        line_ys2_list = [y1s+3.5, y2s+3.5, y3s+3.5, y4s+3.5, y5s+3.5, y6s+3.5, y7s+3.5, y8s+3.5, y9s, y10s, y11s, y12s, y13s, y14s, y15s, y16s]
        line_xe2_list = [x1e, x2e, x3e, x4e, x5e, x6e, x7e, x8e, x9e+3.5, x10e+3.5, x11e+3.5, x12e+3.5, x13e+3.5, x14e+3.5, x15e+3.5, x16e+3.5]
        line_ye2_list = [y1e+3.5, y2e+3.5, y3e+3.5, y4e+3.5, y5e+3.5, y6e+3.5, y7e+3.5, y8e+3.5, y9e, y10e, y11e, y12e, y13e, y14e, y15e, y16e]

        #info['内层c']=self.convert_to_dict(x_list=line_xs1_list, y_list=line_ys1_list, xe_list=line_xe1_list,ye_list=line_ye1_list, symbol='r1002', polarity='negative')
        #info['内层s']=self.convert_to_dict(x_list=line_xs2_list, y_list=line_ys2_list, xe_list=line_xe2_list,ye_list=line_ye2_list, symbol='r1002', polarity='negative')
        for index, fill_hash in enumerate(fill_array):
            layer_name = fill_hash.layer_name
            layer_side = fill_hash.layer_side
            copper_thick = fill_hash.copper_thick
            if not info.has_key(layer_name):
                info[layer_name] = []            
            if layer_name in hdi_contain_tag_layer:
                if layer_side == '正':
                    info[layer_name]=self.convert_to_dict(x_list=line_xs1_list, y_list=line_ys1_list, xe_list=line_xe1_list,ye_list=line_ye1_list, symbol='r1002', polarity='negative')
                else:
                    info[layer_name]=self.convert_to_dict(x_list=line_xs2_list, y_list=line_ys2_list, xe_list=line_xe2_list,ye_list=line_ye2_list, symbol='r1002', polarity='negative')
                                        
        return info

class mdk_tooling(STATIC_SYM):
    """
    溶合块及防爆孔
    """
    def __init__(self,frozen_json=None,priority=1.4):
        self.parm = frozen_json

        if (self.parm.fusion_mode == '电磁热溶') or (self.parm.sh_site in ['胜宏三厂','胜宏四厂','胜宏五厂','胜宏六厂'] and self.parm.fusion_mode == '韩松热溶'):
            # --铆钉孔在电磁热溶块之前添加
            #一二处韩松热熔按原来的优先级 其他处别的韩松热熔优先于铆钉孔
            # 周涌通知 铆钉孔要在熔胶之前添加 熔胶是1.2 20240725
            priority = 1.21

        self.priority = priority
        self.avoidType = 'inner'
        STATIC_SYM.__init__(self,priority=priority,avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """

        ##由于要分先后定义添加有序的字典
        info = OrderedDict()
        #info = {}
        if self.parm.pan_lam != '是':
            return {}        

        core_count = self.parm.core_count
        # press_fit_Riveting = self.parm.press_fit_Riveting
        if core_count < 2: # and press_fit_Riveting == '否':
            return info

        fill_array = self.parm.fill_array
        hdi_contain_tag_layer = self.parm.hdi_contain_tag_layer   
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        panel_x_inch = float(panel_x) * 0.03937
        panel_y_inch = float(panel_y) * 0.03937
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        profile_xmax = self.parm.profile_xmax
        md_x = self.parm.mao_pin_x
        md_y = self.parm.mao_pin_y
        add_number_x = self.parm.add_number_x
        add_number_y = self.parm.add_number_y
        hdi_num = self.parm.hdi_num
        add_rmyt_symbol = self.parm.add_rmyt_symbol
        # --PE3000冲孔进制(0.25inch或者0.5inch)
        ape3000_base = self.parm.ape3000_base
        # --冲孔光学点坐标，初始化时是inch单位，此处转换为mm单位
        ck_fid_x1 = self.parm.ck_fid_x1*25.4
        core_count = self.parm.core_count
        put_copper_md = self.parm.put_copper_md
        sh_site = self.parm.sh_site
        Flows = eval(self.parm.all_flows)
        # --定义xa, xb, ya, yb的长度 : xa->top xb->bot ya->right yb->left
        xa = (md_y - 0.75) * 0.5
        xb = xa
        ya = (md_x - 0.75) * 0.5
        yb = ya

        # --设置溶胶定位孔的坐标.bot->top->left->right
        rj_dw_x1 = (panel_x_inch * 0.5 + 0.47 - add_number_x)*25.4
        rj_dw_y1 = (panel_y_inch * 0.5 - xb)*25.4
        rj_dw_y2 = (panel_y_inch * 0.5 + xa)*25.4

        rj_dw_x3 = (panel_x_inch * 0.5 - yb)*25.4
        rj_dw_y3 = (panel_y_inch * 0.5 - add_number_y)*25.4

        rj_dw_x4 = (panel_x_inch * 0.5 + ya)*25.4
        rj_dw_y4 = (panel_y_inch * 0.5 - add_number_y + 0.18799175)*25.4

        center_mdk_x_array = []
        center_mdk_y_array = []
        center_mdk_sym_top = []
        center_mdk_sym_bot = []
        jingzhi=0.25 if ape3000_base == '0.25inch' else 0.5
        if ape3000_base == '0.25inch':
            # --ape3000 0.25inch进制时,溶胶定位槽偏左0.47inch的位置加sh-mdk
            center_mdk_x_array = [rj_dw_x1-0.47*25.4, rj_dw_x1-0.47*25.4, rj_dw_x3, rj_dw_x4]
            center_mdk_y_array = [rj_dw_y1, rj_dw_y2, rj_dw_y3, rj_dw_y4]
            center_mdk_sym_top = ['sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t']
            center_mdk_sym_bot = ['sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b']

        # --定义铆钉孔坐标
        mdk_x1 = (panel_x_inch * 0.5 - yb)*25.4
        mdk_x2 = (panel_x_inch * 0.5 - 0.52999894 - add_number_x)*25.4
        mdk_x3 = (panel_x_inch * 0.5 + ya)*25.4

        mdk_y1 = (panel_y_inch * 0.5 - xb)*25.4
        mdk_y2 = (panel_y_inch * 0.5 - 6 - add_number_y)*25.4
        mdk_y3 = (panel_y_inch * 0.5 - 0.52999894 - add_number_y)*25.4
        mdk_fdy3 = (panel_y_inch * 0.5 - 0.34200719 - add_number_y)*25.4
        mdk_y4 = (panel_y_inch * 0.5 + 6 - add_number_y)*25.4
        mdk_y5 = (panel_y_inch * 0.5 + xa)*25.4
        if ape3000_base == '0.25inch':
            # --APE3000 0.25inch进制,上下两铆钉距中心与x方向距中心相等
            mdk_y2 = (panel_y_inch * 0.5 - 7.5 - add_number_y) * 25.4
            mdk_y4 = (panel_y_inch * 0.5 + 7.5 - add_number_y) * 25.4
            ###新增9.2inch的铆钉孔
            mdk_extra_d=(panel_y_inch * 0.5 - 9.2 - add_number_y) * 25.4
            mdk_extra_u=(panel_y_inch * 0.5 + 9.2 - add_number_y) * 25.4
            mdk_x_array = [mdk_x1, mdk_x1, mdk_x1, mdk_x2, mdk_x2, mdk_x3, mdk_x3, mdk_x3,mdk_x1, mdk_x1,mdk_x3, mdk_x3,]
            mdk_y_array = [mdk_y2, mdk_y3, mdk_y4, mdk_y1, mdk_y5, mdk_y2, mdk_fdy3, mdk_y4,mdk_extra_u,mdk_extra_d,mdk_extra_u,mdk_extra_d]
            mdk_top_array = ['sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t']
            mdk_bot_array = ['sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b']

        else:
            # --铆钉孔坐标列表,正常HDI长边三个孔，多层板长边5个孔
            mdk_x_array = [mdk_x1, mdk_x1, mdk_x1, mdk_x2, mdk_x2, mdk_x3, mdk_x3, mdk_x3]
            mdk_y_array = [mdk_y2, mdk_y3, mdk_y4, mdk_y1, mdk_y5, mdk_y2, mdk_fdy3, mdk_y4]
            mdk_top_array = ['sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t']
            mdk_bot_array = ['sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b']

        # --定义冲孔对位symbol sh-bb/sh-bb1坐标
        ck_fid_y1 = (panel_y_inch * 0.5 - xb)*25.4
        ck_fid_y2 = (panel_y_inch * 0.5 + xa)*25.4
        ck_fid_x2 = ck_fid_x1
        # --冲孔光学点yy方向距sr
        fid_dis_y = sr_ymin - ck_fid_y1
        ck_fid_sym_top_UD = "sh-bb-min"
        ck_fid_sym_bot_UD = "sh-bb1-min"
        ck_fid_sym_top_LR = "sh-bb-min"
        ck_fid_sym_bot_LR = "sh-bb1-min"
        ###pinlam t3靶自定义
        if self.parm.pan_lam == '是' or self.parm.mao_pin_x == 18.0 or self.parm.mao_pin_y == 24.0:
            ck_fid_sym_top_UD = "pin_lan_t3c"
            ck_fid_sym_bot_UD = "pin_lan_t3s"
            ck_fid_sym_top_LR = "pin_lan_t3c"
            ck_fid_sym_bot_LR = "pin_lan_t3s"
        if fid_dis_y > 6:
            ck_fid_angle1 = 0
            ck_fid_angle2 = 0
        else:
            # ck_fid_sym_top_UD = "sh-b2013"
            # ck_fid_sym_bot_UD = "sh-b12013"
            ck_fid_sym_top_UD = "sh-bb-min"
            ck_fid_sym_bot_UD = "sh-bb1-min"
            if self.parm.pan_lam == '是' or self.parm.mao_pin_x == 18.0 or self.parm.mao_pin_y == 24.0:
                ck_fid_sym_top_UD = "pin_lan_t3c"
                ck_fid_sym_bot_UD = "pin_lan_t3s"
            ck_fid_angle1 = 90
            ck_fid_angle2 = 270
        ck_fid_x3 = (panel_x_inch * 0.5 - yb)*25.4
        ck_fid_y3 = (panel_y_inch * 0.5 + 1.499997 - add_number_y)*25.4
        ck_fid_x4 = (panel_x_inch * 0.5 + ya)*25.4
        ck_fid_y4 = (panel_y_inch * 0.5 + 1.6877919 - add_number_y)*25.4
        # --冲孔光学点yy方向距sr
        fid_dis_x = sr_xmin - ck_fid_x3
        if fid_dis_x > 6:
            ck_fid_angle3 = 0
            ck_fid_angle4 = 0
        else:
            # ck_fid_sym_top_LR = "sh-b2013"
            # ck_fid_sym_bot_LR = "sh-b12013"
            ck_fid_sym_top_LR = "sh-bb-min"
            ck_fid_sym_bot_LR = "sh-bb1-min"
            ck_fid_angle3 = 180
            ck_fid_angle4 = 0
        # --冲孔光学点坐标及symbol列表
        ck_fid_x_array = [ck_fid_x1,ck_fid_x2,ck_fid_x3,ck_fid_x4]
        ck_fid_y_array = [ck_fid_y1,ck_fid_y2,ck_fid_y3,ck_fid_y4]
        ck_fid_a_array = [ck_fid_angle1,ck_fid_angle2,ck_fid_angle3,ck_fid_angle4]
        ck_fid_sym_top = [ck_fid_sym_top_UD,ck_fid_sym_top_UD,ck_fid_sym_top_LR,ck_fid_sym_top_LR]
        ck_fid_sym_bot = [ck_fid_sym_bot_UD,ck_fid_sym_bot_UD,ck_fid_sym_bot_LR,ck_fid_sym_bot_LR]

        # --视留边情况改变铆钉孔symbol形状
        if add_rmyt_symbol == "yes" and core_count >= 2 and profile_xmax > 328 and hdi_num < 1:
            # --计算短边铆钉到内sr的距离
            rm_to_sr_distan = sr_ymin - mdk_y1
            if rm_to_sr_distan < 7.5 and rm_to_sr_distan >= 3.8:
                top_up_mdk = bot_up_mdk = 'rm_dw_topqie'
                top_down_mdk = bot_down_mdk = 'rm_dw_botqie'
            elif rm_to_sr_distan >= 7.5 and rm_to_sr_distan < 9:
                top_up_mdk = bot_up_mdk = 'rm_dw_topmin'
                top_down_mdk = bot_down_mdk = 'rm_dw_botmin'
            else:
                top_down_mdk = 'rm_dw_bot-t'
                bot_down_mdk = 'rm_dw_bot-b'
                top_up_mdk = 'rm_dw_top-t'
                bot_up_mdk = 'rm_dw_top-b'
            # --视留边情况改变铆钉孔symbol形状
            if ape3000_base == '0.5inch':
                # --ape3000 0.25进制的不需要更改
                mdk_top_array = ['sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t', top_down_mdk, top_up_mdk,
                                 'sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t']
                mdk_bot_array = ['sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b', bot_down_mdk, bot_up_mdk,
                                 'sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b']

        if ape3000_base == '0.25inch':
            # --0.25inch APE3000冲孔时,在slot槽位置加铆钉symbol
            mdk_x_array.extend(center_mdk_x_array)
            mdk_y_array.extend(center_mdk_y_array)
            mdk_top_array.extend(center_mdk_sym_top)
            mdk_bot_array.extend(center_mdk_sym_bot)

        # --多加四个铆钉孔,板边y小于20.55inch时不加,会加到profile外面,ape3000 0.25inch进制的不需要额外添加铆钉()
        ##梁涛要求全部料号都需要加一组9.2inch的铆钉 2023/04/21
        ##梁涛要求 料号一律按多层处理 不区分hdi http://192.168.2.120:82/zentao/story-view-5954.html if core_count >= 2 and  hdi_num < 1 and ape3000_base == '0.5inch' and panel_y_inch >18.5 :
        if core_count >= 2  and ape3000_base == '0.5inch' and panel_y_inch >18.5 :
        #if core_count >= 2 and hdi_num < 1 and panel_y_inch > 20.55 and ape3000_base == '0.5inch':
            # --多层板, 一次压合, 两张core及以上，包括辅助层
            add_mdk_y1 = rj_dw_y3 + 9.2 * 25.4
            add_mdk_y2 = rj_dw_y3 - 9.2 * 25.4
            # --去掉y坐标为y2和y4的列表项,去掉中间四颗 梁涛要求全部加（因为全部处别加6 inch的和9.2inch的）注释掉下面几行
            # mdk_x_array = mdk_x_array[1:2] + mdk_x_array[3:5] + mdk_x_array[6:7]
            # mdk_y_array = mdk_y_array[1:2] + mdk_y_array[3:5] + mdk_y_array[6:7]
            # mdk_top_array = mdk_top_array[1:2] + mdk_top_array[3:5] + mdk_top_array[6:7]
            # mdk_bot_array = mdk_bot_array[1:2] + mdk_bot_array[3:5] + mdk_bot_array[6:7]
            # --2021.7.21依据story-view-3316取消，长边只留外围四颗+是中间两颗
            mdk_x_array.extend([mdk_x1,mdk_x1,mdk_x3,mdk_x3])
            mdk_y_array.extend([add_mdk_y1,add_mdk_y2,add_mdk_y1,add_mdk_y2])
            mdk_top_array.extend(['sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t'])
            mdk_bot_array.extend(['sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b'])

        ##上面已包含了这个要求 注释该条件
        # if  hdi_num>=1:
        #     ##刘文东要求hdi要加9.2的 需求：http://192.168.2.120:82/zentao/story-view-4831.html
        #     # mdy1=rj_dw_y3 + 9.2 * 25.4
        #     # mdy2=rj_dw_y3 - 9.2 * 25.4
        #     mdy1 = (panel_y_inch * 0.5 - 9.2 - add_number_y) * 25.4
        #     mdy2 = (panel_y_inch * 0.5 + 9.2 - add_number_y) * 25.4
        #     mdk_x_array.extend([mdk_x1, mdk_x1, mdk_x3, mdk_x3])
        #     mdk_y_array.extend([mdy1, mdy2, mdy1, mdy2])
        #     mdk_top_array.extend(['sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t', 'sh-mdk-t'])
        #     mdk_bot_array.extend(['sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b', 'sh-mdk-b'])

        # --四层板铆合，只需要长短边中间共四颗铆钉,参考需求story-view-3438
        # if press_fit_Riveting == '是' and core_count < 2:
        if core_count < 2:
            # --考虑四层板+辅助层可能有两张core的现象，故core_count<2的条件是必须的，参考料号988/840a1
            mdk_x_array = [mdk_x1, mdk_x2, mdk_x2, mdk_x3]
            mdk_y_array = [mdk_y3, mdk_y1, mdk_y5, mdk_fdy3]
            mdk_top_array = ['sh-mdk-t','sh-mdk-t','sh-mdk-t','sh-mdk-t']
            mdk_bot_array = ['sh-mdk-b','sh-mdk-b','sh-mdk-b','sh-mdk-b']

        #锚短边去掉长边的坐标
        if self.parm.short_mao_yes == '是' and ape3000_base == '0.25inch':
            mdk_x_array_new, mdk_y_array_new, mdk_top_array_new,mdk_bot_array_new = [], [], [],[]
            for i in range(len(mdk_x_array)):
                if   panel_x / 4.0 < mdk_x_array[i] < panel_x-(panel_x/4.0):
                    mdk_x_array_new.append(mdk_x_array[i])
                    mdk_y_array_new.append(mdk_y_array[i])
                    mdk_top_array_new.append(mdk_top_array[i])
                    mdk_bot_array_new.append(mdk_bot_array[i])
            mdk_x_array, mdk_y_array, mdk_top_array, mdk_bot_array =mdk_x_array_new, mdk_y_array_new, mdk_top_array_new, mdk_bot_array_new
            if ape3000_base == '0.25inch':
                cz= min(mdk_x_array)
                cz_left1=cz-185.72501
                cz_left2 = cz - 228.90501
                cz_right1=cz+195.27499
                cz_right2=cz+238.45499
                mdk_x_array.extend([cz_left1,cz_left2,cz_right1,cz_right2]*2)
                mdk_y_array.extend([max(mdk_y_array),max(mdk_y_array),max(mdk_y_array),max(mdk_y_array),min(mdk_y_array),min(mdk_y_array),min(mdk_y_array),min(mdk_y_array)])
                mdk_top_array.extend(['sh-mdk-t']*8)
                mdk_bot_array.extend(['sh-mdk-b'] * 8)
            else:
                pass
                #0.5inch 转到最后处理


        # --增加铆钉孔对应的symbol
        #info['内层c'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol=mdk_top_array)
        #info['内层s'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol=mdk_bot_array)
        for index, fill_hash in enumerate(fill_array):
            layer_name = fill_hash.layer_name
            layer_side = fill_hash.layer_side
            copper_thick = fill_hash.copper_thick
            if not info.has_key(layer_name):
                info[layer_name] = []            
            if layer_name in hdi_contain_tag_layer:
                if layer_side == '正':
                    info[layer_name] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol=mdk_top_array)
                else:
                    info[layer_name] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol=mdk_bot_array)
                    
        mdk_x_array_drl,mdk_y_array_drl=mdk_x_array,mdk_y_array

        if "等离子除胶渣" in Flows and "树脂塞孔" in Flows:
        #if sh_site == "胜宏六厂" and "等离子除胶渣" in Flows and "树脂塞孔" in Flows:
            mdk_x_array_drl = [x +1.3 for x in mdk_x_array]+[x -1.3 for x in mdk_x_array] + mdk_x_array
            mdk_y_array_drl=mdk_y_array_drl*3
            mdk_x_array_drl=mdk_x_array_drl+mdk_x_array+mdk_x_array
            mdk_y_array_drl=mdk_y_array_drl+[x +1.3 for x in mdk_y_array]+[x -1.3 for x in mdk_y_array]
            #mdk_y_array_drl = [y + 1.3 for y in mdk_y_array] + [y - 1.3 for y in mdk_y_array] + mdk_y_array



        ####当有多次压合的时候会多加一套铆钉孔，铆钉尺寸随留边的情况而定 2022 01 06
        #[('三压', 'l1', 'l10'), ('二压', 'l2', 'l9'), ('一压', 'l3', 'l8')]#

        lamination = self.parm.lamination
        more_x_list,more_y_list=[],[]
        short_xtmp,  short_ytmp ,long_xtmp,long_ytmp,short_x_nor,short_y_nor= [], [],[],[],[],[]
        long_x_nor,long_y_nor=[],[]
        # --计算短边铆钉到内sr的距离
        short_to_sr_distan = sr_ymin - mdk_y1
        # --计算长边铆钉到内sr的距离
        long_to_sr_distan = sr_xmin - mdk_x1
        ck_fid_x_array_new, ck_fid_y_array_new  = [], []
        # --设置溶胶定位孔的坐标.bot->top->left->right
        rj_dw_x1 = (panel_x_inch * 0.5 + 0.47 - add_number_x) * 25.4
        rj_dw_y1 = (panel_y_inch * 0.5 - xb) * 25.4
        rj_dw_y2 = (panel_y_inch * 0.5 + xa) * 25.4
        # --长边左侧溶胶定位槽x坐标及y坐标
        rj_dw_x3 = (panel_x_inch * 0.5 - yb) * 25.4
        rj_dw_y3 = (panel_y_inch * 0.5 - add_number_y) * 25.4
        # --长边右侧溶胶定位槽x坐标及y坐标
        rj_dw_x4 = (panel_x_inch * 0.5 + ya) * 25.4
        rj_dw_y4 = (panel_y_inch * 0.5 - add_number_y + 0.18799175) * 25.4
        # --溶胶定位防呆孔,仅在短边top有，且如果与靶孔重叠时，可以不加，删除处理
        rj_dwfd_x = (panel_x_inch * 0.5 - add_number_x) * 25.4
        rj_dwfd_y = (panel_y_inch * 0.5 + xa) * 25.4
        rj_dw_x_array_n,rj_dw_y_array_n=[],[]

        rj_dw_x3_n = rj_dw_x3
        rj_dw_x4_n = rj_dw_x4
        rj_dw_y1_n = rj_dw_y1
        rj_dw_y2_n = rj_dw_y2
        short_rj_x_dw_tmp,short_rj_y_dw_tmp=[],[]
        long_rj_x_dw_tmp, long_rj_y_dw_tmp=[],[]
        #msgBox().critical(self, '警告', json.dumps(lamination, indent=4, ensure_ascii=False), QMessageBox.Ok)

        if len(lamination)>1  and False: ##暂时屏蔽
            if short_to_sr_distan <14:
                ###短边留边小于14时 y 轴的铆钉尺寸和图形位置不变
                y_size=md_y
            else:
                y_size=md_y-jingzhi

                rj_dw_y1=rj_dw_y1+(jingzhi/2.0)*25.4
                rj_dw_y2=rj_dw_y2-(jingzhi/2.0)*25.4

                for x,y in zip(mdk_x_array,mdk_y_array):
                    if sr_xmin<x<sr_xmax:
                        short_xtmp.append(x)
                        short_ytmp.append(y+(jingzhi/2.0)*25.4) if y<panel_y*0.5 else short_ytmp.append(y-(jingzhi/2.0)*25.4)
                        short_x_nor.append(x)
                        short_y_nor.append(y)

            if long_to_sr_distan<14:
            ###长边边留边小于14时 x 轴的铆钉尺寸和图形位置不变
                x_size = md_x
            else:

                rj_dw_x3=rj_dw_x3+(jingzhi/2.0)*25.4
                rj_dw_x4=rj_dw_x4-(jingzhi/2.0)*25.4
                x_size = md_x - jingzhi
                for x, y in zip(mdk_x_array, mdk_y_array):
                    if sr_ymin < y < sr_ymax:
                        long_xtmp.append(x+(jingzhi/2.0)*25.4) if x < panel_x * 0.5 else long_xtmp.append(x-(jingzhi/2.0)*25.4)
                        long_ytmp.append(y)
                        long_x_nor.append(x)
                        long_y_nor.append(y)
            more_x_list=short_xtmp+long_xtmp
            more_y_list=short_ytmp+long_ytmp
            more_x_nor=short_x_nor+long_x_nor
            more_y_nor=short_y_nor+long_y_nor
            rj_dw_x_array = [rj_dw_x1, rj_dw_x1, rj_dw_x3, rj_dw_x4]
            rj_dw_y_array = [rj_dw_y1, rj_dw_y2, rj_dw_y3, rj_dw_y4]

            rj_dw_x_array_n=[rj_dw_x1, rj_dw_x1, rj_dw_x3_n, rj_dw_x4_n]
            rj_dw_y_array_n = [rj_dw_y1_n, rj_dw_y2_n, rj_dw_y3, rj_dw_y4]
            rj_dw_sym_top = ['sh-rj3-t', 'sh-rj3-t', 'sh-rj2-t', 'sh-rj2-t']
            rj_dw_sym_bot = ['sh-rj3-b', 'sh-rj3-b', 'sh-rj2-b', 'sh-rj2-b']
            send_inn=[]
            for yh,start,end in lamination:
                for i in range(int(start[1:])+1,int(end[1:])):
                    if int(start[1:]) == 1:continue
                    send_inn.append(["l"+str(x) for x in range(int(start[1:])+1,int(end[1:]))])
                    if (i - int(start[1:])) % 2 == 1:
                        symbol= 'sh-mdk-t'
                        symbol_op="sh-bb-min"
                        symbol_cao=rj_dw_sym_top
                    else:
                        symbol="sh-mdk-b"
                        symbol_op="sh-bb1-min"
                        symbol_cao = rj_dw_sym_bot
                    if not info.has_key('l%s'%i):
                        info['l%s' % i]=self.convert_to_dict(x_list=more_x_nor, y_list=more_y_nor, symbol="s8000",polarity='negative')
                        info['l%s' % i].extend(self.convert_to_dict(x_list=more_x_list, y_list=more_y_list, symbol="s8000",attribute='.string,text=dp'))
                        info['l%s' % i].extend (self.convert_to_dict(x_list=more_x_list, y_list=more_y_list, symbol=symbol))
                        info['l%s' % i].extend(self.convert_to_dict(x_list=rj_dw_x_array_n, y_list=rj_dw_y_array_n, symbol="rect12100x9520",attribute='.string,text=dp_n',polarity='negative'))
                        info['l%s' % i].extend(self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol="rect12100x9520",attribute='.string,text=dp'))

                        info['l%s' % i].extend(self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=symbol_cao))
                    else:
                        info['l%s' % i].extend(self.convert_to_dict(x_list=more_x_nor, y_list=more_y_nor, symbol="s8000",polarity='negative'))
                        info['l%s' % i].extend(self.convert_to_dict(x_list=more_x_list, y_list=more_y_list, symbol="s8000",attribute='.string,text=dp'))
                        info['l%s' % i] .extend (self.convert_to_dict(x_list=more_x_list, y_list=more_y_list,symbol=symbol))
                        info['l%s' % i].extend(self.convert_to_dict(x_list=rj_dw_x_array_n, y_list=rj_dw_y_array_n, symbol="rect12100x9520",attribute='.string,text=dp_n',polarity='negative'))
                        info['l%s' % i].extend(self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol="rect12100x9520",attribute='.string,text=dp'))
                        info['l%s' % i].extend(self.convert_to_dict(x_list=rj_dw_x_array, y_list=rj_dw_y_array, symbol=symbol_cao))
                        info['l%s' % i].extend(self.convert_to_dict(x_list=more_x_nor, y_list=more_y_nor, symbol="s8000",polarity='negative'))
                    ###加冲孔光学点 加两套
                    ii = 0
                    for x, y in zip(ck_fid_x_array,ck_fid_y_array):
                        if long_to_sr_distan > 14:
                            if x<panel_x/4.0:
                                #左边的
                                ck_fid_x_array_new.append(x+jingzhi/2.0*25.4)
                                ck_fid_y_array_new.append(y)
                            if x>3*panel_x/4.0:
                                #右边的
                                ck_fid_x_array_new.append(x - jingzhi / 2.0 * 25.4)
                                ck_fid_y_array_new.append(y)
                        if short_to_sr_distan >14:
                            if y<panel_y/4.0:
                                #下面
                                ck_fid_x_array_new.append(x)
                                ck_fid_y_array_new.append(y+jingzhi / 2.0 * 25.4)
                            if  y>3*panel_y/4.0:
                                #上
                                ck_fid_x_array_new.append(x)
                                ck_fid_y_array_new.append(y - jingzhi / 2.0 * 25.4)
                        else:
                            pass
                        if not info.has_key('l%s'%i):
                            info['l%s'%i] = self.convert_to_dict(x_list=ck_fid_x_array_new, y_list=ck_fid_y_array_new, symbol=symbol_op,angle=ck_fid_a_array[ii])
                            info['l%s' % i] .extend (self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array,symbol="r6301",angle=ck_fid_a_array[ii],polarity='negative'))
                        else:
                            info['l%s' % i] .extend (self.convert_to_dict(x_list=ck_fid_x_array_new, y_list=ck_fid_y_array_new,symbol=symbol_op,angle=ck_fid_a_array[ii]))
                            info['l%s' % i] .extend (self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array,symbol="r6301",angle=ck_fid_a_array[ii],polarity='negative'))
                        ii+=1

        # ---正常多层料号和HDI料号都一样
        if self.JOB[6] in ['l','h']:
            info['通孔'] = self.convert_to_dict(x_list=mdk_x_array_drl, y_list=mdk_y_array_drl, symbol='r4000')
            info['通孔'].extend(self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r6000'))
            if put_copper_md == 'no':
                # --档点不铺铜时,D+20正极性copy到档点
                # --20210301刘文东要求修改为1:1档油
                info['档点'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r6000')
            # --防焊D+20套负片,依据story-view-2735,防止上锡
            info['防焊'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r6508', polarity='negative')
            # --选化D+20套负片
            info['选化'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r6508', polarity='negative')
        else:
            pass
            # info['通孔'] = self.convert_to_dict(x_list=mdk_x_array_drl, y_list=mdk_y_array_drl, symbol='r2000',attribute='.string,text=fbk_md')
            # if put_copper_md == 'no':
                # --档点不铺铜时,D+20正极性copy到档点
            # info['档点'] = self.convert_to_dict(x_list=mdk_x_array_drl, y_list=mdk_y_array_drl, symbol='r2254')
            # # --选化D+20套负片
            # info['选化'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r2508', polarity='negative')
            # info['防焊'] = self.convert_to_dict(x_list=mdk_x_array_drl, y_list=mdk_y_array_drl, symbol='r2254')
            # info['外层'] = self.convert_to_dict(x_list=mdk_x_array_drl, y_list=mdk_y_array_drl, symbol='r2508')
            # info['蚀刻引线'] = self.convert_to_dict(x_list=mdk_x_array_drl, y_list=mdk_y_array_drl, symbol='r2508')



        # --inn-pp层symbol坐标列表定义,铆钉孔对应inn-pp层加r3600
        info['inn-pp'] = self.convert_to_dict(x_list=mdk_x_array, y_list=mdk_y_array, symbol='r3600')

        # --增加冲孔光学点
        #info['内层c'].extend(self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array, symbol=ck_fid_sym_top,
                                                    #angle=ck_fid_a_array))
        #info['内层s'].extend(self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array, symbol=ck_fid_sym_bot,
                                                    # angle=ck_fid_a_array))
        for index, fill_hash in enumerate(fill_array):
            layer_name = fill_hash.layer_name
            layer_side = fill_hash.layer_side
            copper_thick = fill_hash.copper_thick
            if not info.has_key(layer_name):
                info[layer_name] = []
                
            if layer_name in hdi_contain_tag_layer:
                if layer_side == '正':
                    info[layer_name].extend(self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array, symbol=ck_fid_sym_top,
                                                                angle=ck_fid_a_array))
                else:
                    info[layer_name].extend(self.convert_to_dict(x_list=ck_fid_x_array, y_list=ck_fid_y_array, symbol=ck_fid_sym_bot,
                                                            angle=ck_fid_a_array))
                
        DP_SY=['s8000' for i in range(len(mdk_y_array))  ]
        ##垫pad窄边会加到进板露铜,垫pad往板外移动1mm
        #
        L_margin = self.parm.L_margin
        R_margin = self.parm.R_margin
        U_margin = self.parm.U_margin
        D_margin = self.parm.D_margin
        dpmdk_x_array = mdk_x_array
        dpmdk_y_array = mdk_y_array
        for i in range(len(dpmdk_x_array)):
            if U_margin < 13 and sr_xmin < dpmdk_x_array[i] < sr_xmax and dpmdk_y_array[i] > panel_y / 2: dpmdk_y_array[i] += 1
            if D_margin < 13 and sr_xmin < dpmdk_x_array[i] < sr_xmax and dpmdk_y_array[i] < panel_y / 2: dpmdk_y_array[i] -= 1
            if L_margin < 13 and sr_ymin < dpmdk_y_array[i] < sr_ymax and dpmdk_x_array[i] < panel_x / 2: dpmdk_x_array[i] -= 1
            if R_margin < 13 and sr_ymin < dpmdk_y_array[i] < sr_ymax and dpmdk_x_array[i] > panel_x / 2: dpmdk_x_array[i] += 1
        # 锚短边去掉长边的坐标
        if self.parm.short_mao_yes == '是' and ape3000_base == '0.25inch':
            dpmdk_x_array_new, dpmdk_y_array_new, DP_SY_new = [], [], []
            for i in range(len(dpmdk_x_array)):
                if panel_x / 4.0<dpmdk_x_array[i]  <panel_x-(panel_x/4.0):
                    dpmdk_x_array_new.append(dpmdk_x_array[i])
                    dpmdk_y_array_new.append(dpmdk_y_array[i])
                    DP_SY_new.append(DP_SY[i])
            dpmdk_x_array, dpmdk_y_array, DP_SY=dpmdk_x_array_new, dpmdk_y_array_new, DP_SY_new
            if ape3000_base == '0.25inch':
                # cz= min(mdk_x_array)
                # cz_left1=cz-185.72501
                # cz_left2 = cz - 228.90501
                # cz_right1=cz+195.27499
                # cz_right2=cz+238.45499
                dpmdk_x_array.extend([cz_left1,cz_left2,cz_right1,cz_right2]*2)
                dpmdk_y_array.extend([max(mdk_y_array),max(mdk_y_array),max(mdk_y_array),max(mdk_y_array),min(mdk_y_array),min(mdk_y_array),min(mdk_y_array),min(mdk_y_array)])
                DP_SY.extend(['s8000']*8)
            else:
                pass
                # 0.5inch 转到最后处理

        #多次亚和内层掏开
        #info['内层c']= self.convert_to_dict(x_list=dpmdk_x_array, y_list=dpmdk_y_array, symbol=DP_SY,attribute='.string,text=dp')+info['内层c']
        #info['内层s'] =self.convert_to_dict(x_list=dpmdk_x_array, y_list=dpmdk_y_array, symbol=DP_SY,attribute='.string,text=dp')+info['内层s']
        for index, fill_hash in enumerate(fill_array):
            layer_name = fill_hash.layer_name
            layer_side = fill_hash.layer_side
            copper_thick = fill_hash.copper_thick
            if not info.has_key(layer_name):
                info[layer_name] = []            
            if layer_name in hdi_contain_tag_layer:
                if layer_side == '正':
                    info[layer_name] = self.convert_to_dict(x_list=dpmdk_x_array, y_list=dpmdk_y_array, symbol=DP_SY,attribute='.string,text=dp') + info[layer_name]
                else:
                    info[layer_name] = self.convert_to_dict(x_list=dpmdk_x_array, y_list=dpmdk_y_array, symbol=DP_SY,attribute='.string,text=dp') + info[layer_name]            

        return info


class Range_hole(STATIC_SYM):
    """
    inn-pp层加四个范围孔
    """

    def __init__(self, frozen_json=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        job_signal_numbers = self.parm.job_signal_numbers
        put_copper_md = self.parm.put_copper_md
        core_count = self.parm.core_count
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_xmin = self.parm.profile_xmin
        profile_ymin = self.parm.profile_ymin
        inn_x1 = profile_xmin + 2
        inn_x2 = profile_xmax - 2
        inn_y1 = profile_ymin + 2
        inn_y2 = profile_ymax - 2
        inn_x_list = [inn_x1, inn_x1, inn_x2, inn_x2]
        inn_y_list = [inn_y1, inn_y2, inn_y1, inn_y2]
        if core_count >= 2:
            # --两张core以上,不管是否HDI,都要加溶合symbol,则就需要加inn-pp
            info['inn-pp'] = self.convert_to_dict(x_list=inn_x_list, y_list=inn_y_list, symbol='r2050')
        return info


#
# class tag_xray(STATIC_SYM):
#     """
#     靶孔
#     """
#     def __init__(self,frozen_json=None,priority=1):
#         self.parm = frozen_json
#         self.priority = priority
#         self.avoidType = 'inner'
#         STATIC_SYM.__init__(self,priority=priority,avoidType=self.avoidType)
#
#     def get_sym_info(self):
#         """
#         获取symbol添加时的坐标极性等相关信息
#         :return:
#         :rtype:
#         """
#         hdi_num = self.parm.hdi_num
#         if hdi_num >= 1:
#             # --HDI板不加三靶
#             info = {}
#             return info
#         L_margin = self.parm.L_margin
#         profile_xmax = self.parm.profile_xmax
#         profile_ymax = self.parm.profile_ymax
#         sr_xmin = self.parm.sr_xmin
#         sr_xmax = self.parm.sr_xmax
#         sr_ymin = self.parm.sr_ymin
#         sr_ymax = self.parm.sr_ymax
#         panel_x = self.parm.panel_x
#         panel_y = self.parm.panel_y
#         rout_x = self.parm.rout_x
#         rout_y = self.parm.rout_y
#         margin_rout_x = (panel_x - rout_x)/2
#         margin_rout_y = (panel_y - rout_y)/2
#         top_after_margin = self.parm.top_after_margin
#         left_after_margin = self.parm.left_after_margin
#
#         sh_site = self.parm.sh_site
#         job_signal_numbers = self.parm.job_signal_numbers
#         sel_finger = self.parm.sel_finger
#         add_first_plant = self.parm.add_first_plant
#         ck_fid_x1 = self.parm.ck_fid_x1
#         panel_case = self.parm.panel_case
#         flow_content = self.parm.flow_content
#         put_copper_out = self.parm.put_copper_out
#         put_copper_md = self.parm.put_copper_md
#         add_hj_panel = self.parm.add_hj_panel
#         add_px_panel = self.parm.add_px_panel
#         # --PE3000冲孔进制(0.25inch或者0.5inch)
#         ape3000_base = self.parm.ape3000_base
#         add_number_x = self.parm.add_number_x
#         global tag_distance_x
#         global tag_distance_y
#         global tag_y1
#         global tag_y2
#         global tag_x1
#         global tag_x2
#         tag_x1, tag_x2, tag_y1, tag_y2, backup_tag_y1, backup_tag_y2 = None, None, None, None, None, None
#         tag_distance_x = 0
#         tag_distance_y = 0
#         tag_rect_x_list = []
#         tag_rect_y_list = []
#         tag_text_x_list = []
#         tag_text_y_list = []
#         tag_rect_sym = 'rect6350x1905'
#         tag_text_angle = 90
#         xray_x_list = []
#         xray_y_list = []
#         xray_sym = []
#         # --一压才会有靶距数据，不存在时会报keyError
#         try:
#             Bar_x = self.parm.Bar_x
#         except KeyError:
#             Bar_x = None
#         try:
#             Bar_y = self.parm.Bar_y
#         except KeyError:
#             Bar_y = None
#         try:
#             backupBar = self.parm.Bar_Backup
#         except KeyError:
#             backupBar = None
#
#         # if U_margin < 7 or D_margin < 7:
#         # --改为锣边后的留边大小,2021.1.21李家兴，参考料号685/134a2
#         if top_after_margin < 7:
#             # --短边留边不够7mm,靶孔加在长边的情况,四层板留边通常很窄,且2021.1.18更改规则锣边不等于开料，这种情况更普遍
#             tmp = profile_ymax * 0.5 + 56 - 300
#             if tmp < 66:
#                 tag_y1 = sr_ymin + 66
#             elif tmp < 76:
#                 tag_y1 = sr_ymin + 76
#             elif tmp < 86:
#                 tag_y1 = sr_ymin + 86
#             elif tmp < 96:
#                 tag_y1 = sr_ymin + 96
#             elif tmp < 106:
#                 tag_y1 = sr_ymin + 106
#             elif tmp < 109:
#                 tag_y1 = sr_ymin + 109
#                 pass
#             if job_signal_numbers == 4:
#                 tag_y2 = profile_ymax * 0.5
#             else:
#                 tag_y2 = profile_ymax * 0.5 + 19.5
#
#             # --定义左边x坐标
#             if top_after_margin >= 7 and top_after_margin < 8:
#                 tag_x1 = sr_xmin - 4
#                 tag_x2 = sr_xmax + 4
#             elif top_after_margin >= 8 and top_after_margin < 9:
#                 tag_x1 = sr_xmin - 4.5
#                 tag_x2 = sr_xmax + 4.5
#             elif top_after_margin >= 9 and top_after_margin < 10.1:
#                 tag_x1 = sr_xmin - 5
#                 tag_x2 = sr_xmax + 5
#             else:
#                 if margin_rout_x + 4.6 + 3.5 <= L_margin:
#                     # 单边锣边2mm，极限：2+4.6+3.5=10.1,其中3.5mm为靶标单边宽度，4.6(靶中心到锣边)为防呆起始值(4.6-10区间0.5mm做防呆)
#                     tag_x1 = margin_rout_x + 4.6
#                     tag_x2 = panel_x - margin_rout_x - 4.6
#                 else:
#                     # 如果锣边超过2mm,靶标会加进板内，需优先保证靶标不进板内
#                     tag_x1 = sr_xmin - 6
#                     tag_x2 = sr_xmax + 6
#
#             # --取数据库中的数据
#             if Bar_x and Bar_y and backupBar:
#                 if job_signal_numbers == 4:
#                     tag_y2 = profile_ymax * 0.5
#                 tag_y1 = tag_y2 - Bar_y
#                 # --x坐标等于profile中心加靶距*0.5
#                 tag_x1 = profile_xmax * 0.5 - Bar_x * 0.5
#                 tag_x2 = profile_xmax * 0.5 + Bar_x * 0.5
#
#             # --正靶坐标列表
#             tag_x_list = [tag_x2,tag_x1,tag_x2]
#             tag_y_list = [tag_y1,tag_y2,tag_y2]
#             tag_angle  = [0,0,270]
#             tag_sym = ['sh-baa', 'sh-bab', 'sh-bac']
#
#             # --20210122李家兴加大17mm,因为板边symbol太多,会重叠,InPlan系统也加大了17mm,见樊后星备注
#             tag_dw_y2 =  sr_ymax - 20 - 17
#             tag_dw_y1 =  sr_ymin + 20 + 17
#             if Bar_x and Bar_y and backupBar:
#                 tag_dw_y2 = profile_ymax * 0.5 + backupBar/2
#                 tag_dw_y1 = profile_ymax * 0.5 - backupBar/2
#             if sel_finger == "是" and add_first_plant == "no":
#                 tag_dw_y1fd = sr_ymin + 20 - 12.5
#                 tag_distance_y = tag_dw_y2 - tag_dw_y1fd
#             else:
#                 tag_dw_y1fd = sr_ymin + 20
#                 tag_distance_y = tag_dw_y2 - tag_dw_y1
#             tag_distance_x = tag_x2 - tag_x1
#             # --备靶坐标列表
#             tag_x_list2 = [tag_x1,tag_x1,tag_x2,tag_x2]
#             tag_y_list2 = [tag_dw_y1,tag_dw_y2,tag_dw_y1,tag_dw_y2]
#
#             # --底部方向靶左侧加料号名
#             tag_rect_y = tag_y2 + 4.445
#             tag_rect_y1 = tag_y2 + 4.445 - 0.75
#             tag_rect_x1 = tag_x1 - 2.8
#             tag_rect_x_list = [tag_x1]
#             tag_rect_y_list = [tag_rect_y]
#             tag_text_x_list = [tag_rect_x1]
#             tag_text_y_list = [tag_rect_y1]
#             tag_rect_sym = 'rect6350x1905'
#             tag_text_angle = 0
#         else:
#             """
#             靶孔到两个长边的距离尽量做到相等，若无法做到相等时，距两长边距离之差要小于等于30mm
#             """
#             # --短边留边超过7mm,靶孔加在短边的情况
#             tmp = profile_xmax * 0.5 + 56 - 300
#             if tmp < 66:
#                 tag_x1 = sr_xmin + 66
#             elif tmp < 76:
#                 tag_x1 = sr_xmin + 76
#             elif tmp < 86:
#                 tag_x1 = sr_xmin + 86
#             elif tmp < 96:
#                 tag_x1 = sr_xmin + 96
#             elif tmp < 106:
#                 tag_x1 = sr_xmin + 106
#             elif tmp < 109:
#                 tag_x1 = sr_xmin + 109
#             if job_signal_numbers <= 4:
#                 # --四层板和双面板inn孔居中
#                 tag_x2 = profile_xmax * 0.5
#                 tmp_content = self.JOB[6]
#                 if job_signal_numbers == 2 and tmp_content in ['h','l']:
#                     # --喷锡料号会加挂孔,会与inn孔冲突,inn孔向左移
#                     tag_x2 = tag_x2 - (3.2+3.175)/2 - 5.5
#             else:
#                 tag_x2 = ck_fid_x1 * 25.4 - 12
#
#             # --2019.11.25李家兴依据story-view-674将靶距下限从100修改为50mm
#             tag_distance = tag_x2 - tag_x1
#             if tag_distance < 50:
#                 dif_value = 50 - tag_distance
#                 if dif_value < 25:
#                     tag_x2 = tag_x2 + 25
#                 else:
#                     tag_x2 = tag_x2 + dif_value
#
#             # --定义靶孔y坐标
#             if top_after_margin >= 7 and top_after_margin < 8:
#                 tag_y1 = sr_ymin - 4
#                 tag_y2 = sr_ymax + 4
#             elif top_after_margin >= 8 and top_after_margin < 9:
#                 tag_y1 = sr_ymin - 4.5
#                 tag_y2 = sr_ymax + 4.5
#             elif top_after_margin >= 9 and top_after_margin < 10.1:
#                 tag_y1 = sr_ymin - 5
#                 tag_y2 = sr_ymax + 5
#             else:
#                 if margin_rout_y + 4.6 + 3.5 <= top_after_margin:
#                     # 单边锣边2mm，极限：2+4.6+3.5=10.1,其中3.5mm为靶标单边宽度，4.6(靶中心到锣边)为防呆起始值(4.6-10区间0.5mm做防呆)
#                     tag_y1 = margin_rout_y + 4.6
#                     tag_y2 = panel_y - margin_rout_y - 4.6
#                 else:
#                     # 如果锣边超过2mm,靶标会加进板内，需优先保证靶标不进板内
#                     tag_y1 = sr_ymin - 6
#                     tag_y2 = sr_ymax + 6
#
#             # --正靶在短边，备靶在长边,依据左右留边宽度而定
#             if left_after_margin >= 7 and left_after_margin < 8:
#                 backup_tag_x1 = sr_xmin - 4
#                 backup_tag_x2 = sr_xmax + 4
#             elif left_after_margin >= 8 and left_after_margin < 9:
#                 backup_tag_x1 = sr_xmin - 4.5
#                 backup_tag_x2 = sr_xmax + 4.5
#             elif left_after_margin >= 9 and left_after_margin < 10.1:
#                 backup_tag_x1 = sr_xmin - 5
#                 backup_tag_x2 = sr_xmax + 5
#             else:
#                 if margin_rout_x + 4.6 + 3.5 <= left_after_margin:
#                     # 单边锣边2mm，极限：2+4.6+3.5=10.1,其中3.5mm为靶标单边宽度，4.6(靶中心到锣边)为防呆起始值(4.6-10区间0.5mm做防呆)
#                     backup_tag_x1 = margin_rout_x + 4.6
#                     backup_tag_x2 = panel_x - margin_rout_x - 4.6
#                 else:
#                     # 如果锣边超过2mm,靶标会加进板内，需优先保证靶标不进板内
#                     backup_tag_x1 = sr_xmin - 6
#                     backup_tag_x2 = sr_xmax + 6
#
#             if profile_xmax >= 600:
#                 # --发料大于600时，方向靶c靶，b靶居中
#                 tag_x2 = profile_xmax * 0.5
#
#             if Bar_x and Bar_y and backupBar:
#                 if job_signal_numbers == 4:
#                     tag_x2 = profile_xmax * 0.5
#                 else:
#                     tag_x2 = ck_fid_x1 * 25.4 - 12
#                 tag_x1 = tag_x2 - Bar_x
#
#                 if tag_x2 > 315:
#                     # --此时会与融合光学点冲突，故修正坐标
#                     tag_x2 = ck_fid_x1 * 25.4 - 12 - 22
#                     tag_x1 = tag_x2 - Bar_x
#                     if ape3000_base == '0.25inch':
#                         # --ape3000 0.25进制时,方向靶肯定与铆钉冲突,方向靶只能向右移6.24mm,极限a11/059c3 tag_x2大于315mm,保证X1-X2不超过30mm即可
#                         if add_number_x == 0.125:
#                             # --此时整体向左偏移0.125inch
#                             tag_x2 = ck_fid_x1 * 25.4 - 12 - 22 + 6.24 - 0.125*25.4
#                             tag_x1 = tag_x2 - Bar_x
#                         else:
#                             tag_x2 = ck_fid_x1 * 25.4 - 12 - 22 + 6.24
#                             tag_x1 = tag_x2 - Bar_x
#
#                 # --y坐标等于profile中心加靶距*0.5
#                 tag_y1 = profile_ymax * 0.5 - Bar_y * 0.5
#                 tag_y2 = profile_ymax * 0.5 + Bar_y * 0.5
#                 # --备靶x坐标等于profile x中心加备靶靶距*0.5
#                 backup_tag_x1 = profile_xmax * 0.5 - backupBar * 0.5
#                 backup_tag_x2 = profile_xmax * 0.5 + backupBar * 0.5
#
#
#             # --正靶坐标列表
#             tag_x_list = [tag_x1, tag_x2, tag_x2]
#             tag_y_list = [tag_y2, tag_y1, tag_y2]
#             tag_angle = [0, 0, 0]
#             tag_sym = ['sh-baa', 'sh-bab', 'sh-bac']
#
#             tag_x_list2 = []
#             tag_y_list2 = []
#             if panel_case == "case2" or panel_case == "case1":
#                 # --小于9mm时加四颗备靶
#                 tag_dw_x1 =  sr_xmin + 7.323 + 7 + 4
#                 tag_dw_x2 =  sr_xmax - 3 - 7 - 4
#                 tag_dw_x1fd = sr_xmin + 7.323 + 2
#                 # --20210203李家兴发现a47/004c3备靶跑到板内而修改此规则
#                 tag_dw_x1 = sr_xmin + 5
#                 tag_dw_x2 = sr_xmax - 5
#                 # tag_dw_x1 = backup_tag_x1
#                 # tag_dw_x2 = backup_tag_x2
#                 tag_dw_x1fd = tag_dw_x1 - 3
#                 if sel_finger == "是" and add_first_plant == "no":
#                     # --二厂且是手指选化时防呆
#                     tag_x_list2.append(tag_dw_x1fd)
#                 else:
#                     # --其它不防呆
#                     tag_x_list2.append(tag_dw_x1)
#                 tag_y_list2.append(tag_y2)
#                 tag_x_list2.extend([tag_dw_x2,tag_dw_x1,tag_dw_x2])
#                 tag_y_list2.extend([tag_y2,tag_y1,tag_y1])
#                 tag_distance_x = tag_dw_x2 - tag_dw_x1
#             else:
#                 # --2020.10.29李家兴依据story-view-2226修正坐标,紧靠挂pin孔上方添加
#                 backup_tag_y = profile_ymax * 0.5 - 118
#
#                 # --优化后放在rj_dw对位槽正上方10mm处
#                 add_number_y = self.parm.add_number_y
#                 panel_y_inch = float(panel_y) * 0.03937
#                 rj_dw_y4 = (panel_y_inch * 0.5 - add_number_y + 0.18799175) * 25.4
#                 # --rj_dw槽单边宽3.81,备靶单边宽3.5
#                 backup_tag_y = rj_dw_y4 + 3.81 + 10 + 3.5
#
#                 # --在rj_dw槽下面的溶胶块之上添加备靶,20210125李家兴修改到此位置
#                 rj_dw_y3 = (panel_y_inch * 0.5 - add_number_y) * 25.4
#                 rm_dw_sym_y5 = rj_dw_y3 - 76.4
#                 # --溶胶块中心到顶12mm,备靶单边宽3.5mm,symbol到symbol保证边到边10mm
#                 backup_tag_y = rm_dw_sym_y5 + 12 + 10 + 3.5
#
#                 tag_x_list2 = [backup_tag_x1,backup_tag_x2]
#                 tag_y_list2 = [backup_tag_y,backup_tag_y]
#                 tag_distance_x = backup_tag_x2 - backup_tag_x1
#             tag_distance_y = tag_y2 - tag_y1
#
#             # --底部方向靶左侧加料号名
#             tag_rect_x = tag_x2 - 4.445
#             tag_rect_x1 = tag_x2 - 4.445 - 0.75
#             tag_rect_y1 = tag_y1 + 2.8
#             tag_rect_x_list = [tag_rect_x]
#             tag_rect_y_list = [tag_y1]
#             tag_text_x_list = [tag_rect_x1]
#             tag_text_y_list = [tag_rect_y1]
#             tag_rect_sym = 'rect1905x6350'
#
#             if sh_site == '胜宏五厂':
#                 xray_y1 = tag_y1
#                 xray_y2 = tag_y2
#                 to_center = 41.75
#                 if job_signal_numbers >= 6:
#                     to_center = ck_fid_x1 * 25.4 + 10 - profile_xmax * 0.5
#                 xray_x1 = profile_xmax * 0.5 - to_center
#                 xray_x2 = profile_xmax * 0.5 + to_center
#                 xray_x_list = [xray_x1,xray_x2,xray_x1,xray_x2]
#                 xray_y_list = [xray_y1,xray_y1,xray_y2,xray_y2]
#                 xray_sym = ['xray-lower','xray-lower','xray-upper','xray-upper']
#
#         tag_distance_x = '%.2f' % tag_distance_x
#         tag_distance_y = '%.2f' % tag_distance_y
#         # --坐标list
#         if job_signal_numbers == 2:
#             # --两层板,不需要靶孔,但需要inn层加三个r3200的孔
#             # ----------------------------------------------------------------------------------------------------------
#             info = {}
#             info['inn'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol='r3200')
#             # --档点不铺铜时,D+20正极性copy到档点
#             if put_copper_md == 'no':
#                 info['档点'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol='r3708')
#             info['选化'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list, symbol='r3708',polarity='negative')
#
#             # --两层板,外层防焊第四个r0
#             r0_x1 = profile_xmax * 0.5 + 15
#             r0_y1 = sr_ymin * 0.5
#             info['通孔'] = self.convert_to_dict(x_list=[r0_x1], y_list=[r0_y1],symbol='r3175')
#             # --档点不铺铜时,D+20正极性copy到档点
#             if put_copper_md == 'no':
#                 info['档点'].extend(self.convert_to_dict(x_list=[r0_x1], y_list=[r0_y1],symbol='r3683'))
#             # --选化D+20套负片
#             info['选化'] = self.convert_to_dict(x_list=[r0_x1], y_list=[r0_y1],symbol='r3683',polarity='negative')
#
#             if put_copper_out == 'yes':
#                 # --双面板底部r0,20200717李家兴依据story-view-1581修改，增加单边30mil的RING,以防VGT卡板切断
#                 info['外层'] = self.convert_to_dict(x_list=[r0_x1], y_list=[r0_y1],symbol='r5715',polarity='positive')
#                 info['外层'].extend(self.convert_to_dict(x_list=[r0_x1], y_list=[r0_y1], symbol='r4191',polarity='negative'))
#                 # --双面板inn孔对应外层,20200717李家兴依据story-view-1581要求增加单边30mil的Ring,VGA卡板切边后，保证铜皮完整性
#                 info['外层'].extend(self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list, symbol='r5232'))
#             else:
#                 info['外层'] = self.convert_to_dict(x_list=[r0_x1], y_list=[r0_y1], symbol='r4191', polarity='negative')
#                 # --inn孔对应外层净空
#                 info['外层'].extend(self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list, symbol='r3708', polarity='negative'))
#             # --添加短边底部的r0
#             info['外层'].extend(self.convert_to_dict(x_list=[r0_x1], y_list=[r0_y1], symbol='r0', attribute='.out_flag,int=226'))
#             # --文字D+6mil套开,20210406李家兴依据story-view-2868修改
#             info['文字'] = self.convert_to_dict(x_list=[r0_x1], y_list=[r0_y1], symbol='r3327.4', polarity='negative')
#             info['文字'].extend(self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list, symbol='r3352.4', polarity='negative'))
#             # --文字加r0
#             info['文字'].extend(self.convert_to_dict(x_list=[r0_x1], y_list=[r0_y1], symbol='r0', attribute='.out_flag,int=226'))
#             return info
#
#         # --正常4层以上板添加三靶
#         # --------------------------------------------------------------------------------------------------------------
#         info = {
#             '内层' : self.convert_to_dict(x_list=tag_x_list,y_list=tag_y_list,angle=tag_angle,symbol=tag_sym),
#             '辅助层' : self.convert_to_dict(x_list=tag_x_list,y_list=tag_y_list,angle=tag_angle,symbol=tag_sym),
#             'inn' : self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol='r3125'),
#             'rvc.inn' : self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol='r3125'),
#             '机械盲孔inn': self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list, symbol='r3125'),
#         }
#
#         # --档点不铺铜时,D+20正极性copy到档点
#         if put_copper_md == 'no':
#             info['档点'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol='r3633')
#         info['选化'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol='r3633')
#
#         # --内层添加备靶
#         info['内层'].extend(self.convert_to_dict(x_list=tag_x_list2,y_list=tag_y_list2,symbol='sh-ba'))
#         info['辅助层'].extend(self.convert_to_dict(x_list=tag_x_list2,y_list=tag_y_list2,symbol='sh-ba'))
#
#         # --内层底部靶标附近添加料号名后五码
#         if len(tag_text_x_list) > 0:
#             # --方形pad
#             info['内层'].extend(self.convert_to_dict(x_list=tag_rect_x_list, y_list=tag_rect_y_list,symbol=tag_rect_sym))
#             info['辅助层'].extend(self.convert_to_dict(x_list=tag_rect_x_list, y_list=tag_rect_y_list,symbol=tag_rect_sym))
#             # --文字
#             info['内层'].extend(self.convert_to_dict(x_list=tag_text_x_list, y_list=tag_text_y_list, text='$$zuanzi',
#                                                    x_size='1.27', y_size='1.524', w_factor=0.6666666865, angle=tag_text_angle,
#                                                    mirror='no', polarity='negative'))
#             info['辅助层'].extend(self.convert_to_dict(x_list=tag_text_x_list, y_list=tag_text_y_list, text='$$zuanzi',
#                                                     x_size='1.27', y_size='1.524', w_factor=0.6666666865, angle=tag_text_angle,
#                                                     mirror='no', polarity='negative'))
#
#         # --2020.01.16李家兴依据story-view-916添加,仅五厂添加
#         if len(xray_x_list) > 0:
#             info['内层'].extend(self.convert_to_dict(x_list=xray_x_list, y_list=xray_y_list,symbol=xray_sym))
#             info['辅助层'].extend(self.convert_to_dict(x_list=xray_x_list, y_list=xray_y_list,symbol=xray_sym))
#
#         # 外层防焊第四个r0
#         # --------------------------------------------------------------------------------------------------------------
#         if flow_content == '二次铜':
#             # --一厂二次铜，inn孔做成D+20mil PTH,20201031李家兴依据story-view-690添加
#             info['外层'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol='r3633',polarity='positive')
#         else:
#             if sel_finger == "是" and add_first_plant == "no":
#                 # --手指选化,外层不套铜
#                 info['外层'] = []
#             else:
#                 out_clear = ['r4141', 'r4191', 'r4141']
#                 if put_copper_out == 'yes':
#                     info['外层'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol='r4903',polarity='positive')
#                     info['外层'].extend(self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol=out_clear,polarity='negative'))
#                 else:
#                     # --一次铜外层加s6000,在加靶标的函数中体现
#                     if add_hj_panel == "是" or add_px_panel == "是":
#                         # --化金板防止上金,喷锡板防止上锡
#                         info['外层'] = []
#                     else:
#                         info['外层'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol='s6000')
#                     info['外层'].extend(self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list,symbol=out_clear,polarity='negative'))
#                 # --靶孔r0位置套负片,这个位置有两个重复的负片,r4191,r4141是否有必要？
#                 # info['外层'].extend(self.convert_to_dict(x_list=[tag_x2], y_list=[tag_y1],symbol='r4191',polarity='negative'))
#         # --外层加r0
#         info['外层'].extend(self.convert_to_dict(x_list=[tag_x2], y_list=[tag_y1],symbol='r0',attribute='.out_flag,int=226'))
#         # --文字D+6mil套开,20210406李家兴依据story-view-2868修改
#         silk_clear = 'r3327.4'
#         info['文字'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list, symbol=silk_clear, polarity='negative')
#         # --文字加r0
#         info['文字'].extend(self.convert_to_dict(x_list=[tag_x2], y_list=[tag_y1],symbol='r0',attribute='.out_flag,int=226'))
#         return info

class tag_core_board(STATIC_SYM):
    """
    双面板靶孔
    """

    def __init__(self, frozen_json=None, priority=1.5):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        job_signal_numbers = self.parm.job_signal_numbers
        if job_signal_numbers > 2:
            return info
        profile_xmin = self.parm.profile_xmin
        profile_xmax = self.parm.profile_xmax
        profile_ymin = self.parm.profile_ymin
        profile_ymax = self.parm.profile_ymax
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        other_fd_h = self.parm.right_fd_h
        other_fd_v = self.parm.right_fd_v
        top_after_margin = self.parm.top_after_margin
        left_after_margin = self.parm.left_after_margin

        # define the coordinate. V1.10 change 2 --> 6 规范要求，详见需求3710
        inn_x1 = profile_xmin + 6
        inn_x2 = profile_xmax - 6
        inn_y1 = profile_ymin + 6
        inn_y2 = profile_ymax - 6

        inn_x_list = [inn_x1, inn_x1, inn_x2, inn_x2]
        inn_y_list = [inn_y1, inn_y2, inn_y1, inn_y2]
        inn_corner_sym = 'r2500'

        # short_margin_left = sr_xmin - profile_xmin
        tag_x1 = 0
        tag_x2 = 0
        tag_y1 = 0
        tag_y2 = 0
        if top_after_margin >= 9 or top_after_margin > left_after_margin:
            # 靶孔添加短边
            tmp = profile_xmax * 0.5 + 56 - 300
            if tmp < 66:
                tag_x1 = sr_xmin + 66 + other_fd_h
            elif tmp < 76:
                tag_x1 = sr_xmin + 76 + other_fd_h
            elif tmp < 86:
                tag_x1 = sr_xmin + 86 + other_fd_h
            elif tmp < 96:
                tag_x1 = sr_xmin + 96 + other_fd_h
            elif tmp < 106:
                tag_x1 = sr_xmin + 106 + other_fd_h

            tag_x2 = profile_xmax * 0.5
            # 加以个防呆，判断间距是否大于100.
            tag_distance = tag_x2 - tag_x1
            if tag_distance < 100:
                dif_value = 100 - tag_distance
                tag_x2 = profile_xmax * 0.5

            if top_after_margin >= 9:
                tag_y1 = profile_ymin + 3.5
                tag_y2 = profile_ymax - 3.5
            elif 7 < top_after_margin < 9:
                tag_y1 = profile_ymin + 3
                tag_y2 = profile_ymax - 3
            else:
                tag_y1 = profile_ymin + 2
                tag_y2 = profile_ymax - 2

            tag_x_list = [tag_x1, tag_x2, tag_x2]
            tag_y_list = [tag_y2, tag_y2, tag_y1]

            dbk_sym = 'r3175'
            inn_sym = 'r3100'
            sig_sym = 'r3708'
            sig_pol = 'negative'
            sm_sym = 'r3454'

        else:
            # 靶孔添加长边
            tmp = profile_ymax * 0.5 + 56 - 300;
            if tmp < 66:
                tag_y1 = sr_ymin + 66 + other_fd_v
            elif tmp < 76:
                tag_y1 = sr_ymin + 76 + other_fd_v
            elif tmp < 86:
                tag_y1 = sr_ymin + 86 + other_fd_v
            elif tmp < 96:
                tag_y1 = sr_ymin + 96 + other_fd_v
            elif tmp < 106:
                tag_y1 = sr_ymin + 106 + other_fd_v

            tag_y2 = profile_ymax * 0.5 + 120
            if left_after_margin >= 9:
                tag_x1 = profile_xmin + 3.5
                tag_x2 = profile_xmax - 3.5
            elif 7 < left_after_margin < 9:
                tag_x1 = profile_xmin + 3
                tag_x2 = profile_xmax - 3
            else:
                tag_x1 = profile_xmin + 2
                tag_x2 = profile_xmax - 2

            tag_x_list = [tag_x2, tag_x2, tag_x1]
            tag_y_list = [tag_y1, tag_y2, tag_y2]

            dbk_sym = 'r3175'
            inn_sym = 'r3100'
            sig_sym = 'r3708'
            sig_pol = 'negative'
            sm_sym = 'r3454'

        info['inn'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list, symbol=inn_sym)
        info['dbk'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list, symbol=dbk_sym)
        info['dbk'].extend(self.convert_to_dict(x_list=inn_x_list, y_list=inn_y_list, symbol=inn_corner_sym))

        info['外层'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list, symbol=sig_sym, polarity=sig_pol)
        info['防焊'] = self.convert_to_dict(x_list=tag_x_list, y_list=tag_y_list, symbol=sm_sym)

        return info


class core_core_board(STATIC_SYM):
    """
    core+core压合的打靶孔及inn层别制作
    """

    def __init__(self, frozen_json=None, priority=2.1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        profile_xmax = self.parm.profile_xmax
        profile_xmin = self.parm.profile_xmin
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        burry_list = self.parm.burry_list
        lamination = self.parm.lamination
        fill_array = self.parm.fill_array
        out_signal_array = self.parm.out_signal_array
        blind_burry_by_lamin = self.parm.blind_burry_by_lamin
        jx_drill_list = self.parm.jx_drill_list
        # === 此处套用pin的防呆数据，用于三靶数据初始化防呆
        pin_fd_h = self.parm.pin_fd_h

        if len(jx_drill_list) == 0 and len(burry_list) == 0:
            return info
        core_burry_list = list(burry_list)
        core_jx_list = list(jx_drill_list)
        yh_num = len(lamination)
        """
        "blind_burry_by_lamin": [
        {"burryLayer": "b3-8", "cur_yh_num": 1}, 
        {"blindLayer": ["s2-3", "s9-8"], "cur_yh_num": 2}, 
        {"blindLayer": ["s1-2", "s10-9"], "cur_yh_num": 3}], 
        """
        for current_lamin_hole in blind_burry_by_lamin:
            # === 定义空值，使判断以下不生效 ===
            if hasattr(current_lamin_hole, 'burryLayer'):
                # === 在埋孔列表里去除归属压合的埋孔：归属压合的埋孔在类hdi_tag_symbol中处理 ===
                core_burry_list.remove(current_lamin_hole.burryLayer)

        for current_jx in jx_drill_list:
            jx_reg = re.compile('m(\d+?)-(\d+?)')
            jx_m = jx_reg.match(current_jx)
            if jx_m:
                start_num = int(jx_m.group(1))
                end_num = int(jx_m.group(2))
                if abs(start_num - end_num) != 1:
                    core_jx_list.remove(current_jx)
        if len(core_jx_list) == 0 and len(core_burry_list) == 0:
            return info
        # define the coordinate. V1.10 change 2 --> 6 规范要求，详见需求3710
        corner_x1 = profile_xmin + 6
        corner_x2 = profile_xmax - 6
        corner_y1 = profile_ymin + 6
        corner_y2 = profile_ymax - 6

        corner_x_list = [corner_x1, corner_x1, corner_x2, corner_x2]
        corner_y_list = [corner_y1, corner_y2, corner_y1, corner_y2]
        inn_corner_sym = 'r2500'
        # hdi_tag_midx = profile_xmax * 0.5
        bar3_rect = 'rect%sx5080' % (5080)
        bar3_rect_x_r = profile_xmax * 0.5 - 2.54
        bar3_r_xmin = profile_xmax * 0.5 - 2.54
        bar3_r_xmax = profile_xmax * 0.5 + 50
        hdi_tag_hy1 = (profile_ymax - lamination[0].BAR3Y) * 0.5
        hdi_tag_hy2 = profile_ymax - hdi_tag_hy1
        bar3_x_r, hdi_tag_hy2_ls = self.optimize_static(bar3_rect, x_org=bar3_rect_x_r, y_org=hdi_tag_hy2,
                                                        area_xmin=bar3_r_xmin, area_xmax=bar3_r_xmax)
        bar3_rect_x_l = profile_xmax * 0.5 - lamination[yh_num - 1].BAR3X - 5.08 * len(
            core_burry_list + core_jx_list) - pin_fd_h
        bar3_l_xmax = bar3_rect_x_l + len(core_burry_list + core_jx_list) * 5.08 * 0.5
        bar3_l_xmin = 50

        bar3_rect_l = 'rect%sx5080' % (len(core_burry_list + core_jx_list) * 5080)
        bar3_x_l, hdi_tag_hy2_ls = self.optimize_static(bar3_rect_l, x_org=bar3_rect_x_l, y_org=hdi_tag_hy2,
                                                        area_xmin=bar3_l_xmin, area_xmax=bar3_l_xmax)
        bar3_x_l_start = bar3_x_l + 5.08 * len(core_burry_list + core_jx_list) * 0.5
        for index, layer in enumerate(core_burry_list + core_jx_list):
            cored_reg = re.compile(r'[mb](\d+?)-(\d+?)')
            dbk = 'dbk%s' % layer
            inn = '%s.inn' % layer
            if 'b' in layer:
                inn = 'inn%s' % layer.strip('b').replace('-', '')
            bar3_x_list = [bar3_x_r, bar3_x_r, bar3_x_l_start - 5.08 * index]
            bar3_y_list = [hdi_tag_hy1, hdi_tag_hy2, hdi_tag_hy2]
            cur_corner_x_list = corner_x_list + bar3_x_list
            cur_corner_y_list = corner_y_list + bar3_y_list
            inn_corner_sym = ['r2500', 'r2500', 'r2500', 'r2500', 'r3175', 'r3175', 'r3175']
            info[dbk] = self.convert_to_dict(x_list=cur_corner_x_list, y_list=cur_corner_y_list, symbol=inn_corner_sym)
            info[inn] = self.convert_to_dict(x_list=bar3_x_list, y_list=bar3_y_list, symbol='r3100')
            # === V2.00测试，周涌反馈，不要要增加标靶 ===
            # cored_m = cored_reg.match(layer)
            # layer_start = None
            # layer_end = None
            # if cored_m:
            #     layer_start = int(cored_m.group(1))
            #     layer_end = int(cored_m.group(2))
            # for fill_hash in fill_array:
            #     layer_name = fill_hash.layer_name
            #     if layer_name in out_signal_array:
            #         # --机械盲孔外层不加pad
            #         continue
            #     # --考虑辅助层
            #     des_symbol = None
            #     layer_side = fill_hash.layer_side
            #     layer_id = int (layer_name.strip ('.fz').split ('-')[0][1:])
            #     if layer_id == layer_start or layer_id == layer_end:
            #         if layer_side == "正":
            #             des_symbol = 'sh-dwtop'
            #         elif layer_side == "反":
            #             des_symbol = 'sh-dwbot'
            #         info[layer_name] = self.convert_to_dict(x_list=bar3_x_list, y_list=bar3_y_list, symbol=des_symbol,
            #                                                 polarity='negative')

        return info


class ECC_200(DYNAMIC_SYM):
    """
    层别二维码
    """
    priority = 8

    def __init__(self, frozen_json=None, avoidArea=None, priority=8):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        job_signal_numbers = self.parm.job_signal_numbers
        sh_site = self.parm.sh_site
        if job_signal_numbers < 6:
            # --四层及以下板不添加
            return info
        try:
            rj_tmp = rj_y_array[0]
        except (NameError, IndexError):
            return info
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        profile_ymax = self.parm.profile_ymax
        if rj_y_array[0] < profile_ymax * 0.5:
            # --HDI料号
            index = int(len(rj_y_array) / 2)
        else:
            # --非HDI料号
            index = 0
        # --二维码高7mm,总宽8.3125mm,静空1.5mm 10000 = (8.3125 + 1.5*2)*1000
        sym = 'rect11312.5x11312.5'
        lenth, width = self.get_sym_LIMITS(sym)
        x_L_org = sr_xmin - 2.5 - lenth / 2
        y_L_org = rj_y_array[index] + 65.0 + 65.0 / 2 - 1.5
        x_R_org = sr_xmax + 2.5 + lenth / 2
        y_R_org = rj_y_array[index] + 65.0 + 65.0 / 2 + 1.5

        # --可移动范围定义
        area_ymin = rj_y_array[index] + 65.0 + 15.5
        area_ymax = rj_y_array[index] + 65.0 * 2 - 15.5
        # --获取长边移动优化后的坐标,仅上下移动
        # x_L, y_L = self.optimize_coord(sym, x=x_L_org, y=y_L_org, area_ymin=area_ymin, area_ymax=area_ymax)
        x_R, y_R = self.optimize_coord(sym, x=x_R_org, y=y_R_org, area_ymin=area_ymin, area_ymax=area_ymax)

        # --仅在panel_map层添加sym
        # info['panel_map'] = self.convert_to_dict(x_list=[x_L,x_R], y_list=[y_L,y_R], symbol=sym, polarity='positive')
        info['panel_map'] = self.convert_to_dict(x_list=[x_R], y_list=[y_R], symbol=sym, polarity='positive')

        # self.x_L,self.y_L = x_L-3.5,y_L-3.5
        self.x_R, self.y_R = x_R - 3.5, y_R - 3.5
        return info

    def change_text(self):
        """
        每个层别的二维码都不一样，而且add_symbol方法不支持二维码，所以每个层别均需要添加二维码
        :return:
        :rtype:
        """
        job_signal_numbers = self.parm.job_signal_numbers
        hdi_contain_tag_layer = self.parm.hdi_contain_tag_layer
        if job_signal_numbers < 6:
            # --四层及以下板不添加
            return
        try:
            rj_tmp = rj_y_array[0]
        except (NameError, IndexError):
            return 
        fill_array = self.parm.fill_array
        out_signal_array = self.parm.out_signal_array
        info = {}
        for fill_hash in fill_array:
            layer_name = fill_hash.layer_name
            # 修改为动态字体 ynh-20230824
            upper_text = '$$job $$layer'
            # upper_text = '%s %s' % (self.JOB, layer_name)
            # upper_text = upper_text.upper()
            layer_side = fill_hash.layer_side
            if layer_name not in out_signal_array:
                if layer_name in hdi_contain_tag_layer:
                    # if layer_side == "反":
                    #     # --生成字典信息,键是层别类型,值是字典
                    #     info[layer_name] = self.convert_to_dict (x_list=[self.x_R + 3.5, self.x_L + 3.5],
                    #                                              y_list=[self.y_R + 3.5, self.y_L + 3.5],
                    #                                              symbol='rect11312.5x11312.5',
                    #                                              polarity='negative')
                    #     info[layer_name].extend (
                    #         self.convert_to_dict (x_list=[self.x_L + 7], y_list=[self.y_L], text=upper_text,
                    #         angle=0, mirror='yes',type='barcode',bar_type='ECC-200',matrix='Minimal',bar_add_string='no',
                    #         bar_height = 7))
                    # elif layer_side == "正":
                    #     info[layer_name] = self.convert_to_dict (x_list=[self.x_R + 3.5,self.x_L + 3.5],
                    #                                              y_list=[self.y_R + 3.5, self.y_L + 3.5],
                    #                                              symbol='rect11312.5x11312.5',
                    #                                              polarity='negative')
                    if layer_side == "反":
                        # --生成字典信息,键是层别类型,值是字典
                        info[layer_name] = self.convert_to_dict(x_list=[self.x_R + 3.5],
                                                                y_list=[self.y_R + 3.5],
                                                                symbol='rect11312.5x11312.5',
                                                                polarity='negative')
                    elif layer_side == "正":
                        info[layer_name] = self.convert_to_dict(x_list=[self.x_R + 3.5],
                                                                y_list=[self.y_R + 3.5],
                                                                symbol='rect11312.5x11312.5',
                                                                polarity='negative')
                        info[layer_name].extend(
                            self.convert_to_dict(x_list=[self.x_R], y_list=[self.y_R], text=upper_text,
                                                 angle=0, mirror='no', type='barcode', bar_type='ECC-200',
                                                 matrix='Minimal', bar_add_string='no',
                                                 bar_height=7))

        self.add_symbol(info)


class hdi_tag_symbol(STATIC_SYM):
    """
    HDI靶孔,与服务器模块优先及一样,HDI料号不加服务器模块,故可以共存
    """
    priority = 2

    def __init__(self, frozen_json=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        # === HDI板考虑多层板以及HDI使用同一套标靶添加方式
        hdi_num = self.parm.hdi_num
        # if hdi_num < 1:
        #     # --多层板不加HDI靶
        #     return info
        job_signal_numbers = self.parm.job_signal_numbers
        if job_signal_numbers <= 2:
            return info
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        profile_xmin = self.parm.profile_xmin
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        lam_rout = self.parm.lam_rout
        lamination = self.parm.lamination
        fill_array = self.parm.fill_array
        assist_layer = self.parm.assist_layer
        assist_ref = self.parm.assist_ref
        assist_side = self.parm.assist_side
        out_signal_array = self.parm.out_signal_array
        sub_outer = self.parm.sub_outer
        hdi_contain_tag_layer = self.parm.hdi_contain_tag_layer
        put_copper_md = self.parm.put_copper_md
        left_after_margin = self.parm.left_after_margin
        # put_copper_md = 'no'
        add_first_plant = self.parm.add_first_plant
        L_margin = self.parm.L_margin
        R_margin = self.parm.R_margin
        pin_fd_h = self.parm.pin_fd_h
        burry_list = self.parm.burry_list
        # add_first_plant = 'no'
        flow_content = self.parm.flow_content
        blind_burry_by_lamin = self.parm.blind_burry_by_lamin
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        job_split = self.parm.job_split
        yh_num = len(lamination)
        rout_after_marginy_tmp = sr_ymin - (profile_ymax - rout_y) * 0.5
        rout_after_marginx_tmp = (profile_xmax - rout_x) * 0.5
        hdi_margin_min = "no"
        # === 暂时取消此提醒，似乎没有实际用处 ===
        # if rout_after_marginy_tmp < 17:
        #     hdi_margin_min = "yes"
        #     msg_dict = {'type'       : 'critical',
        #                 'windowTitle': '警告',
        #                 'content'    : 'Hdi锣边后的板边小于17mm, 靶标特殊加法，跑完之后请检查是否有跟靶标重叠的symbol！'}
        #     self.msg_array.append(msg_dict)
        # === 默认三靶数据存在 在前面增加判断，判断三靶数据及四靶数据 ===
        # === if lamination[0]['BAR3X']: ===
        # === 取一压数据和最后一次压合数据，定义矩形大小 ===
        lenth = 5.08 * len(lam_rout)
        hdi_tag_sy1 = (profile_ymax - lamination[0].BAR4Y1) * 0.5
        hdi_tag_sy4 = profile_ymax - hdi_tag_sy1
        hdi_tag_sy1fd = hdi_tag_sy4 - lamination[0].BAR4Y2
        hdi_tag_sx2 = profile_xmax * 0.5 - lamination[0].BAR4X1 * 0.5
        hdi_tag_sx3 = hdi_tag_sx2 + lamination[0].BAR4X1
        hdi_tag_sx2fd = hdi_tag_sx3 - lamination[0].BAR4X2
        hdi_tag_midx = profile_xmax * 0.5
        if lamination[0].BAR3X:
            if lamination[0].BAR4X1 * 0.5 - lamination[0].BAR3X < 70:
                hdi_tag_midx = profile_xmax * 0.5 + 71 + lamination[0].BAR3X - lamination[0].BAR4X1 * 0.5
        # === 当有铆钉存在时，三靶避让铆钉 ===
        # if len (hdi_contain_tag_layer) > 0:
        #     hdi_tag_midx = hdi_tag_midx + 1.499997 * 25.4 + 9

        hdi_tag_hy1 = (profile_ymax - lamination[0].BAR3Y) * 0.5
        hdi_tag_hy2 = profile_ymax - hdi_tag_hy1

        # === 箭靶三靶添加位置检测，有溶胶区时大概率碰到PE光点。
        bar3_rect = 'rect%sx5080' % (lenth * 1000)
        bar3_rect_x = profile_xmax * 0.5 + len(lam_rout) * 5.08 * 0.5 - 2.54
        bar3_area_xmin = profile_xmax * 0.5 - 2.54
        bar3_area_xmax = hdi_tag_midx + 1.5 * 25.4 + 30 + len(lam_rout) * 5.08
        bar3_rect_x, hdi_tag_hy2_ls = self.optimize_static(bar3_rect, x_org=bar3_rect_x, y_org=hdi_tag_hy2,
                                                           area_xmin=bar3_area_xmin, area_xmax=bar3_area_xmax)
        hdi_tag_midx = bar3_rect_x - len(lam_rout) * 5.08 * 0.5 + 2.54
        hdi_tag_shx2 = hdi_tag_midx
        hdi_tag_shx1 = hdi_tag_shx2 - lamination[0].BAR3X

        # ==左下角四靶坐标 === rect_sym 后续用于类似CCD 标靶的6.5mm的避让，注意更改此尺寸需要变更DYNAMIC_SYM中的方法
        rect_sym = 'rect%sx5080' % (lenth * 1000 + 80)
        rect_ang = '0'
        sr_lenth = self.parm.sr_lenth
        rect_x_ll, rect_y_ll = hdi_tag_sx2fd - lenth / 2 + 2.54, hdi_tag_sy1fd
        # ==左上角四靶坐标
        rect_x_ul, rect_y_ul = hdi_tag_sx2 - lenth / 2 + 2.54, hdi_tag_sy4
        # ==右下角四靶坐标
        rect_x_lr, rect_y_lr = hdi_tag_sx3 + lenth / 2 - 2.54, hdi_tag_sy1
        # --右上角四靶坐标
        rect_x_ur, rect_y_ur = hdi_tag_sx3 + lenth / 2 - 2.54, hdi_tag_sy4
        # === 三靶左侧标靶矩形中心
        rect_hx1, rect_hy1 = hdi_tag_shx1 - lenth / 2 + 2.54, hdi_tag_hy2
        # rect_hx2, rect_hy1 = hdi_tag_shx2 - lenth/2 + 2.54, hdi_tag_hy2
        rect_hx2, rect_hy2 = hdi_tag_shx2 + lenth / 2 - 2.54, hdi_tag_hy1
        # 蚀刻引线层别的对位标靶，使用T靶对位 == =
        etch_dw_symbol = []
        etch_dw_x = []
        etch_dw_y = []

        # === 蚀刻引线层别的标靶，如果外层有对位pad，在蚀刻引线层加r0对位点 ===
        etch_lyr_symbol = None
        etch_lyr_x = []
        etch_lyr_y = []
        # === 选化层标靶位置化金，套开处理 ===
        sgt_lyr_symbol = None
        sgt_lyr_x = []
        sgt_lyr_y = []
        # === 压合超过一次时需要判断添加在长边还是短边 ===
        # if len (lam_rout) > 1:
        # === 以下为长边，X相同
        by_ll_starty = None
        by_lr_starty = None
        by_rect_x_ll = None
        # if lamination[0].BAR3Y != lamination[0].BAR4Y1:
        if lamination[0].TARGET_DESIGNREGION == "长边":
            # === 正式靶在长边 ===
            rect_ang = '90'
            # ==左下角四靶坐标
            rect_x_ll, rect_y_ll = hdi_tag_sx2fd, hdi_tag_sy1fd - lenth / 2 + 2.54
            # ==左上角四靶坐标
            rect_x_ul, rect_y_ul = hdi_tag_sx2, hdi_tag_sy4 + lenth / 2 - 2.54
            # ==右下角四靶坐标
            rect_x_lr, rect_y_lr = hdi_tag_sx3, hdi_tag_sy1 - lenth / 2 + 2.54
            # --右上角四靶坐标
            rect_x_ur, rect_y_ur = hdi_tag_sx3, hdi_tag_sy4 + lenth / 2 - 2.54
        # === V1.10 以下独立于类 hdi_by_bar
        # else:
        #     # === 备用长边标靶的坐标 ===
        #     by_lenth =  5.08 * len (lam_rout) + 3
        #     # === Symbol 可以挨着添加，不用加大0.5 不变更方法，此处rect改小 ===
        #     by_rect_sym = 'rect4580x%s' % (by_lenth*1000)
        #     # === 考虑此值是否根据留边增加加大 ===
        #     if left_after_margin > 15:
        #         by_rect_x_ll = sr_xmin - 7.8
        #     else:
        #         by_rect_x_ll = sr_xmin - 5
        #     by_rect_y_ll = sr_ymin + by_lenth / 2
        #     # print by_rect_x_ll,by_rect_y_ll
        #     by_area_ymin = sr_ymin
        #     by_area_ymax = profile_ymax * 0.33
        #     by_rect_x_ll, by_rect_y_ll = self.optimize_static (by_rect_sym, x_org=by_rect_x_ll, y_org=by_rect_y_ll,
        #                                                          area_ymin=by_area_ymin, area_ymax=by_area_ymax,
        #                                                        mirror_y_area = 'yes')
        #     # print by_rect_x_ll,by_rect_y_ll
        #     by_ll_starty = by_rect_y_ll + by_lenth * 0.5 - 2.54 - 3
        #     by_lr_starty = by_rect_y_ll + by_lenth * 0.5 - 2.54
        # self.GEN.PAUSE('xxxxxxxxxxxxxxxxxxxxx')
        rect_x_list = [rect_x_ll, rect_x_ul, rect_x_lr, rect_x_ur, rect_hx1, rect_hx2, rect_hx2]
        rect_y_list = [rect_y_ll, rect_y_ul, rect_y_lr, rect_y_ur, rect_hy1, rect_hy1, rect_hy2]
        rect_ang_list = [rect_ang, rect_ang, rect_ang, rect_ang, 0, 0, 0]
        info['panel_map'] = self.convert_to_dict(x_list=rect_x_list, y_list=rect_y_list, symbol=rect_sym,
                                                 angle=rect_ang_list)
        tag_step = 5.08
        for index, cur_lamin in enumerate(lamination, 1):
            (lam_des, from_lyr, to_lyr) = (
                int(cur_lamin.PROCESS_NUM) - 1, str(cur_lamin.FROMLAY).lower(), str(cur_lamin.TOLAY).lower())
            from_id = int(from_lyr[1:])
            from_next = from_id + 1
            to_id = int(to_lyr[1:])
            to_pre = to_id - 1
            # --pnl_rout4->pnl_rout3->pnl_rout2->pnl_rout1
            pnl_rout = 'pnl_rout' + str(index)

            hdi_tag_sy1 = (profile_ymax - cur_lamin.BAR4Y1) * 0.5
            hdi_tag_sy4 = profile_ymax - hdi_tag_sy1
            # === 四靶加在短边上 2021.01.13 Only Note by Song ===
            hdi_tag_hy1 = (profile_ymax - cur_lamin.BAR3Y) * 0.5
            hdi_tag_hy2 = profile_ymax - hdi_tag_hy1
            hdi_tag_sy1fd = hdi_tag_sy4 - cur_lamin.BAR4Y2
            hdi_tag_sx2 = profile_xmax * 0.5 - cur_lamin.BAR4X1 * 0.5
            hdi_tag_sx3 = hdi_tag_sx2 + cur_lamin.BAR4X1
            hdi_tag_sx2fd = hdi_tag_sx3 - cur_lamin.BAR4X2
            hdi_tag_shx2 = hdi_tag_midx + (index - 1) * tag_step
            hdi_tag_shx1 = hdi_tag_shx2 - cur_lamin.BAR3X
            hdi_tag_siy1 = 0
            hdi_tag_siy4 = 0
            hdi_tag_siy1fd = 0
            cur_fg_sig = 'no'
            hdi_tag_six1 = None
            hdi_tag_six2 = None
            # === 添加线路靶 ===
            if cur_lamin.SIG4Y1 != 0:
                hdi_tag_six1 = hdi_tag_sx2
                hdi_tag_six2 = hdi_tag_sx3

                hdi_tag_siy1 = (profile_ymax - cur_lamin.SIG4Y1) * 0.5
                hdi_tag_siy4 = profile_ymax - hdi_tag_siy1
                hdi_tag_siy1fd = hdi_tag_siy4 - cur_lamin.SIG4Y2
                if cur_lamin.SIG4X1 != 0:
                    hdi_tag_six1 = profile_xmax * 0.5 - cur_lamin.SIG4X1 * 0.5
                    hdi_tag_six2 = hdi_tag_six1 + cur_lamin.SIG4X2
                    cur_fg_sig = 'yes'
                    if job_split == '无需分割' or job_split == 'Unknown':
                        cur_fg_sig = 'no'

            # === V1.10 以下独立于类 hdi_by_bar
            # === 备用标靶坐标 ===
            # hdi_tag_by1 = sr_ymin + (index + 1) * tag_step
            # hdi_tag_by2 = sr_ymax - (index + 1) * tag_step
            # hdi_tag_by1fd = hdi_tag_by1 - 3
            # hdi_tag_bx1 = sr_xmin - 5
            # hdi_tag_bx2 = sr_xmax + 5
            # if by_ll_starty:
            #     hdi_tag_by1 = by_lr_starty - (index - 1) * tag_step
            #     hdi_tag_by1fd = hdi_tag_by1 - 3
            #     hdi_tag_by2 = profile_ymax - hdi_tag_by1
            #     hdi_tag_bx1 = by_rect_x_ll
            #     hdi_tag_bx2 = profile_xmax - hdi_tag_bx1
            # if cur_lamin.BAR3Y and cur_lamin.BAR3Y != cur_lamin.BAR4Y1:
            #     hdi_tag_by1 = (profile_ymax - cur_lamin.BAR3Y) * 0.5
            #     hdi_tag_by2 = hdi_tag_by1 + cur_lamin.BAR3Y
            #     hdi_tag_by1fd = hdi_tag_by1 - 1
            #     hdi_tag_bx1 = sr_xmin + (yh_num - index + 1) * tag_step
            #     hdi_tag_bx2 = sr_xmax - (yh_num - index + 1) * tag_step
            #     # === 长边加备用靶，避开板角四孔
            #     if L_margin > 20 and R_margin > 20 and add_first_plant == 'no':
            #         # pass
            #         pin_x_min = profile_xmin + (profile_xmax - rout_x) * 0.5 + 5.5 + len(burry_list) * 5.5
            #         if abs(hdi_tag_bx1 - pin_x_min) < 6.5:
            #             hdi_tag_bx1 = pin_x_min + 6.5
            #             hdi_tag_bx2 = profile_xmax - hdi_tag_bx1
            #     else:
            #         hdi_tag_bx1 = sr_xmin + (yh_num - index + 1) * tag_step + 7.323 + pin_fd_h + 5.5
            #         hdi_tag_bx2 = sr_xmax - (yh_num - index + 1) * tag_step - 7.323 - pin_fd_h - 5.5
            #         hdi_tag_by1fd = hdi_tag_by1 - 3

            for fill_hash in fill_array:
                sym1 = None
                sym2 = None
                sym3 = None
                bs1 = None
                bsj = None
                letter_1 = None
                letter_2 = None
                info_list = []
                layer_name = str(fill_hash.layer_name)
                layer_id = int(layer_name.strip('-fz').split('-')[0][1:])
                if re.search('fz',layer_name):
                    continue                

                if from_id <= layer_id <= to_id:
                    if layer_name == from_lyr:
                        sym1 = "sh-dwtop"
                        sym2 = "sh-dwtop"
                        sym3 = 'r0'
                        bs1 = "sh-dwtop"
                        bsj = "sh-dwtop"

                        # by1 = 'sh-dwtop'
                        # byj = 'sh-dwtop'
                        if flow_content == '一次铜' or index != len(lamination):
                            tag_polarity = "negative"
                        else:
                            tag_polarity = "positive"
                        if index == len(lamination):
                            sym1 = "hdi-dwtop-t"
                            sym2 = "hdi-dwtop-t"
                            bs1 = "hdi-dwtop-tt"
                            bsj = "hdi-dwtop-tt"
                            tag_polarity = "positive"
                            if flow_content == '二次铜':
                                tag_polarity = "negative"
                                
                        if cur_fg_sig == 'yes':
                            bs1 = 's5082'
                            bsj = 's5082'
                            # tag_polarity = "negative"
                            sym3 = None
                    elif layer_name == to_lyr:
                        sym1 = "sh-dwbot"
                        sym2 = "sh-dwbot"
                        sym3 = 'r0'
                        bs1 = "sh-dwbot"
                        bsj = "sh-dwbot"
                        # by1 = 'sh-dwbot'
                        # byj = 'sh-dwbot'
                        if flow_content == '一次铜' or index != len(lamination):
                            tag_polarity = "negative"
                        else:
                            tag_polarity = "positive"

                        if index == len(lamination):
                            sym1 = "hdi-dwbot-t"
                            sym2 = "hdi-dwbot-t"
                            bs1 = "hdi-dwbot-tt"
                            bsj = "hdi-dwbot-tt"
                            tag_polarity = "positive"
                            if flow_content == '二次铜':
                                tag_polarity = "negative"
                        if cur_fg_sig == 'yes':
                            bs1 = 's5082'
                            bsj = 's5082'
                            # tag_polarity = "negative"
                            sym3 = None
                            
                    elif layer_id == from_next or layer_id == to_pre or index == 1:
                        # --当前压合前一层,l2->l3,l9->l8
                        tail_num = index
                        if tail_num == len(lamination):
                            tail_num = 't'
                        sym1 = "hdi1-ba%s" % tail_num
                        sym2 = "hdi1-baj%s" % tail_num
                        sym3 = None
                        if cur_fg_sig == 'yes':
                            # === 当为特殊类型八靶时，数字follow压合
                            if index != 1:
                                tail_num2 = 2
                            else:
                                tail_num2 = 1
                            bs1 = "hdi1-bs%s" % tail_num2
                            bsj = "hdi1-bs%s" % tail_num2
                        else:
                            bs1 = "hdi1-bs%s" % tail_num
                            bsj = "hdi1-bs%s" % tail_num
                        # by1 = 'hdi1-by%s' % tail_num
                        # byj = 'hdi1-byj%s' % tail_num
                        tag_polarity = "positive"
                    else:
                        # --内一其它层别用s7000掏空,多次压合时,第一次压合不掏空并添加hdi-ba1
                        sym1 = 's5080'
                        sym2 = 's5080'
                        sym3 = None
                        bs1 = "s5080"
                        bsj = "s5080"
                        # by1 = "s5080"
                        # byj = "s5080"
                        tag_polarity = "negative"
                        # if index == len(lamination):
                        #     sym = 'hdi1-ba1'
                        #     tag_polarity = "positive"
                        if len(lamination) == 1:
                            sym1 = "hdi1-bat"
                            sym2 = "hdi1-bajt"
                            tag_polarity = "positive"
                else:
                    # --超出本次压合范围的层别不加任何symbol,比如二压为b38,则l1,l2,l9,l10不加symbol
                    sym1 = None
                    sym2 = None
                    sym3 = None
                    bs1 = None
                    bsj = None
                    tag_polarity = "positive"
                    # === V2.01 如果是加特殊线路分割八靶类型，需要添加标靶 ===
                    if cur_fg_sig == 'yes':
                        bs1 = 's5082'
                        bsj = 's5082'
                        # tag_polarity = "negative"

                    # by1 = None
                    # byj = None
                tag4_x_list = [hdi_tag_sx2fd, hdi_tag_sx2, hdi_tag_sx3, hdi_tag_sx3]
                tag4_y_list = [hdi_tag_sy1fd, hdi_tag_sy4, hdi_tag_sy1, hdi_tag_sy4]
                tag4_sym_list = [sym1, sym1, sym1, sym2]

                # http://192.168.2.120:82/zentao/story-view-6102.html
                # 按此需求更改此symbol 全部掏开
                if sym1 == "sh-dwtop" or  sym1 == "sh-dwbot" :
                    tag4_sym_list = [sym1 + "2023", sym1 + "2023", sym1 + "2023", sym2 + "2023"]
                # dw_x_list = [hdi_tag_x1, hdi_tag_x1]
                # dw_y_list = [hdi_tag_y3, hdi_tag_y2]
                tag3_x_list = [hdi_tag_shx1, hdi_tag_shx2, hdi_tag_shx2]
                tag3_y_list = [hdi_tag_hy2, hdi_tag_hy2, hdi_tag_hy1]
                tag3_sym_list = [sym1, sym2, sym1]
                
                # http://192.168.2.120:82/zentao/story-view-7142.html 工艺要求档住此靶 20240724 by lyh
                if sym2 == "sh-dwtop" or  sym2 == "sh-dwbot" :
                    tag3_sym_list = [sym1, sym2 + "2024", sym1 + "2024"]

                # sig4_x_list = [hdi_tag_sx2, hdi_tag_sx2, hdi_tag_sx3, hdi_tag_sx3]
                sig4_x_list = [hdi_tag_six1, hdi_tag_six1, hdi_tag_six2, hdi_tag_six2]
                sig4_y_list = [hdi_tag_siy1fd, hdi_tag_siy4, hdi_tag_siy1, hdi_tag_siy4]
                sig4_sym_list = [bs1, bs1, bs1, bsj]
                # http://192.168.2.120:82/zentao/story-view-6102.html
                # 按此需求更改此symbol 全部掏开                
                if bs1 == "sh-dwtop" or  bs1 == "sh-dwbot" :
                    sig4_sym_list = [bs1 + "2023", bs1 + "2023", bs1 + "2023", bsj + "2023"]            
                

                # by4_x_list = [hdi_tag_bx2, hdi_tag_bx2, hdi_tag_bx1, hdi_tag_bx1]
                # by4_y_list = [hdi_tag_by1, hdi_tag_by2, hdi_tag_by2, hdi_tag_by1fd]
                # by4_sym_list = [by1, byj, by1, by1]
                # # --依据story-view-973修改for特殊叠构，料号s543/238a1,除外层，一次压合之后的所有层别都加上靶距
                # if from_next <= layer_id <= to_pre:
                #     # --写入字典
                #     hdi_tag_distance_x_dict[layer_name] = hdi_tag_distance_x
                #     hdi_tag_distance_y_dict[layer_name] = hdi_tag_distance_y
                # --范围内的层别才添加symbol
                # if from_id <= layer_id <= to_id:
                
                #http://192.168.2.120:82/zentao/story-view-6102.html 
                # 等于是在设计靶标的后面哪些层都掏开。开料钻的靶孔也是这样，
                # 从内层到后面都掏开。外层不用管，外层干膜有封孔能力
                info_list.extend(
                    self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol=["s5082", "s5082", "s5082", "s5082"],
                                         polarity="negative"))                 
                
                # http://192.168.2.120:82/zentao/story-view-5815.html
                # 为省金，外层的靶标都取消添加20230724 但是r0点保留 by lyh
                # 有辅助层存在，层数会不匹配，改为直接数字匹配
                if layer_name not in ('l1', 'l' + str(int(self.JOB[4:6]))):
                    info_list.extend(
                        self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol=tag4_sym_list,
                                             polarity=tag_polarity))
                else:
                    # T靶和TT靶外层正片且蚀刻引线为碱性蚀刻的条件下top面加sh-dwtop2013,S面加sh-dwbot2013
                    # http://192.168.2.120:82/zentao/story-view-6783.html
                    figer_dp_positive = self.parm.figer_dp_positive
                    if figer_dp_positive == 'yes' and flow_content == '二次铜':
                        if layer_name == 'l1':
                            info_list.extend(
                                self.convert_to_dict(x_list=tag4_x_list + sig4_x_list, y_list=tag4_y_list + sig4_y_list, symbol='sh-dwtop2013'))

                        elif layer_name == 'l' + str(int(self.JOB[4:6])):
                            info_list.extend(
                                self.convert_to_dict(x_list=tag4_x_list + sig4_x_list, y_list=tag4_y_list + sig4_y_list, symbol='sh-dwbot2013'))
                #http://192.168.2.120:82/zentao/story-view-6102.html 
                # 等于是在设计靶标的后面哪些层都掏开。开料钻的靶孔也是这样，
                # 从内层到后面都掏开。外层不用管，外层干膜有封孔能力
                info_list.extend(
                    self.convert_to_dict(x_list=tag3_x_list, y_list=tag3_y_list, symbol=["s5082", "s5082", "s5082"],
                                         polarity="negative"))
                
                # TODO if cur_lamin.V5LASER == 1
                # --HDI与多层共用dw-pad,因此不用添加
                # info_list.extend(self.convert_to_dict(x_list=dw_x_list, y_list=dw_y_list, symbol='sh-dwpad'))
                # http://192.168.2.120:82/zentao/story-view-5815.html
                # 为省金，外层的靶标都取消添加20230724 但是r0点保留 by lyh               
                if layer_name not in ('l1', 'l'+ str(int(self.JOB[4:6]))):
                    info_list.extend(
                        self.convert_to_dict(x_list=tag3_x_list, y_list=tag3_y_list, symbol=tag3_sym_list,
                                             polarity=tag_polarity))

                # info_list.extend (self.convert_to_dict (x_list=by4_x_list, y_list=by4_y_list, symbol=by4_sym_list,
                #                                         polarity=tag_polarity))
                if cur_lamin.SIG4Y1 != 0:
                    # 修改分割条件下 极性判断改到此处 存在s5082即为负 其他情况按之前的判断 20230417 by lyh
                    # http://192.168.2.120:82/zentao/story-view-5815.html
                    # 为省金，外层的靶标都取消添加20230724 但是r0点保留 by lyh                    
                    if layer_name not in ('l1', 'l' + str(int(self.JOB[4:6]))):
                        info_list.extend(
                            self.convert_to_dict(x_list=sig4_x_list, y_list=sig4_y_list, symbol=sig4_sym_list,
                                                 polarity="negative" if "s5082" in sig4_sym_list else tag_polarity))
                        
                    info_list.extend(
                        self.convert_to_dict(x_list=sig4_x_list, y_list=sig4_y_list, symbol=sym3,
                                             polarity=tag_polarity, attribute='.fiducial_name,text=317.reg'))
                    if index == len(lamination):
                        etch_lyr_x = sig4_x_list
                        etch_lyr_y = sig4_y_list
                        etch_lyr_symbol = sym3
                        # if cur_fg_sig == 'yes':
                        #     etch_lyr_x = tag4_x_list
                        #     etch_lyr_y = tag4_y_list
                elif cur_lamin.V5LASER == 0:
                    if index == len(lamination):
                        if hdi_num < 1:
                            # === 通孔板使用钻出四孔做线路对位 ===
                            etch_lyr_x = [None, None, None, None]
                            etch_lyr_y = [None, None, None, None]
                            etch_lyr_symbol = None
                        elif not [i for i in blind_burry_by_lamin if
                                  int(i.cur_yh_num) == index and hasattr(i, 'blindLayer')]:
                            # === 最外层没有盲埋孔存在时也使用ccd对位，适用于core+core+core压合 料号：515-070aa 用类out_ccd添加
                            etch_lyr_x = [None, None, None, None]
                            etch_lyr_y = [None, None, None, None]
                            etch_lyr_symbol = None
                        else:
                            info_list.extend(
                                self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol=sym3,
                                                     polarity=tag_polarity, attribute='.fiducial_name,text=317.reg'))
                            etch_lyr_x = tag4_x_list
                            etch_lyr_y = tag4_y_list
                            etch_lyr_symbol = 'r0'
                    else:
                        get_cur_info = [i for i in blind_burry_by_lamin if int(i.cur_yh_num) == index]
                        if len(get_cur_info) > 0:
                            current_lamin_hole = get_cur_info[0]
                        else:
                            # === 定义空值，使判断以下不生效 ===
                            current_lamin_hole = []
                        if hasattr(current_lamin_hole, 'burryLayer') and not hasattr(current_lamin_hole, 'blindLayer'):
                            # === 仅有埋孔的压合，使用板角位置孔做线路对位 见类pin_donut
                            pass
                        else:
                            info_list.extend(
                                self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol=sym3,
                                                     polarity=tag_polarity, attribute='.fiducial_name,text=317.reg'))

                if index == len(lamination):
                    

                    etch_dw_x = tag4_x_list

                    etch_dw_y = tag4_y_list
                    # etch_dw_symbol = 'sh-dwtop'

                    if cur_lamin.SIG4Y1 != 0:
                        # sgt_lyr_x = tag4_x_list + sig4_x_list + tag3_x_list + by4_x_list
                        sgt_lyr_x = tag4_x_list + sig4_x_list + tag3_x_list
                        # sgt_lyr_y = tag4_y_list + sig4_y_list + tag3_y_list + by4_y_list
                        sgt_lyr_y = tag4_y_list + sig4_y_list + tag3_y_list
                    else:
                        # sgt_lyr_x = tag4_x_list + tag3_x_list + by4_x_list
                        sgt_lyr_x = tag4_x_list + tag3_x_list
                        # sgt_lyr_y = tag4_y_list + tag3_y_list + by4_y_list
                        sgt_lyr_y = tag4_y_list + tag3_y_list
                    sgt_lyr_symbol = 's4736'
                # print json.dumps(info,indent=2)
                if fill_hash.layer_mode == "inn" or layer_name in ["l{0}".format(job_signal_numbers/2), "l{0}".format(job_signal_numbers/2+1)]:
                    # 翟鸣通知 一压靶标位置都要加框线 http://192.168.2.120:82/zentao/story-view-6885.html 20240520 by lyh
                    info_list.extend(
                        self.convert_to_dict(x_list=tag3_x_list, y_list=tag3_y_list, symbol=["donut_s5100x4650",
                                                                                             "donut_s5100x4650",
                                                                                             "donut_s5100x4650",],
                                             polarity="positive"))
                    info_list.extend(
                        self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol=["donut_s5100x4650",
                                                                                             "donut_s5100x4650",
                                                                                             "donut_s5100x4650",
                                                                                             "donut_s5100x4650",],
                                             polarity="positive"))
                    
                    if cur_lamin.SIG4Y1 != 0:
                        info_list.extend(
                            self.convert_to_dict(x_list=sig4_x_list, y_list=sig4_y_list, symbol=["donut_s5100x4650",
                                                                                                 "donut_s5100x4650",
                                                                                                 "donut_s5100x4650",
                                                                                                 "donut_s5100x4650",],
                                                 polarity="positive"))                      
                if index == 1:                  
                    info[layer_name] = info_list                 
                else:
                    info[layer_name].extend(info_list)                                         
                                             

            # --考虑辅助层,参考999/072a1
            # ===  V2.09 辅助层不跑出靶孔

            # for layer_fz, layer_ref in zip(assist_layer, assist_ref):
            #     info[layer_fz] = info[layer_ref]

            # --最后一次压合
            if index == len(lamination):
                inn_layer = 'inn'
            else:
                inn_layer = 'inn%s%s' % (from_id, to_id)

            # --相应的镭射层加r3175pad
            # === 2022.07.26 Song 分割料号，不添加镭射对位孔在外八靶位置 BUg料号：190-173A1 ===
            if cur_lamin.SIG4Y1 != 0 and index == len(lamination) and cur_fg_sig == 'no':
                # if cur_lamin.X1 == 0:
                laser_inn_x_list = sig4_x_list
                laser_inn_y_list = sig4_y_list
            else:
                laser_inn_x_list = tag4_x_list
                laser_inn_y_list = tag4_y_list
            info[inn_layer] = self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol='r3100')
            tmp_check = [i for i in blind_burry_by_lamin if int(i.cur_yh_num) == index]
            if len(tmp_check) > 0:
                if hasattr(tmp_check[0], 'blindLayer'):
                    cur_blind_list = tmp_check[0].blindLayer
                    for cur_laser in cur_blind_list:
                        info[cur_laser] = self.convert_to_dict(x_list=laser_inn_x_list, y_list=laser_inn_y_list,
                                                               symbol='r3175')

            info[pnl_rout] = self.convert_to_dict(x_list=tag3_x_list, y_list=tag3_y_list, symbol='r3125')
        # === 0压有钻带存在的情形 === 开料埋孔，开料盲孔 使用打靶孔内移一靶位钻孔，用于线路对位 ===
        tmp_check = [i for i in blind_burry_by_lamin if int(i.cur_yh_num) == 0]
        zero_lamin_yn = 'no'
        zero_burry_yn = 'no'
        zero_blind_yn = 'no'

        zero_burry = ''
        zero_blind = []
        if len(tmp_check) > 0:
            zero_lamin_yn = 'yes'
            if hasattr(tmp_check[0], 'burryLayer'):
                zero_burry = tmp_check[0].burryLayer
                zero_burry_yn = 'yes'

            if hasattr(tmp_check[0], 'blindLayer'):
                zero_blind = tmp_check[0].blindLayer
                zero_blind_yn = 'yes'

        # print 'zero_lamin_yn:%s' % zero_lamin_yn
        if zero_lamin_yn == 'yes':
            zero_lamin_dict = tmp_check[0]
            from_id = zero_lamin_dict.start_num
            to_id = zero_lamin_dict.end_num
            
            if lamination[0].BAR4X1 < lamination[-1].BAR4X1:
                # 四靶计算由内而外
                hdi_tag_sy1 = (panel_y - lamination[0].BAR4Y1) * 0.5
                hdi_tag_sy4 = panel_y - hdi_tag_sy1
                # === 四靶加在短边上 2021.01.13 Only Note by Song ===
                hdi_tag_hy1 = (panel_y - lamination[0].BAR3Y) * 0.5
                hdi_tag_hy2 = panel_y - hdi_tag_hy1
                hdi_tag_sy1fd = hdi_tag_sy4 - lamination[0].BAR4Y2
                hdi_tag_sx2 = panel_x * 0.5 - lamination[0].BAR4X1 * 0.5 + tag_step
                hdi_tag_sx3 = hdi_tag_sx2 + lamination[0].BAR4X1 - tag_step * 2
                hdi_tag_sx2fd = hdi_tag_sx3 - lamination[0].BAR4X2 + tag_step * 2
            else:
                hdi_tag_sy1 = (panel_y - lamination[-1].BAR4Y1) * 0.5
                hdi_tag_sy4 = panel_y - hdi_tag_sy1
                # === 四靶加在短边上 2021.01.13 Only Note by Song ===
                hdi_tag_hy1 = (panel_y - lamination[-1].BAR3Y) * 0.5
                hdi_tag_hy2 = panel_y - hdi_tag_hy1
                hdi_tag_sy1fd = hdi_tag_sy4 - lamination[-1].BAR4Y2
                hdi_tag_sx2 = panel_x * 0.5 - lamination[-1].BAR4X1 * 0.5 + tag_step
                hdi_tag_sx3 = hdi_tag_sx2 + lamination[-1].BAR4X1 - tag_step * 2
                hdi_tag_sx2fd = hdi_tag_sx3 - lamination[-1].BAR4X2 + tag_step * 2
                
            if lamination[0].BAR3X < lamination[-1].BAR3X:
                hdi_tag_shx2 = hdi_tag_midx - tag_step
                hdi_tag_shx1 = hdi_tag_shx2 - lamination[0].BAR3X + tag_step * 2
            else:
                hdi_tag_shx2 = hdi_tag_midx - tag_step
                hdi_tag_shx1 = hdi_tag_shx2 - lamination[-1].BAR3X + tag_step * 2                

            # === 支持靶加在长边的情况 === Song 2021.02.23
            if rect_ang == '90':
                if lamination[0].BAR4Y1 < lamination[-1].BAR4Y1:
                    hdi_tag_sy1 = panel_y * 0.5 - lamination[0].BAR4Y1 * 0.5 + tag_step
                    hdi_tag_sy4 = hdi_tag_sy1 + lamination[0].BAR4Y1 - tag_step * 2
                    hdi_tag_sy1fd = hdi_tag_sy4 - lamination[0].BAR4Y2 + tag_step * 2
                    hdi_tag_sx2 = (panel_x - lamination[0].BAR4X1) * 0.5
                    hdi_tag_sx3 = panel_x - hdi_tag_sx2
                    hdi_tag_sx2fd = hdi_tag_sx3 - lamination[0].BAR4X2
                else:
                    hdi_tag_sy1 = panel_y * 0.5 - lamination[-1].BAR4Y1 * 0.5 + tag_step
                    hdi_tag_sy4 = hdi_tag_sy1 + lamination[-1].BAR4Y1 - tag_step * 2
                    hdi_tag_sy1fd = hdi_tag_sy4 - lamination[-1].BAR4Y2 + tag_step * 2
                    hdi_tag_sx2 = (panel_x - lamination[-1].BAR4X1) * 0.5
                    hdi_tag_sx3 = panel_x - hdi_tag_sx2
                    hdi_tag_sx2fd = hdi_tag_sx3 - lamination[-1].BAR4X2                    
                    
            tag3_x_list = [hdi_tag_shx1, hdi_tag_shx2, hdi_tag_shx2]
            tag3_y_list = [hdi_tag_hy2, hdi_tag_hy2, hdi_tag_hy1]

            tag4_x_list = [hdi_tag_sx2fd, hdi_tag_sx2, hdi_tag_sx3, hdi_tag_sx3]
            tag4_y_list = [hdi_tag_sy1fd, hdi_tag_sy4, hdi_tag_sy1, hdi_tag_sy4]

            inn_layer = 'inn%s%s' % (from_id, to_id)
            dbk_layer = 'dbkb%s-%s' % (from_id, to_id)
            top_layer = 'l%s' % from_id
            bot_layer = 'l%s' % to_id
            if top_layer not in info:
                info[top_layer] = self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol='sh-dwtop'+"2023",
                                                       polarity='negative')
            else:
                info[top_layer].extend(
                    self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol='sh-dwtop'+"2023",
                                         polarity='negative'))

            info[top_layer].extend(
                self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol='r0', polarity='positive',
                                     attribute='.fiducial_name,text=317.reg'))
            info[top_layer].extend(self.convert_to_dict(x_list=tag3_x_list, y_list=tag3_y_list, symbol='sh-dwtop'+"2023",
                                                        polarity='negative'))

            if bot_layer not in info:
                info[bot_layer] = self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol='sh-dwbot'+"2023",
                                                       polarity='negative')
            else:
                info[bot_layer].extend(
                    self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol='sh-dwbot'+"2023",
                                         polarity='negative'))

            info[bot_layer].extend(
                self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol='r0', polarity='positive',
                                     attribute='.fiducial_name,text=317.reg'))
            info[bot_layer].extend(self.convert_to_dict(x_list=tag3_x_list, y_list=tag3_y_list, symbol='sh-dwbot'+"2023",
                                                        polarity='negative'))
            
            #http://192.168.2.120:82/zentao/story-view-6102.html 
            # 等于是在设计靶标的后面哪些层都掏开。开料钻的靶孔也是这样，
            # 从内层到后面都掏开。外层不用管，外层干膜有封孔能力
            # 这里需在循环下 20231023 by lyh
            for other_fill_hash in fill_array:
                other_layer_name = str(other_fill_hash.layer_name)
                other_layer_id = int(other_layer_name.strip('-fz').split('-')[0][1:])
                if re.search('fz',other_layer_name):
                    continue

                if  1< other_layer_id < from_id or to_id< other_layer_id < job_signal_numbers:
                    other_info_list = self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol="s5082",
                                                       polarity='negative')
                    other_info_list.extend(self.convert_to_dict(x_list=tag3_x_list, y_list=tag3_y_list, symbol='s5082',
                                                        polarity='negative'))                    
                    if info.has_key(other_layer_name):
                        info[other_layer_name].extend(other_info_list)
                    else:
                        info[other_layer_name] = other_info_list          

            if zero_burry_yn == 'yes':
                burry_layer = zero_burry
                info[dbk_layer] = self.convert_to_dict(x_list=tag3_x_list, y_list=tag3_y_list, symbol='r3175')
                coreInnXList = [6, 6, panel_x - 6, panel_x - 6]
                coreInnYList = [6, panel_y - 6, panel_y - 6, 6]
                info[dbk_layer].extend(self.convert_to_dict(x_list=coreInnXList, y_list=coreInnYList, symbol='r2500'))
                info[inn_layer] = self.convert_to_dict(x_list=tag3_x_list, y_list=tag3_y_list, symbol='r3100')

                info[burry_layer] = self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol='r3175')

            # === 有盲孔存在时，添加盲孔定位孔钻带层 ===
            if zero_blind_yn == 'yes':
                lr_layer = 'lr%s-%s' % (from_id, to_id)
                info[lr_layer] = self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list, symbol='r3175',
                                                      polarity='positive')
                for zero_blind_layer in zero_blind:
                    info[zero_blind_layer] = self.convert_to_dict(x_list=tag4_x_list, y_list=tag4_y_list,
                                                                  symbol='r3175',
                                                                  polarity='positive')

        info['蚀刻引线'] = self.convert_to_dict(x_list=etch_dw_x , y_list=etch_dw_y, symbol='r0',
                                            attribute='.fiducial_name,text=317.reg')
        info['蚀刻引线c'] = self.convert_to_dict(x_list=etch_dw_x, y_list=etch_dw_y, symbol='sh-dwtop',
                                             polarity='negative')
        info['蚀刻引线s'] = self.convert_to_dict(x_list=etch_dw_x, y_list=etch_dw_y, symbol='sh-dwbot',
                                             polarity='negative')


        # if etch_lyr_symbol:
        #     # === V2.03 周涌要求增加 需求3793 ===
        #
        #     info['蚀刻引线c'] = self.convert_to_dict(x_list=etch_dw_x, y_list=etch_dw_y, symbol='sh-dwtop',
        #                                          polarity='negative')
        #     info['蚀刻引线s'] = self.convert_to_dict(x_list=etch_dw_x, y_list=etch_dw_y, symbol='sh-dwbot',
        #                                          polarity='negative')

        info['选化'] = self.convert_to_dict(x_list=sgt_lyr_x, y_list=sgt_lyr_y, symbol=sgt_lyr_symbol,
                                          polarity='negative')
        return info


class back_drill_tag(STATIC_SYM):
    """
    背钻、控深钻靶孔添加，包含外层背钻及内层背钻bd_info
    """
    priority = 1.9

    def __init__(self, frozen_json=None, avoidArea=None, priority=1.9):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        bd_info = self.parm.bd_info
        if len(bd_info) == 0:
            return info
        drill_type_yn = self.parm.drill_type_yn
        lamination = self.parm.lamination
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        fill_array = self.parm.fill_array
        through_hole = self.parm.drl
        for bd_line in bd_info:
            bd_layers = []
            cur_yh_num = bd_line.cur_yh_num
            if cur_yh_num == len(lamination):
                tail1_word = ''
            else:
                tail1_word = '-%s' % (bd_line.start_num)
            tail2_word = bd_line.side_word
            for cur_bd_type in list(set(bd_line.drill_type)):
                if cur_bd_type == "Controll Depth":
                    start_word = 'cd'
                elif cur_bd_type == 'Backdrill':
                    start_word = 'bd'
                elif cur_bd_type == 'Countersink':
                    start_word = 'cs'
                elif cur_bd_type == 'Counterbore':
                    start_word = 'cb'
                
                lay = "%s%s%s" % (start_word, tail1_word, tail2_word)
                if self.GEN.LAYER_EXISTS(lay, job=self.JOB, step="panel") == "yes":                    
                    bd_layers.append(lay)
                
            # if self.JOB.split("-")[0].upper() == "H47508GB544C1":
            # 同一开始层有多个背钻 且靶距不一样的 此处循环下
            if len(set(bd_line.TARGET_X1)) > 1 or not bd_layers:                
                bd_layers = bd_line.drl_names
                
            exist_add_coor_info = []
            
            for index_num, lay in enumerate(bd_layers):                
                
                # bd1-4 cd1-4 cs1-4 cb1-4等层名不加靶孔 此层都会被合并
                if re.match("[bc][cbds][1-9][1-9]?-[1-9][1-9]?", lay):
                    continue
                
                # 检测背钻层是否存在 不存在的直接创建 20221220  by lyh
                bd_innlayer = lay + ".inn"
                
                if self.GEN.LAYER_EXISTS(lay, job=self.JOB, step="panel") == "no":
                    self.GEN.CREATE_LAYER(lay, ins_lay='drl', context='board', add_type='drill')
                    
                if self.GEN.LAYER_EXISTS(bd_innlayer, job=self.JOB, step="panel") == "no":
                    self.GEN.CREATE_LAYER(bd_innlayer, ins_lay=lay, context='board', add_type='drill')                
                
                bd_erf_name = bd_line.erp_drill_name
                inn_size = ''
                for line in drill_type_yn:
                    print line[0]
                    print line[1]
                    if line[0] == bd_erf_name:
                        if line[1] == 'Y':
                            inn_size = '3100'
                        elif line[1] == 'N':
                            inn_size = '2950'
                if not inn_size:
                    msg_dict = {'type': 'critical',
                                'windowTitle': '警告',
                                'content': '未匹配到钻带中孔类型，钻带:%s定位孔使用2950!' % bd_erf_name}
                    self.msg_array.append(msg_dict)
                    inn_size = '2950'
                # print inn_size
                # print bd_erf_name
                # exit(0)
                hdi_bk_x1 = panel_x * 0.5 - bd_line.TARGET_X1[index_num] * 0.5
                hdi_bk_x2 = hdi_bk_x1 + bd_line.TARGET_X2[index_num]
    
                hdi_bk_y1 = panel_y * 0.5 - bd_line.TARGET_Y1[index_num] * 0.5
                hdi_bk_y2 = hdi_bk_y1 + bd_line.TARGET_Y1[index_num]
                hdi_bk_y3 = hdi_bk_y2 - bd_line.TARGET_Y2[index_num]
    
                bd_text = bd_line.side_word.upper()
                bd_tag_x_list = [hdi_bk_x1, hdi_bk_x1, hdi_bk_x2, hdi_bk_x2]
                bd_tag_y_list = [hdi_bk_y3, hdi_bk_y2, hdi_bk_y1, hdi_bk_y2]
                
                # self.GEN.PAUSE(str([lay, exist_add_coor_info]))
                if (bd_tag_x_list, bd_tag_y_list) not in exist_add_coor_info:
                    exist_add_coor_info.append((bd_tag_x_list, bd_tag_y_list))
                else:
                    # 同一开始层有多个背钻 且靶距一样的 不重复添加 只加孔 20221213 by lyh                      
                    bd_innlayer = lay + ".inn"
                    info[bd_innlayer] = self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list,
                                                             symbol='r%s' % inn_size,
                                                             polarity='positive',
                                                             attribute='.string,text=id_{0}'.format("_".join(bd_line.mysql_id)))                    
                    continue
                # self.GEN.PAUSE(str([bd_innlayer, inn_size, exist_add_coor_info]))
                bd_text_x_list = [hdi_bk_x1 - 2.25, hdi_bk_x1 - 2.25, hdi_bk_x2 - 2.25, hdi_bk_x2 - 2.25]
                bd_text_y_list = [hdi_bk_y3 + 1.2, hdi_bk_y2 + 1.2, hdi_bk_y1 + 1.2, hdi_bk_y2 + 1.2]
    
                bd_sym_list = ['hdi1-bmd', 'hdi1-bmd', 'hdi1-bmd', 'hdi1-bmdj']
                #bd_top_sig_sym = 'sh-dwtop'
                #bd_bot_sig_sym = 'sh-dwbot'
                # 翟鸣通知 控深靶的下一次压合位置掏开处理 外层掏大单边5mil吧 20240307 by lyh
                bd_top_sig_sym = "s5334"
                bd_bot_sig_sym = "s5334"
                if through_hole == lay:
                    bd_sym_list = [None, None, None, None]
                    bd_top_sig_sym = None
                    bd_bot_sig_sym = None
                    bd_text = None
                bd_inner_list = ['s5080', 's5080', 's5080', 's5080']
    
                # for index, cur_lamin in enumerate (lamination, 1):
                (from_lyr, to_lyr) = \
                [(str(cur_lamin.FROMLAY).lower(), str(cur_lamin.TOLAY).lower())
                 for cur_lamin in lamination if int(cur_lamin.PROCESS_NUM - 1) == int(cur_yh_num)][0]
                from_id = int(from_lyr[1:])
                from_next = from_id + 1
                to_id = int(to_lyr[1:])
                to_pre = to_id - 1
                # 修改和T靶最后一次压合添加逻辑一致,获取最后一次压合前一次压合的起始层
                # http://192.168.2.120:82/zentao/story-view-7141.html
                if cur_yh_num > 1:
                    (from_lyr_2, to_lyr_2) = [(str(cur_lamin.FROMLAY).lower(), str(cur_lamin.TOLAY).lower()) for cur_lamin in lamination if int(cur_lamin.PROCESS_NUM - 1) == int(cur_yh_num)-1][0]
                    from_id_2 = int(from_lyr_2[1:])
                    to_id_2 = int(to_lyr_2[1:])
                    add_bmd_bar_layers = ['l{0}'.format(num+1) for num in range(from_id, from_id_2)] + \
                                         ['l{0}'.format(num) for num in range(to_id_2, to_id)]
                else:
                    add_bmd_bar_layers = ['l{0}'.format(num) for num in range(from_next, to_id)]


                for fill_hash in fill_array:
                    if fill_hash.layer_name == 'l%s' % from_id:
                        if fill_hash.layer_side == '正':
                            sig_from_add_symbol = bd_top_sig_sym
                        else:
                            sig_from_add_symbol = bd_bot_sig_sym
    
                    if fill_hash.layer_name == 'l%s' % to_id:
                        if fill_hash.layer_name == 'l%s' % to_id:
                            if fill_hash.layer_side == '正':
                                sig_to_add_symbol = bd_top_sig_sym
                            else:
                                sig_to_add_symbol = bd_bot_sig_sym



                if 'l%s' % from_id not in info:
                    info['l%s' % from_id] = self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list,
                                                                 symbol=sig_from_add_symbol, polarity='negative')
                else:
                    info['l%s' % from_id].extend(self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list,
                                                                      symbol=sig_from_add_symbol, polarity='negative'))
                if 'l%s' % to_id not in info:
                    info['l%s' % to_id] = self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list,
                                                               symbol=sig_to_add_symbol, polarity='negative')
                else:
                    info['l%s' % to_id].extend(self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list,
                                                                    symbol=sig_to_add_symbol, polarity='negative'))

                for layer_num in range(from_next, to_id):
                    layer = 'l%s' % layer_num
                    if layer in add_bmd_bar_layers:
                        add_symbol = bd_sym_list
                        add_pol = 'positive'
                    else:
                        add_symbol = bd_inner_list
                        add_pol = 'negative'

                    if layer not in info:
                        info[layer] = self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list, symbol=add_symbol,
                                                           polarity=add_pol)
                    else:
                        info[layer].extend(self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list,
                                                                symbol=add_symbol, polarity=add_pol))
                    if layer in add_bmd_bar_layers:
                        info[layer].extend(
                            self.convert_to_dict(x_list=bd_text_x_list, y_list=bd_text_y_list, text=bd_text,
                                                 x_size='0.889', y_size='0.889', w_factor=0.6666666865,
                                                 angle='0',
                                                 mirror='no', fontname='simple'))

                # for layer in ['l%s' % from_next, 'l%s' % to_pre]:
                #     if layer not in info:
                #         info[layer] = self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list, symbol=bd_sym_list,
                #                                            polarity='positive')
                #     else:
                #         info[layer].extend(self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list,
                #                                                 symbol=bd_sym_list, polarity='positive'))
                #     info[layer].extend(self.convert_to_dict(x_list=bd_text_x_list, y_list=bd_text_y_list, text=bd_text,
                #                                             x_size='0.889', y_size='0.889', w_factor=0.6666666865,
                #                                             angle='0',
                #                                             mirror='no', fontname='simple'))
                # for layer_num in range(from_next + 1, to_pre):
                #     layer = 'l%s' % layer_num
                #     if layer not in info:
                #         info[layer] = self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list, symbol=bd_inner_list,
                #                                            polarity='negative')
                #     else:
                #         info[layer].extend(self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list,
                #                                                 symbol=bd_inner_list, polarity='negative'))
            
                info[bd_innlayer] = self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list,
                                                         symbol='r%s' % inn_size,
                                                         polarity='positive',
                                                         attribute='.string,text=id_{0}'.format("_".join(bd_line.mysql_id)))
                
                #翟鸣通知 陆工，脚本再帮忙优化下，外层掏大一点儿，然后将外层负片缩小单边3mil反转极性做到开窗和档点 20240308 by lyh
                if '防焊' not in info:
                    info['防焊'] = self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list, symbol='s5182', polarity='positive')
                else:
                    info['防焊'].extend(self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list, symbol='s5182', polarity='positive'))
                
                if '档点' not in info:
                    info['档点'] = self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list, symbol='s5182', polarity='positive')
                else:
                    info['档点'].extend(self.convert_to_dict(x_list=bd_tag_x_list, y_list=bd_tag_y_list, symbol='s5182', polarity='positive'))            

        return info
    

class add_bd_dw_holes(DYNAMIC_SYM):
    """
    添加背钻定位孔 因背钻定位孔要避开外钻孔 放到最后添加 V2.14
    """
    priority = 20

    def __init__(self, frozen_json=None, avoidArea=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_width = self.parm.sr_width
        sr_lenth = self.parm.sr_lenth
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        profile_xmin = self.parm.profile_xmin
        jobname = self.JOB
        stepname = "panel"
        job = gClasses.Job(jobname)
        matrixinfo = job.matrix.getInfo()
        step = gClasses.Step(job, stepname)
        step.open()
        step.COM("units,type=mm")        
            
        # 测试
        if not self.parm.get('bd_has_3175_dw_hole', None) and \
           "-" not in self.JOB:
            return info
        
        # 周涌通知取消此定位孔 板边已有2.0mm的孔 20240717 by lyh
        return info        

        #step.removeLayer("bd_tmp")
        #step.createLayer("bd_tmp")
        #step.affect("bd_tmp")
        if profile_ymax - sr_ymax > 12:
            # 左上角
            left_upper_x = sr_xmin + 6
            left_upper_y = sr_ymax + 10
            
            area_xmin = left_upper_x - 4.5
            area_xmax = sr_xmin + sr_width / 3
            area_ymax = left_upper_y
            area_ymin = left_upper_y
            return_x1, return_y1 = self.optimize_coord("rect8350x3175", x=left_upper_x, y=left_upper_y, area_xmin=area_xmin,
                                                       area_xmax=area_xmax)             
            # 左下角
            left_down_x = sr_xmin + 6 + 6.325
            left_down_y = sr_ymin - 10
            
            area_xmin = left_down_x - 11
            area_xmax = sr_xmin + sr_width / 3
            area_ymax = left_down_y
            area_ymin = left_down_y
            return_x2, return_y2 = self.optimize_coord("rect21000x3175", x=left_down_x, y=left_down_y, area_xmin=area_xmin,
                                                       area_xmax=area_xmax)            
            # 右下角
            right_down_x = sr_xmax - 6
            right_down_y = sr_ymin - 10
            area_xmin = sr_xmax - sr_width / 3
            area_xmax = right_down_x + 4.5
            area_ymax = right_down_y
            area_ymin = right_down_y
            return_x3, return_y3= self.optimize_coord("rect8350x3175", x=right_down_x, y=right_down_y, area_xmin=area_xmin,
                                                       area_xmax=area_xmax)            
            
            # 右上角
            right_upper_x = return_x3 - 8.35
            right_upper_y = sr_ymax + 10            
            area_xmin = sr_xmax - sr_width / 3
            area_xmax = right_upper_x + 4.5
            area_ymax = right_upper_y
            area_ymin = right_upper_y
            return_x4, return_y4= self.optimize_coord("rect8350x3175", x=right_upper_x, y=right_upper_y, area_xmin=area_xmin,
                                                       area_xmax=area_xmax)
            
            angle = 0
        else:
            # 加到长边
            # 左上角
            left_upper_x = sr_xmin - 4.5
            left_upper_y = sr_ymax - 10
            
            area_xmin = left_upper_x
            area_xmax = left_upper_x
            area_ymin = sr_ymax - sr_lenth / 3
            area_ymax = left_upper_y + 4.5            
            return_x1, return_y1 = self.optimize_coord("rect3175x8350", x=left_upper_x, y=left_upper_y, area_ymin=area_ymin,
                                                       area_ymax=area_ymax)             
            # 左下角
            left_down_x = sr_xmin - 4.5
            left_down_y = sr_ymin + 10
            
            area_xmin = left_down_x
            area_xmax = left_down_x
            area_ymin = left_down_y - 11
            area_ymax = sr_ymin + sr_lenth / 3
            return_x2, return_y2 = self.optimize_coord("rect3175x21000", x=left_down_x, y=left_down_y, area_ymin=area_ymin,
                                                       area_ymax=area_ymax)            
            # 右下角
            right_down_x = sr_xmax + 4.5
            right_down_y = sr_ymin + 10
            
            area_xmin = right_down_x
            area_xmax = right_down_x
            area_ymin = right_down_y - 4.5
            area_ymax = sr_ymin + sr_lenth / 3
            return_x3, return_y3= self.optimize_coord("rect3175x8350", x=right_down_x, y=right_down_y, area_ymin=area_ymin,
                                                       area_ymax=area_ymax)            
            
            # 右上角
            right_upper_x = sr_xmax + 4.5
            right_upper_y = return_y1 - 8.35
            
            area_xmin = right_upper_x
            area_xmax = right_upper_x
            area_ymin = sr_ymax - sr_lenth / 3
            area_ymax = right_upper_y + 4.5
            return_x4, return_y4= self.optimize_coord("rect3175x8350", x=right_upper_x, y=right_upper_y, area_ymin=area_ymin,
                                                       area_ymax=area_ymax)
            
            angle = 90
            
            
        for drill_layer in ["bdc", "bds"]:
            if step.isLayer(drill_layer):
                for x, y , symbol in [(return_x1, return_y1, "rect8350x3175"),
                                      (return_x2, return_y2, "rect21000x3175"),
                                      (return_x3, return_y3, "rect8350x3175"),
                                      (return_x4, return_y4, "rect8350x3175")]:
                    # step.addPad(x, y, symbol, angle=angle)        
                    if drill_layer == "bdc":
                        flag = -1
                    else:
                        flag = 1                        
                    if angle == 0:
                        # 短边
                        list_bd_y = [y]
                        if (x, y) in [(return_x1, return_y1), (return_x2, return_y2)]:                            
                            list_bd_x = [x + flag * (2  + 3.175) * 0.5]
                            if (x, y) == (return_x2, return_y2):
                                list_bd_x = [x + flag * (2  + 3.175 ) *2 * 0.5 - 3.4,
                                             x + flag * (2  + 3.175) *2 * 0.5 + 3.715 + 2 - 3.4]
                                list_bd_y = [y, y]                                
                        else:
                            list_bd_x = [x - flag * (2  + 3.175) * 0.5]
                    else:
                        # 长边
                        list_bd_x = [x]
                        if (x, y) in [(return_x2, return_y2), (return_x4, return_y4)]:                            
                            list_bd_y = [y + flag * (2  + 3.175) * 0.5]
                            if (x, y) == (return_x2, return_y2):
                                list_bd_y = [y + flag * (2  + 3.175 ) *2 * 0.5 - 3.4,
                                             y + flag * (2  + 3.175) *2 * 0.5 + 3.715 + 2 - 3.4]
                                list_bd_x = [x, x]                                
                        else:
                            list_bd_y = [y - flag * (2  + 3.175) * 0.5]                            
                
                    if info.has_key(drill_layer):
                        info[drill_layer].extend(self.convert_to_dict(x_list=list_bd_x, y_list=list_bd_y, symbol='r3175'))                        
                    else:
                        info[drill_layer] = self.convert_to_dict(x_list=list_bd_x, y_list=list_bd_y, symbol='r3175')
                        
        # step.clearAll()
        
        return info
    
class hdi_dld_new(DYNAMIC_SYM):
    """
    dld层别 新算法
    """
    priority = 2

    def __init__(self, frozen_json=None, avoidArea=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        # 测试
        #if "-lyh" not in self.JOB:            
            #return info
            
        os.environ["ADD_DLD_BABIAO"] = "NEW"
        
        true_signal_numbers = self.parm.true_signal_numbers
        half_layer_num = int(true_signal_numbers * 0.5)
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_width = self.parm.sr_width
        sr_lenth = self.parm.sr_lenth
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y        
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        profile_xmin = self.parm.profile_xmin

        right_fd_v = self.parm.right_fd_v
        right_fd_h = self.parm.right_fd_h
        through_drl = self.parm.drl
        # --dld层别定义
        blind_list = self.parm.blind_list
        if len(blind_list) == 0:
            # --没有盲孔不需要添加
            return info
        blind_burry_list = self.parm.blind_burry_list
        blind_burry_start = self.parm.blind_burry_start
        blind_burry_end = self.parm.blind_burry_end
        blind_burry_by_lamin = self.parm.blind_burry_by_lamin

        tmp_check = [i for i in blind_burry_by_lamin if int(i.cur_yh_num) == 0]
        no_dld_layer = []
        if len(tmp_check) == 1:
            zero_lamin = tmp_check[0]
            if hasattr(zero_lamin, 'blindLayer'):
                no_dld_layer = no_dld_layer + zero_lamin.blindLayer

        jobname = self.JOB
        stepname = "panel"
        job = gClasses.Job(jobname)
        step = gClasses.Step(job, stepname)
        step.open()
        if "-lyh" in self.JOB: 
            step.removeLayer("dld_check_area_tmp")
            step.createLayer("dld_check_area_tmp")
        
        dld_list = []
        dld_from_list = []
        dld_mid_list = []
        dld_to_list = []
        dic_top_bot_zu = {}# 把顶层跟底层对应一个压合层次分到一组
        for i, layer in enumerate(blind_burry_list):
            if layer in blind_list:
                index_start = int(blind_burry_start[i][1:])
                index_end = int(blind_burry_end[i][1:])
                tmp_layer = "dld%s-%s" % (index_start, index_end)
                if layer not in no_dld_layer:
                    dld_list.append(tmp_layer)
                    # === 仅考虑1-3 类型
                    layer_mid = ''
                    if abs(index_start - index_end) == 2:
                        layer_mid = 'l%s' % ((index_start + index_end) / 2)
                        
                    if index_start >= half_layer_num:
                        layer_from = 'l%s' % (index_end)
                        layer_to = 'l%s' % (index_end - 1)
                        
                        # 1to4的情况
                        if abs(index_start - index_end) > 2:
                            layer_mid = []
                            for i in range(abs(index_start - index_end) - 1):                                
                                layer_mid.append('l%s' % (index_end+1+i))                            
                    else:
                        layer_from = 'l%s' % (index_end)
                        layer_to = 'l%s' % (index_end + 1)
                        
                        # 1to4的情况
                        if abs(index_start - index_end) > 2:
                            layer_mid = []
                            for i in range(abs(index_start - index_end) - 1):                                
                                layer_mid.append('l%s' % (index_start+1+i))                         
                    ##
                    ##1to3 1toN 仅skipvia时重新计算内靶的位置 20240528 by lyh
                    #if "-lyh" in job.name:
                        #job.PAUSE(str([1, layer, layer_from,layer_to, layer_mid, index_start]))
                    skip_via_change = ""
                    skip_via_change2 = "no"
                    if abs(index_start - index_end) >= 2:
                        if index_start >= half_layer_num:
                            flag = -1
                        else:
                            flag = 1
                            
                        for i in range(1, 10):
                            next_drill = "s{0}-{1}".format(index_start, index_start+i*flag)
                            if next_drill in blind_list and next_drill <> layer:
                                break
                        else:                                                       
                            #先同时计算反面的镭射也是否为skipvia 且是否导通 保持两面一致 若存在s-6-7-8 反面s20-18导通 则按旧的逻辑             
                            if index_start >= half_layer_num:
                                reverse_laser_drill = "s{0}-{1}".format(true_signal_numbers-index_start+1, true_signal_numbers-index_start+3)
                                if reverse_laser_drill in blind_list:
                                    skip_via_change2 = "no"
                                    for i in range(1, 10):
                                        next_drill = "s{0}-{1}".format(true_signal_numbers-index_start+1, true_signal_numbers-index_start+1+i*1)
                                        if next_drill in blind_list and next_drill <> reverse_laser_drill:
                                            skip_via_change = "no"
                                            break
                                    else:
                                        layer_mid2 = []                                        
                                        for i in range(abs(index_start - index_end) - 1):                                
                                            layer_mid2.append('l%s' % (true_signal_numbers-index_start+1+1+i))                                        
                                        _,_, _,skip_via_change2 =self.check_only_skip_via_layer(reverse_laser_drill, true_signal_numbers-index_start+1,
                                                                                               true_signal_numbers-index_start+2, layer_from,
                                                                                               layer_to, layer_mid2, flag)                                            
                            else:
                                reverse_laser_drill = "s{0}-{1}".format(true_signal_numbers-index_start+1, true_signal_numbers-index_start-1)
                                if reverse_laser_drill in blind_list:
                                    skip_via_change2 = "no"
                                    for i in range(1, 10):
                                        next_drill = "s{0}-{1}".format(true_signal_numbers-index_start+1, true_signal_numbers-index_start+1+i*-1)
                                        if next_drill in blind_list and next_drill <> reverse_laser_drill:
                                            skip_via_change = "no"
                                            break
                                    else:
                                        layer_mid2 = []                                        
                                        for i in range(abs(index_start - index_end) - 1):                                
                                            layer_mid2.append('l%s' % (true_signal_numbers-index_start-1+1+i))                                        
                                        _,_, _,skip_via_change2 =self.check_only_skip_via_layer(reverse_laser_drill, true_signal_numbers-index_start+1,
                                                                                               true_signal_numbers-index_start+2, layer_from,
                                                                                               layer_to, layer_mid2, flag)
                            if skip_via_change != "no":
                                if skip_via_change2 == "yes":                                    
                                    layer_from,layer_to, layer_mid,skip_via_change = "l{0}".format(index_end - flag), "l{0}".format(index_end), layer_mid, "yes"
                                else:
                                    layer_from,layer_to, layer_mid,skip_via_change =self.check_only_skip_via_layer(layer, index_start,
                                                                                                                      index_end, layer_from,
                                                                                                                      layer_to, layer_mid, flag)
                            if "-lyh" in job.name:
                                job.PAUSE(str([layer, reverse_laser_drill, layer_from,layer_to, layer_mid,skip_via_change]))
                    
                    # 按对称的层数相等来分组
                    if min([index_start, index_end]) > half_layer_num:
                        zu = max([index_start , index_end]) - (half_layer_num + 0.5)
                    else:
                        zu = (half_layer_num + 0.5) - min([index_start , index_end])
                    
                    through_layer = 1
                    if layer_mid:
                        through_layer = 2
                        
                    if dic_top_bot_zu.has_key(zu*through_layer):
                        dic_top_bot_zu[zu*through_layer].append(tmp_layer)
                    else:
                        dic_top_bot_zu[zu*through_layer] = [tmp_layer]
                    
                    dld_from_list.append(layer_from)
                    dld_to_list.append(layer_to)
                    dld_mid_list.append(layer_mid)
                    
                    info_this = self.GEN.DO_INFO('-t layer -e %s/panel/%s -d EXISTS' % (self.JOB, tmp_layer))
                    if info_this['gEXISTS'] == "yes":
                        self.GEN.CLEAR_LAYER()
                        self.GEN.AFFECTED_LAYER(tmp_layer, 'yes')
                        self.GEN.SEL_DELETE()
                    else:
                        self.GEN.CREATE_LAYER(tmp_layer, ins_lay=through_drl, add_type='drill', location='before')                    
                    
        add_dld_direct = 'ver'
        if profile_ymax < 622.3 and profile_xmax < 546.1:
            add_dld_direct = 'hor'
            
        lamin_data = self.parm.lam_rout_new
        
        # 先取第一次压合捞边的尺寸
        for i in lamin_data:
            if i[0] == 1:
                rout_x = i[1]
                rout_y = i[2]         
        
        arraylist_rect = []                
        # 模拟计算获取所有可添加的区域
        find_rect_area = self.get_auto_calc_area(profile_xmin, profile_ymin,
                                                 sr_xmin, sr_ymin,
                                                 profile_xmax, profile_ymax,
                                                 rout_x, rout_y,
                                                 "s3750",step,
                                                 add_dld_direct, arraylist_rect)
        #按同一水平位置分组
        dic_zu = {}
        all_x = set([r[0] for r in find_rect_area])
        all_y = set([r[1] for r in find_rect_area])
        
        if add_dld_direct == 'hor':
            for zu in all_y:
                dic_zu[zu] = []
                for x, y, rect in find_rect_area:
                    if zu == y:
                        dic_zu[zu].append([x, y, rect])
        else:
            for zu in all_x:
                dic_zu[zu] = []
                for x, y, rect in find_rect_area:
                    if zu == x:
                        dic_zu[zu].append([x, y, rect])            
            
        add_babiao_num = [len(value) for value in dic_top_bot_zu.values()]
        
        zu_info = []
        for key, values in dic_zu.iteritems():
            # 优先同一水平位置有3个 保证防呆位置能错开
            if len(values) >= 3:
                zu_info.append(values)
        
        if sum([len(value) for value in zu_info]) < sum(add_babiao_num):
            zu_info = []
            for key, values in dic_zu.iteritems():
                # 同一水平位置有2个 保证防呆位置能错开
                if len(values) >= 2:
                    zu_info.append(values)
                    
            if sum([len(value) for value in zu_info]) < sum(add_babiao_num):
                # 按旧的逻辑添加
                os.environ["ADD_DLD_BABIAO"] = "OLD1"
                return info        
        
        # 排序 
        exists_add_rect = []
        exists_add_fd_rect = []
        for key in sorted(dic_top_bot_zu.keys())[::-1]:
            value = dic_top_bot_zu[key]            
            all_sig_layers = []
            arraylist_zu = []
            for index, dld_layer in enumerate(dld_list):
                if dld_layer in value:
                    dld_from=dld_from_list[index]
                    dld_to = dld_to_list[index]
                    dld_mid = dld_mid_list[index]
                    arraylist_zu.append([dld_from, dld_to, dld_mid, dld_layer])
                    result = re.findall("(\d\d?)", dld_layer)
                    if result:                        
                        all_sig_layers.append("l"+result[0])
                        all_sig_layers.append("l"+result[1])

            all_sig_layers = [x for x in all_sig_layers if x.strip()]
            
            #获取当前层次的压合捞边数据
            sort_all_sig_layers = sorted(all_sig_layers, key=lambda x: int(x[1:]))
            for i in lamin_data:
                if i[3].upper() == sort_all_sig_layers[0].upper():
                    rout_x = i[1]
                    rout_y = i[2]                                     
                            
            if add_dld_direct == "hor":
                area_xmin = profile_xmin + (profile_xmax - rout_x) * 0.5 + 40 
                area_xmax = profile_xmin + (profile_xmax - rout_x) * 0.5 + 90
                area_ymax = sr_ymin - 1
                area_ymin = profile_ymin + (profile_ymax - rout_y) * 0.5 + 12
            else:
                area_xmax = sr_xmin - 1
                area_xmin = profile_xmin + (profile_xmax - rout_x) * 0.5 + 12
                area_ymax = profile_ymin + (profile_ymax - rout_y) * 0.5 + 90
                area_ymin = profile_ymin + (profile_ymax - rout_y) * 0.5 + 40  
                
            area_rect = RECTANGLE(symbol="s3750", xmin=area_xmin, ymin=area_ymin,
                                  xmax=area_xmax, ymax=area_ymax)                  
            info, exists_add_rect, exists_add_fd_rect = self.get_add_pad_info(sr_xmin, sr_ymin,
                                                                              sr_xmax, sr_ymax,
                                                                              info,arraylist_zu,
                                                                              dic_zu, zu_info,
                                                                              area_rect,exists_add_rect,
                                                                              exists_add_fd_rect,add_dld_direct )
            if info is None:
                os.environ["ADD_DLD_BABIAO"] = "OLD2"
                return {}
      
        return info
    
    def get_auto_calc_area(self, profile_xmin,profile_ymin,sr_xmin, sr_ymin, 
                           profile_xmax, profile_ymax, rout_x, rout_y, 
                           symbolname, step, add_dld_direct, include_rect_area=[]):
        """先模拟计算所有可以添加的rect区域"""
        
        if add_dld_direct == "hor":
            # 左下角短边
            left_down_x = profile_xmin + (profile_xmax - rout_x) * 0.5 + 40                  
            left_down_y = sr_ymin - 3
            
            area_xmin = left_down_x
            area_xmax = profile_xmin + (profile_xmax - rout_x) * 0.5 + 90
            area_ymax = sr_ymin - 1
            area_ymin = profile_ymin + (profile_ymax - rout_y) * 0.5 + 12
            fx = "X"
            step_x = 0.2
            step_y = -0.2
        else:
            # 左下角长边
            left_down_x = sr_xmin - 3                 
            left_down_y = profile_ymin + (profile_ymax - rout_y) * 0.5 + 40  
            
            area_xmax = sr_xmin - 1
            area_xmin = profile_xmin + (profile_xmax - rout_x) * 0.5 + 12
            area_ymax = profile_ymin + (profile_ymax - rout_y) * 0.5 + 90
            area_ymin = left_down_y
            fx = "Y"
            step_x = -0.2
            step_y = 0.2            
        
        if "-lyh" in self.JOB: 
            step.clearAll()
            step.affect("dld_check_area_tmp") 
        rect_area = self.optimize_coord_find_area_rect(symbolname, x=left_down_x, y=left_down_y, area_xmin=area_xmin,
                                                       area_xmax=area_xmax,area_ymin=area_ymin, area_ymax=area_ymax,
                                                       move_fx=fx, move_x_step=step_x, move_y_step=step_y, 
                                                       return_rect="yes",include_rect=include_rect_area,four_corner2ll="yes",                                            
                                                       step=step)
        #测试
        if "-lyh" in self.JOB:            
            if rect_area:
                step.clearAll()
                step.affect("dld_check_area_tmp")                   
                for x, y, rect in rect_area:
                    step.addRectangle(rect.xmin, rect.ymin, rect.xmax, rect.ymax)
                    step.addPad(x, y, symbolname)
                    
            
        return rect_area
    
    def get_add_pad_info(self, sr_xmin, sr_ymin, sr_xmax, sr_ymax, info, arraylist_zu,
                         dic_zu, zu_info, area_rect, exists_add_rect, exists_add_fd_rect,
                         add_dld_direct):
        """开始添加pad区域"""
        if add_dld_direct == "hor":
            sort_index = 0 # X的值
        else:
            sort_index = 1 # Y的值
        
        for arraylist_info in arraylist_zu:
            arraylist_xy = []
            for key in sorted(dic_zu.keys())[::-1]:
                if dic_zu[key] in zu_info:
                    # 三个固定位置的坐标X或Y由小到大 防呆位置X或Y由大到小
                    find_rect = []                
                    for x, y, rect in sorted(dic_zu[key], key=lambda x: x[sort_index]):
                        
                        # 再次检测symbol是否在单次锣边来计算的有效区域40-90
                        if rect not in [area_rect]:
                            continue
                        
                        if (x, y, rect) in exists_add_rect:
                            continue                        

                        # 左下角
                        x1,y1 = x, y
                        # 左上角
                        x2, y2 = x, sr_ymax + (sr_ymin - y)
                        # 右下角
                        x3, y3 = sr_xmax - (x - sr_xmin), y1                            
                        
                        arraylist_xy = [(x1, y1), (x2, y2),(x3, y3)]
                        exists_add_rect.append((x, y, rect))
                        find_rect.append(rect)
                        break
                    
                    if find_rect: 
                        #防呆角
                        for x, y, rect in sorted(dic_zu[key], key=lambda x: x[sort_index] * -1):
                                
                            # 防呆角跟上面三个角位置一致的跳过
                            if rect in find_rect:
                                continue
                            
                            # 再次检测symbol是否在单次锣边来计算的有效区域40-90
                            if rect not in [area_rect]:
                                continue                                    
                            
                            if (x, y, rect) in exists_add_fd_rect:
                                continue
                            
                            # 右上防呆角
                            x4, y4 = sr_xmax - (x - sr_xmin), sr_ymax + (sr_ymin - y)
                            
                            arraylist_xy.append((x4, y4))
                            exists_add_fd_rect.append((x, y, rect))
                            break
                        else:
                            # 防呆角位置找不到合适的 继续下一组20230130 by lyh
                            arraylist_xy = []
                            continue
                        
                        break
                    
            if not arraylist_xy:
                return None, None, None
            
            if len(arraylist_xy) != 4:
                return None, None, None            
            
            for dld_from, dld_to, dld_mid, dld_layer in [arraylist_info]:
                
                for tmp_x, tmp_y in arraylist_xy:
                    ldi_x_list = [tmp_x]
                    ldi_y_list = [tmp_y]
                    if dld_layer not in info:
                        info[dld_layer] = self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='r500')
                    else:
                        info[dld_layer].extend(self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='r500'))
        
                    if dld_mid:
                        if isinstance(dld_mid, list):
                            for dld_mid_new in dld_mid:
                                if dld_mid_new not in info:
                                    info[dld_mid_new] = self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s3850',
                                                                         polarity='negative')
                                else:   
                                    info[dld_mid_new].extend(self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s3850',
                                                                              polarity='negative'))
                        else:
                            if dld_mid not in info:
                                info[dld_mid] = self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s3850',
                                                                     polarity='negative')
                            else:   
                                info[dld_mid].extend(self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s3850',
                                                                          polarity='negative'))
                    ##
                        
                    if dld_from not in info:
                        info[dld_from] = self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='sh-ldi')
                    else:
                        info[dld_from].extend(self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='sh-ldi'))
                        
                    if dld_to not in info:
                        info[dld_to] = self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s3850')
                    else:
                        info[dld_to].extend(self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s3850'))
                        
        return info, exists_add_rect, exists_add_fd_rect
    
    def check_only_skip_via_layer(self, drill_layer, start_index, end_index, layer_from,layer_to, layer_mid, flag):
        """http://192.168.2.120:82/zentao/story-view-6834.html 20240528 by lyh
        （1）只存在L1-3 Skipvia，孔有连接L2层时，钻带使用L2层内靶对位；
        （2）只存在L1-3 Skipvia，孔不连接L2层时，钻带使用L3层内靶对位；
        （3）只存在L1-3 Skipvia，孔有部分连接L2层时，部分不连接L2层时，钻带使用L2层内靶对位；
        （4）同时存在L1-3 Skipvia和L1-2镭射，统一选用L2层内靶对位。
        （5）其余存在L1-N设计时，输出提示评审。
        以上情况可归结为 改一种情况即可 就是跟中间层导通的情况 加在N-1层上  其他的情况都不变"""        
        jobname = self.JOB
        stepname = "edit"
        job = gClasses.Job(jobname)
        step = gClasses.Step(job, stepname)
        step.open()
        step.COM("units,type=mm")
        check_mid_layers = []
        if isinstance(layer_mid, (list, tuple)):
            check_mid_layers = layer_mid
        else:
            check_mid_layers = [layer_mid]            
            
        for layer in check_mid_layers:
            step.removeLayer(layer+"_tmp")
            step.copyLayer(job.name, step.name, layer, layer+"_tmp")
            step.clearAll()
            step.affect(layer+"_tmp")
            step.contourize()
            
            step.refSelectFilter(drill_layer)
            if step.featureSelected():
                step.removeLayer(layer+"_tmp")
                
                step = gClasses.Step(job, "panel")
                step.open()                
                return "l{0}".format(end_index - flag), "l{0}".format(end_index), layer_mid, "yes"
            
            step.removeLayer(layer+"_tmp")
        
        step = gClasses.Step(job, "panel")
        step.open()
        
        return layer_from,layer_to, layer_mid, "no"          
        

class hdi_dld(DYNAMIC_SYM):
    """
    dld层别
    """
    priority = 2.05

    def __init__(self, frozen_json=None, avoidArea=None, priority=2.05):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        # 测试
        #if "-lyh" in self.JOB:
            #return info            
        # self.GEN.PAUSE(str(os.environ.get("ADD_DLD_BABIAO", None)))
        
        if os.environ.get("ADD_DLD_BABIAO", None) == "NEW":
            "按新的模块来添加 hdi_dld_new"
            return info 
        
        true_signal_numbers = self.parm.true_signal_numbers
        half_layer_num = int(true_signal_numbers * 0.5)
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_width = self.parm.sr_width
        sr_lenth = self.parm.sr_lenth
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y        
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        profile_xmin = self.parm.profile_xmin

        right_fd_v = self.parm.right_fd_v
        right_fd_h = self.parm.right_fd_h
        through_drl = self.parm.drl
        # --dld层别定义
        blind_list = self.parm.blind_list
        if len(blind_list) == 0:
            # --没有盲孔不需要添加
            return info
        
        # 旧的模式位置应该是不满足要求的 所有必须全部提醒
        warn_content = 'symbol : %s dld靶无法避开电镀夹头，需通知MI评审。！' % self.__class__.__doc__
        if warn_content not in self.warn_content_list:
            msg_dict = {'type': 'critical',
                        'windowTitle': '警告',
                        'content': 'symbol : %s dld靶无法避开电镀夹头，需通知MI评审。！' % self.__class__.__doc__}
            self.warn_content_list.append(warn_content)
            self.msg_array.append(msg_dict)
            
        blind_burry_list = self.parm.blind_burry_list
        blind_burry_start = self.parm.blind_burry_start
        blind_burry_end = self.parm.blind_burry_end
        blind_burry_by_lamin = self.parm.blind_burry_by_lamin

        tmp_check = [i for i in blind_burry_by_lamin if int(i.cur_yh_num) == 0]
        no_dld_layer = []
        if len(tmp_check) == 1:
            zero_lamin = tmp_check[0]
            if hasattr(zero_lamin, 'blindLayer'):
                no_dld_layer = no_dld_layer + zero_lamin.blindLayer

        dld_list = []
        dld_from_list = []
        dld_mid_list = []
        dld_to_list = []
        for i, layer in enumerate(blind_burry_list):
            if layer in blind_list:
                index_start = int(blind_burry_start[i][1:])
                index_end = int(blind_burry_end[i][1:])
                tmp_layer = "dld%s-%s" % (index_start, index_end)
                if layer not in no_dld_layer:
                    dld_list.append(tmp_layer)
                    # === 仅考虑1-3 类型
                    layer_mid = ''
                    if abs(index_start - index_end) == 2:
                        layer_mid = 'l%s' % ((index_start + index_end) / 2)
                        
                    if index_start >= half_layer_num:
                        layer_from = 'l%s' % (index_end)
                        layer_to = 'l%s' % (index_end - 1)
                        
                        # 1to4的情况
                        if abs(index_start - index_end) > 2:
                            layer_mid = []
                            for i in range(abs(index_start - index_end) - 1):                                
                                layer_mid.append('l%s' % (index_end+1+i))                            
                    else:
                        layer_from = 'l%s' % (index_end)
                        layer_to = 'l%s' % (index_end + 1)
                        
                        # 1to4的情况
                        if abs(index_start - index_end) > 2:
                            layer_mid = []
                            for i in range(abs(index_start - index_end) - 1):                                
                                layer_mid.append('l%s' % (index_start+1+i))  
                    ##
                    ##1to3 1toN 仅skipvia时重新计算内靶的位置 20240528 by lyh
                    #if "-lyh" in job.name:
                        #job.PAUSE(str([1, layer, layer_from,layer_to, layer_mid, index_start]))
                    skip_via_change = ""
                    skip_via_change2 = "no"
                    if abs(index_start - index_end) >= 2:
                        if index_start >= half_layer_num:
                            flag = -1
                        else:
                            flag = 1
                            
                        for i in range(1, 10):
                            next_drill = "s{0}-{1}".format(index_start, index_start+i*flag)
                            if next_drill in blind_list and next_drill <> layer:
                                break
                        else:                                                       
                            #先同时计算反面的镭射也是否为skipvia 且是否导通 保持两面一致 若存在s-6-7-8 反面s20-18导通 则按旧的逻辑             
                            if index_start >= half_layer_num:
                                reverse_laser_drill = "s{0}-{1}".format(true_signal_numbers-index_start+1, true_signal_numbers-index_start+3)
                                if reverse_laser_drill in blind_list:
                                    skip_via_change2 = "no"
                                    for i in range(1, 10):
                                        next_drill = "s{0}-{1}".format(true_signal_numbers-index_start+1, true_signal_numbers-index_start+1+i*1)
                                        if next_drill in blind_list and next_drill <> reverse_laser_drill:
                                            skip_via_change = "no"
                                            break
                                    else:
                                        layer_mid2 = []                                        
                                        for i in range(abs(index_start - index_end) - 1):                                
                                            layer_mid2.append('l%s' % (true_signal_numbers-index_start+1+1+i))                                        
                                        _,_, _,skip_via_change2 =self.check_only_skip_via_layer(reverse_laser_drill, true_signal_numbers-index_start+1,
                                                                                               true_signal_numbers-index_start+2, layer_from,
                                                                                               layer_to, layer_mid2, flag)                                            
                            else:
                                reverse_laser_drill = "s{0}-{1}".format(true_signal_numbers-index_start+1, true_signal_numbers-index_start-1)
                                if reverse_laser_drill in blind_list:
                                    skip_via_change2 = "no"
                                    for i in range(1, 10):
                                        next_drill = "s{0}-{1}".format(true_signal_numbers-index_start+1, true_signal_numbers-index_start+1+i*-1)
                                        if next_drill in blind_list and next_drill <> reverse_laser_drill:
                                            skip_via_change = "no"
                                            break
                                    else:
                                        layer_mid2 = []                                        
                                        for i in range(abs(index_start - index_end) - 1):                                
                                            layer_mid2.append('l%s' % (true_signal_numbers-index_start-1+1+i))                                        
                                        _,_, _,skip_via_change2 =self.check_only_skip_via_layer(reverse_laser_drill, true_signal_numbers-index_start+1,
                                                                                               true_signal_numbers-index_start+2, layer_from,
                                                                                               layer_to, layer_mid2, flag)
                            if skip_via_change != "no":
                                if skip_via_change2 == "yes":                                    
                                    layer_from,layer_to, layer_mid,skip_via_change = "l{0}".format(index_end - flag), "l{0}".format(index_end), layer_mid, "yes"
                                else:
                                    layer_from,layer_to, layer_mid,skip_via_change =self.check_only_skip_via_layer(layer, index_start,
                                                                                                                      index_end, layer_from,
                                                                                                                      layer_to, layer_mid, flag)
                            if "-lyh" in job.name:
                                job.PAUSE(str([layer, reverse_laser_drill, layer_from,layer_to, layer_mid,skip_via_change]))
                                
                    dld_from_list.append(layer_from)
                    dld_to_list.append(layer_to)
                    dld_mid_list.append(layer_mid)
        add_dld_direct = 'ver'
        if profile_ymax < 622.3 and profile_xmax < 546.1:
            add_dld_direct = 'hor'
        # --坐标定义
        if add_dld_direct == 'ver':
            #ldi_x1 = sr_xmin - 4.25
            #ldi_x2 = sr_xmax + 4.25
            # 周涌通知距成型1mm即可 20221205 by lyh
            ldi_x1 = sr_xmin - 3
            ldi_x2 = sr_xmax + 3          
            ldi_y1 = sr_ymin - 2
            ldi_y2 = sr_ymax + 2
            # dld的防呆不能再往上移，right_fd_v的范围是-5~+2,需要修正为-7~0,故要加6mm修正
            ldi_y3 = sr_ymax + 5 + (right_fd_v - 6)

            # -- 优化左下角四靶坐标

            lenth = 4.0 * len(dld_list)
            rect_sym = 'rect4000x%s' % (lenth * 1000)
            rect_x_ll, rect_y_ll = ldi_x1, ldi_y1 + lenth * 0.5 - 2

            # area_xmin = profile_xmin + 4
            # area_xmax = sr_xmin - 1
            area_xmin = ldi_x1 - 2
            area_xmax = ldi_x1 + 2
            area_ymin = sr_ymin - 1
            area_ymax = sr_ymin + sr_width / 3
            rect_x_ll, rect_y_ll = self.optimize_coord(rect_sym, x=rect_x_ll, y=rect_y_ll, area_xmin=area_xmin,
                                                       area_xmax=area_xmax, area_ymin=area_ymin, area_ymax=area_ymax,
                                                       four_corner2ll="yes")
            ldi_x1 = rect_x_ll
            ldi_y1 = rect_y_ll - lenth * 0.5 + 2

            ldi_x2 = profile_xmax - ldi_x1
            ldi_y2 = profile_ymax - ldi_y1
            ldi_y3 = ldi_y2 + (right_fd_v - 6)
            rect_x_ur, rect_y_ur = ldi_x2, ldi_y3 - lenth * 0.5 + 2
            area_ymin = sr_ymin + sr_width * 2.0 / 3
            area_ymax = rect_y_ur + lenth * 0.5
            rect_x_ur, rect_y_ur = self.optimize_coord(rect_sym, x=rect_x_ur, y=rect_y_ur,
                                                       area_ymin=area_ymin, area_ymax=area_ymax)
            # ldi_y3 = rect_y_ur + lenth * 0.5 - 2
            ldi_y3 = profile_ymax - (rect_y_ll + lenth * 0.5)
        else:
            # === 短边DLD优先加在50-80mm的范围内
            # === V2.00 DLD在短边时使用左下角防呆 错开板角位置孔，错开外层CCD ===
            ldi_x1 = 40
            ldi_x2 = profile_xmax - 40

            ldi_y1 = sr_ymin - 4.25
            ldi_y2 = sr_ymax + 4.25
            # 周涌通知距成型1mm即可 20221205 by lyh
            ldi_y1 = sr_ymin - 3
            ldi_y2 = sr_ymax + 3           

            lenth = 3.75 * len(dld_list)
            rect_sym = 'rect%sx4000' % (lenth * 1000)
            rect_x_ll, rect_y_ll = ldi_x1 + lenth * 0.5 - 2, ldi_y1

            area_xmin = ldi_x1 - 2
            # area_xmax = sr_xmin + sr_lenth / 3
            area_xmax = profile_xmin + (profile_xmax - rout_x) * 0.5 + 92
            
            area_ymax = ldi_y1 + 2
            area_ymin = 10
            rect_x_ll, rect_y_ll = self.optimize_coord(rect_sym, x=rect_x_ll, y=rect_y_ll, area_xmin=area_xmin,
                                                       area_xmax=area_xmax, area_ymin=area_ymin, area_ymax=area_ymax,
                                                       four_corner2ll="yes")
            ldi_x1 = rect_x_ll - lenth * 0.5 + 2
            ldi_y1 = rect_y_ll

            ldi_x2 = profile_xmax - ldi_x1
            ldi_y2 = profile_ymax - ldi_y1
            ldi_x3 = ldi_x2 + right_fd_h
            rect_x_ur, rect_y_ur = ldi_x3 - lenth * 0.5 + 2, ldi_y2
            area_xmin = sr_xmin + sr_lenth * 2.0 / 3
            area_xmax = rect_x_ur + lenth * 0.5
            
            rect_x_ur, rect_y_ur = self.optimize_coord(rect_sym, x=rect_x_ur, y=rect_y_ur,
                                                       area_xmin=area_xmin, area_xmax=area_xmax)
            # ldi_x3 = rect_x_ur + lenth * 0.5 - 2
            ldi_x3 = profile_xmax - (rect_x_ll + lenth * 0.5)

        for index, dld_layer in enumerate(dld_list):
            dld_from = dld_from_list[index]
            dld_to = dld_to_list[index]
            dld_mid = dld_mid_list[index]
            info_this = self.GEN.DO_INFO('-t layer -e %s/panel/%s -d EXISTS' % (self.JOB, dld_layer))
            if info_this['gEXISTS'] == "yes":
                self.GEN.CLEAR_LAYER()
                self.GEN.AFFECTED_LAYER(dld_layer, 'yes')
                self.GEN.SEL_DELETE()
            else:
                self.GEN.CREATE_LAYER(dld_layer, ins_lay=through_drl, add_type='drill', location='before')

            # --归集坐标列表
            if add_dld_direct == 'ver':
                ldi_x_list = [ldi_x1, ldi_x2, ldi_x1, ldi_x2]
                ldi_y_list = [ldi_y1, ldi_y1, ldi_y2, ldi_y3]
            else:
                ldi_x_list = [ldi_x1, ldi_x2, ldi_x1, ldi_x3]
                ldi_y_list = [ldi_y1, ldi_y1, ldi_y2, ldi_y2]
            info[dld_layer] = self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='r500')

            if dld_mid:
                if isinstance(dld_mid, list):
                    for new_dld_mid in dld_mid:
                        if new_dld_mid not in info:
                            info[new_dld_mid] = self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s4000',
                                                                 polarity='negative')
                        else:
                            info[new_dld_mid].extend(self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s4000',
                                                                      polarity='negative'))
                else:
                    if dld_mid not in info:
                        info[dld_mid] = self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s4000',
                                                             polarity='negative')
                    else:
                        info[dld_mid].extend(self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s4000',
                                                                  polarity='negative'))
            ##
            if dld_from not in info:
                info[dld_from] = self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='sh-ldi')
            else:
                info[dld_from].extend(self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='sh-ldi'))
            if dld_to not in info:
                info[dld_to] = self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s4000')
            else:
                info[dld_to].extend(self.convert_to_dict(x_list=ldi_x_list, y_list=ldi_y_list, symbol='s4000'))
                
            if add_dld_direct == 'ver':
                ldi_y1 = ldi_y1 + 4
                ldi_y2 = ldi_y2 - 4
                ldi_y3 = ldi_y3 + 4
            else:
                ldi_x1 = ldi_x1 + 3.75
                ldi_x2 = ldi_x2 - 3.75
                ldi_x3 = ldi_x3 + 3.75

        return info
    
    def check_only_skip_via_layer(self, drill_layer, start_index, end_index, layer_from,layer_to, layer_mid, flag):
        """http://192.168.2.120:82/zentao/story-view-6834.html 20240528 by lyh
        （1）只存在L1-3 Skipvia，孔有连接L2层时，钻带使用L2层内靶对位；
        （2）只存在L1-3 Skipvia，孔不连接L2层时，钻带使用L3层内靶对位；
        （3）只存在L1-3 Skipvia，孔有部分连接L2层时，部分不连接L2层时，钻带使用L2层内靶对位；
        （4）同时存在L1-3 Skipvia和L1-2镭射，统一选用L2层内靶对位。
        （5）其余存在L1-N设计时，输出提示评审。
        以上情况可归结为 改一种情况即可 就是跟中间层导通的情况 加在N-1层上  其他的情况都不变"""
        jobname = self.JOB
        stepname = "edit"
        job = gClasses.Job(jobname)
        step = gClasses.Step(job, stepname)
        step.open()
        step.COM("units,type=mm")
        check_mid_layers = []
        if isinstance(layer_mid, (list, tuple)):
            check_mid_layers = layer_mid
        else:
            check_mid_layers = [layer_mid]
            
        for layer in check_mid_layers:
            step.removeLayer(layer+"_tmp")
            step.copyLayer(job.name, step.name, layer, layer+"_tmp")
            step.clearAll()
            step.affect(layer+"_tmp")
            step.contourize()
            
            step.refSelectFilter(drill_layer)
            if step.featureSelected():
                step.removeLayer(layer+"_tmp")
                
                step = gClasses.Step(job, "panel")
                step.open()                
                return "l{0}".format(end_index - flag), "l{0}".format(end_index), layer_mid, "yes"
            
            step.removeLayer(layer+"_tmp")
            
        step = gClasses.Step(job, "panel")
        step.open()
        
        return layer_from,layer_to, layer_mid,"no"          


class hdi_by_bar(DYNAMIC_SYM):
    """
    备用靶
    """
    priority = 2.1

    def __init__(self, frozen_json=None, avoidArea=None, priority=2.1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        job_signal_numbers = self.parm.job_signal_numbers
        if job_signal_numbers <= 2:
            return info
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        profile_xmin = self.parm.profile_xmin
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        lam_rout = self.parm.lam_rout
        lamination = self.parm.lamination
        fill_array = self.parm.fill_array
        assist_layer = self.parm.assist_layer
        assist_ref = self.parm.assist_ref
        left_after_margin = self.parm.left_after_margin
        # put_copper_md = 'no'
        add_first_plant = self.parm.add_first_plant
        L_margin = self.parm.L_margin
        R_margin = self.parm.R_margin
        pin_fd_h = self.parm.pin_fd_h
        burry_list = self.parm.burry_list
        flow_content = self.parm.flow_content
        yh_num = len(lamination)
        # === 选化层标靶位置化金，套开处理 ===
        sgt_lyr_symbol = None
        sgt_lyr_x = []
        sgt_lyr_y = []

        by_ll_starty = None
        by_lr_starty = None
        by_rect_x_ll = None
        # if lamination[0].BAR3Y != lamination[0].BAR4Y1:
        if lamination[0].TARGET_DESIGNREGION == "长边":
            # === 正式靶在长边 ===
            pass
        else:
            # === 备用长边标靶的坐标 ===
            by_lenth = 5.08 * len(lam_rout) + 3
            # === Symbol 可以挨着添加，不用加大0.5 不变更方法，此处rect改小 ===
            by_rect_sym = 'rect4580x%s' % (by_lenth * 1000)
            # === 考虑此值是否根据留边增加加大 ===
            if left_after_margin > 15:
                by_rect_x_ll = sr_xmin - 7.8
            else:
                by_rect_x_ll = sr_xmin - 5

            # === V2.00 备用靶起始坐标在sr_ymin上+4.5。避免与板角位置孔过近，使用此值保证距离在6.5mm以上 ===
            by_rect_y_ll = sr_ymin + 4.5 + by_lenth / 2
            # print by_rect_x_ll,by_rect_y_ll
            by_area_ymin = sr_ymin + 4.5
            by_area_ymax = profile_ymax * 0.33
            by_rect_x_ll, by_rect_y_ll = self.optimize_coord(by_rect_sym, x=by_rect_x_ll, y=by_rect_y_ll,
                                                             area_ymin=by_area_ymin, area_ymax=by_area_ymax,
                                                             four_corner2ll='yes')
            # print by_rect_x_ll,by_rect_y_ll
            by_ll_starty = by_rect_y_ll + by_lenth * 0.5 - 2.54 - 3
            by_lr_starty = by_rect_y_ll + by_lenth * 0.5 - 2.54

            info['panel_map'] = self.convert_to_dict(x_list=[by_rect_x_ll], y_list=[by_rect_y_ll],
                                                     symbol=by_rect_sym)

        tag_step = 5.08
        for index, cur_lamin in enumerate(lamination, 1):
            (lam_des, from_lyr, to_lyr) = (
                int(cur_lamin.PROCESS_NUM) - 1, str(cur_lamin.FROMLAY).lower(), str(cur_lamin.TOLAY).lower())
            from_id = int(from_lyr[1:])
            from_next = from_id + 1
            to_id = int(to_lyr[1:])
            to_pre = to_id - 1
            # === 备用标靶坐标 ===
            hdi_tag_by1 = sr_ymin + (index + 1) * tag_step
            hdi_tag_by2 = sr_ymax - (index + 1) * tag_step
            hdi_tag_by1fd = hdi_tag_by1 - 3
            hdi_tag_bx1 = sr_xmin - 5
            hdi_tag_bx2 = sr_xmax + 5
            if by_ll_starty:
                hdi_tag_by1 = by_lr_starty - (index - 1) * tag_step
                hdi_tag_by1fd = hdi_tag_by1 - 3
                hdi_tag_by2 = profile_ymax - hdi_tag_by1
                hdi_tag_bx1 = by_rect_x_ll
                hdi_tag_bx2 = profile_xmax - hdi_tag_bx1
            # if cur_lamin.BAR3Y and cur_lamin.BAR3Y != cur_lamin.BAR4Y1:
            if lamination[0].TARGET_DESIGNREGION == "长边":
                hdi_tag_by1 = (profile_ymax - cur_lamin.BAR3Y) * 0.5
                hdi_tag_by2 = hdi_tag_by1 + cur_lamin.BAR3Y
                hdi_tag_by1fd = hdi_tag_by1 - 1
                hdi_tag_bx1 = sr_xmin + (yh_num - index + 1) * tag_step
                hdi_tag_bx2 = sr_xmax - (yh_num - index + 1) * tag_step
                # === 短边加备用靶，避开板角四孔
                if L_margin > 20 and R_margin > 20 and add_first_plant == 'no':
                    # pass
                    pin_x_min = profile_xmin + (profile_xmax - rout_x) * 0.5 + 5.5 + len(burry_list) * 5.5
                    if abs(hdi_tag_bx1 - pin_x_min) < 6.5:
                        hdi_tag_bx1 = pin_x_min + 6.5
                        hdi_tag_bx2 = profile_xmax - hdi_tag_bx1
                else:
                    hdi_tag_bx1 = sr_xmin + (yh_num - index + 1) * tag_step + 7.323 + pin_fd_h + 5.5
                    hdi_tag_bx2 = sr_xmax - (yh_num - index + 1) * tag_step - 7.323 - pin_fd_h - 5.5
                    hdi_tag_by1fd = hdi_tag_by1 - 3

            for fill_hash in fill_array:
                sym3 = None
                info_list = []
                layer_name = str(fill_hash.layer_name)
                if re.search('fz',layer_name):
                    continue
                add_mirror = None
                layer_id = int(layer_name.strip('-fz').split('-')[0][1:])
                
                # http://192.168.2.120:82/zentao/story-view-5815.html
                # 为省金，外层的靶标都取消添加20230724 by lyh
                # if layer_id in (1, job_signal_numbers):
                if layer_name in ('l1', 'l' + str(int(self.JOB[4:6]))):
                    continue
                
                if layer_id >= from_id or layer_id <= to_id:
                    if layer_name == from_lyr:
                        by1 = 'sh-dwtop'
                        byj = 'sh-dwtop'
                        if flow_content == '一次铜' or index != len(lamination):
                            tag_polarity = "negative"
                        else:
                            tag_polarity = "positive"
                        if index == len(lamination):
                            by1 = 'hdi-dwtop-tb'
                            byj = 'hdi-dwtop-tb'
                            tag_polarity = "positive"
                            if flow_content == '二次铜':
                                tag_polarity = "negative"
                    elif layer_name == to_lyr:
                        by1 = 'sh-dwbot'
                        byj = 'sh-dwbot'
                        if flow_content == '一次铜' or index != len(lamination):
                            tag_polarity = "negative"
                        else:
                            tag_polarity = "positive"
                        if index == len(lamination):
                            by1 = 'hdi-dwbot-tb'
                            byj = 'hdi-dwbot-tb'
                            tag_polarity = "positive"
                            add_mirror = 'yes'
                            if flow_content == '二次铜':
                                tag_polarity = "negative"

                    elif layer_id == from_next or layer_id == to_pre or index == 1:
                        # --当前压合前一层,l2->l3,l9->l8
                        tail_num = index
                        if tail_num == len(lamination):
                            tail_num = 't'
                        by1 = 'hdi1-by%s' % tail_num
                        byj = 'hdi1-byj%s' % tail_num
                        tag_polarity = "positive"
                    else:
                        # --内一其它层别用s5080掏空,多次压合时,第一次压合不掏空并添加hdi-ba1
                        by1 = "s5080"
                        byj = "s5080"
                        tag_polarity = "negative"
                else:
                    # --超出本次压合范围的层别不加任何symbol,比如二压为b38,则l1,l2,l9,l10不加symbol
                    by1 = None
                    byj = None
                    tag_polarity = "positive"

                by4_x_list = [hdi_tag_bx2, hdi_tag_bx2, hdi_tag_bx1, hdi_tag_bx1]
                by4_y_list = [hdi_tag_by1, hdi_tag_by2, hdi_tag_by2, hdi_tag_by1fd]
                by4_sym_list = [by1, byj, by1, by1]
                
                # http://192.168.2.120:82/zentao/story-view-6102.html
                # 按此需求更改此symbol 全部掏开                   
                if by1 == "sh-dwtop" or by1 == "sh-dwbot":
                    by4_sym_list = [by1 + "2023", byj + "2023", by1 + "2023", by1 + "2023"]
                    
                info_list.extend(self.convert_to_dict(x_list=by4_x_list, y_list=by4_y_list, symbol="s5082",
                                                      polarity="negative",mirror=add_mirror))                
                if from_id <= layer_id <= to_id:                    
                    info_list.extend(self.convert_to_dict(x_list=by4_x_list, y_list=by4_y_list, symbol=by4_sym_list,
                                                          polarity=tag_polarity,mirror=add_mirror))                    
                    
                if fill_hash.layer_mode == "inn" or layer_name in ["l{0}".format(job_signal_numbers/2), "l{0}".format(job_signal_numbers/2+1)]:
                    # 翟鸣通知 一压靶标位置都要加框线 http://192.168.2.120:82/zentao/story-view-6885.html 20240520 by lyh
                    info_list.extend(
                        self.convert_to_dict(x_list=by4_x_list, y_list=by4_y_list, symbol=["donut_s5100x4650",
                                                                                           "donut_s5100x4650",
                                                                                           "donut_s5100x4650",
                                                                                           "donut_s5100x4650",],
                                             polarity="positive"))
                   
                if index == 1:
                    info[layer_name] = info_list
                else:
                    info[layer_name].extend(info_list)
            if index == len(lamination):
                sgt_lyr_x = by4_x_list
                sgt_lyr_y = by4_y_list
                sgt_lyr_symbol = 's4736'
        info['选化'] = self.convert_to_dict(x_list=sgt_lyr_x, y_list=sgt_lyr_y, symbol=sgt_lyr_symbol,
                                          polarity='negative')

        return info


class hdi_v5_symbol(DYNAMIC_SYM):
    """
    五代靶
    """
    priority = 2

    def __init__(self, frozen_json=None, avoidArea=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        v5laser = self.parm.v5laser
        if v5laser == '否':
            return info
        # === 使用实际层别数 ===
        job_signal_numbers = self.parm.true_signal_numbers
        half_layer_num = int(job_signal_numbers * 0.5)
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_width = self.parm.sr_width
        sr_lenth = self.parm.sr_lenth
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        profile_xmin = self.parm.profile_xmin
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        laser_config = self.parm.laser_config
        layer_cu_info = self.parm.layer_cu_info
        stackup_pp_foil_info = self.parm.stackup_pp_foil_info
        mrp_info = get_inplan_mrp_info(self.JOB.upper(), condtion="1=1")

        cut_x = (profile_xmax - rout_x) * 0.5
        cut_y = (profile_ymax - rout_y) * 0.5

        v5list_o = self.parm.v5list_o
        right_fd_v = self.parm.right_fd_v
        # --dld层别定义
        blind_list = self.parm.blind_list
        if len(blind_list) == 0:
            # --没有盲孔不需要添加
            return info

        blind_burry_list = self.parm.blind_burry_list
        blind_burry_start = self.parm.blind_burry_start
        blind_burry_end = self.parm.blind_burry_end
        v5_from_list = []
        v5_mid_list = []
        v5_to_list = []
        laser_list = []
        
        # 1to3 1to4等取最深层加五代靶 其余层次不加
        new_blind_burry_list = []
        new_blind_burry_start = []
        new_blind_burry_end = []
        for i, (lay, start, end) in enumerate(zip(blind_burry_list, blind_burry_start, blind_burry_end)):
            if lay in blind_list:                
                if start in new_blind_burry_start:
                    new_index = new_blind_burry_start.index(start)
                    new_end = new_blind_burry_end[new_index]
                    if abs(int(start[1:]) - int(end[1:])) > abs(int(new_end[1:])-int(start[1:])):
                        new_blind_burry_list[new_index] = lay
                        new_blind_burry_start[new_index] = start
                        new_blind_burry_end[new_index] = end
                else:
                    new_blind_burry_list.append(lay)
                    new_blind_burry_start.append(start)
                    new_blind_burry_end.append(end)

        blind_burry_list = new_blind_burry_list
        blind_burry_start = new_blind_burry_start
        blind_burry_end = new_blind_burry_end
        
        # === 蚀刻引线层别的标靶，如果外层有对位pad，在蚀刻引线层加r0对位点 ===
        etch_top_symbol = None
        etch_top_x = []
        etch_top_y = []
        etch_bot_symbol = None
        etch_bot_x = []
        etch_bot_y = []

        for i, layer in enumerate(blind_burry_list):
            if layer in blind_list:
                index_start = int(blind_burry_start[i][1:])
                index_end = int(blind_burry_end[i][1:])
                try:                    
                    laser_depth = [i.laser_depth_mil for i in laser_config if i.layer_name == layer][0]
                except:
                    msg_box = msgBox()
                    msg_box.critical(self, '错误', '料号:%s 资料内镭射层名%s 在inplan未匹配到，请反馈MI同事检查！' % (self.JOB, layer), QMessageBox.Ok)
                    sys.exit()
                                       
                # index_end = int(blind_burry_end[i][1:])
                
                # http://192.168.2.120:82/zentao/story-view-6298.html
                # 五代靶按介质厚度判断1to2或1to3只适用于任意介 其他情况都按1to2 20240108 by lyh
                # 取消任意介的判断 按新的工艺要求来判断 20240311 by lyh
                # 新工艺需求 http://192.168.2.120:82/zentao/story-view-6566.html
                # if self.parm.anylayer == "yes":
                if index_start >= half_layer_num:
                    layer_from = 'l%s' % (index_start)                    
                    is_warning = False
                    if layer_from in v5list_o :
                    
                        #if laser_depth > 12.5:
                            #warn_content = "{1}五代靶添加：当N至 N-1层的厚度[实际厚度{0}]:总厚度>12.5mil时，请提出评审，工艺根据电镀铜厚判断。"
                            #msg_dict = {'type': 'critical',
                                        #'windowTitle': '警告',
                                        #'content': warn_content.format(laser_depth, layer)}
                            #self.warn_content_list.append(warn_content.format(laser_depth, layer))
                            #self.msg_array.append(msg_dict)
                            #msg_box = msgBox()
                            #msg_box.critical(self, '错误', warn_content.format(laser_depth, layer), QMessageBox.Ok)
                            #sys.exit()
                            
                        next_n_1_layer = 'l%s' % int(index_start - abs(index_start-index_end))
                        next_n_2_layer = 'l%s' % int(index_start - abs(index_start-index_end) - 1)
                        next_laser_drill_layer = "s{0}-{1}".format(next_n_1_layer[1:], next_n_2_layer[1:])
                        if next_laser_drill_layer in blind_list:
                            try:
                                next_depth = [i.laser_depth_mil for i in laser_config if i.layer_name == next_laser_drill_layer][0]
                            except:
                                msg_box = msgBox()
                                msg_box.critical(self, '错误', '料号:%s 资料内镭射层名%s 在inplan未匹配到，请反馈MI同事检查！' % (self.JOB, next_laser_drill_layer), QMessageBox.Ok)
                                sys.exit()
                            layer_copper_thick = [i.CAL_CU_THK for i in layer_cu_info if i.LAYER_NAME == next_n_1_layer][0]
                            # if laser_depth < 2.5 and next_depth + layer_copper_thick > 10:
                            if laser_depth + next_depth + layer_copper_thick > 10:
                                # warn_content = "{1}五代靶添加：当N至 N-2层的厚度[实际厚度{0}]:总厚度>10mil时，请提出评审，工艺根据电镀铜厚判断。"
                                # msg_dict = {'type': 'critical',
                                #             'windowTitle': '警告',
                                #             'content': warn_content.format(laser_depth+next_depth + layer_copper_thick, layer, laser_depth)}
                                # self.warn_content_list.append(warn_content.format(laser_depth+next_depth + layer_copper_thick, layer, laser_depth))
                                # self.msg_array.append(msg_dict)
                                is_warning = True
                                #msg_box = msgBox()
                                #msg_box.critical(self, '错误', warn_content.format(laser_depth+next_depth + layer_copper_thick, layer, laser_depth), QMessageBox.Ok)
                                # sys.exit()
                        else:
                            layer_copper_thick = [i.CAL_CU_THK for i in layer_cu_info if i.LAYER_NAME == next_n_1_layer]
                            if layer_copper_thick:                                
                                pp_thick = 0                            
                                #for dic_info in mrp_info:
                                    #if dic_info["TOLAY"] is None:
                                        #continue                                    
                                    ## job.PAUSE(str([layer, dic_info["TOLAY"],next_n_1_layer] ))
                                    #if dic_info["TOLAY"].lower() == next_n_1_layer:
                                seg_index = 0
                                array_seg_index = []
                                start_seg_index = 0
                                for stackup_info in sorted(stackup_pp_foil_info, key=lambda x: x.STACKUP_SEG_INDEX * -1):
                                    # job.PAUSE(str([layer, dic_info["TOLAY"].lower(), next_n_1_layer, stackup_info.PROC_MRP_NAME, dic_info["MRPNAME"], stackup_info.SEGMENT_TYPE_T]))
                                    mrp_name = stackup_info.PROC_MRP_NAME
                                    mrp_fromlay = ""
                                    mrp_tolay = ""
                                    for dic_info in mrp_info:
                                        if dic_info["FROMLAY"] is None:
                                            continue
                                        
                                        if mrp_name == dic_info["MRPNAME"]:                                            
                                            mrp_fromlay = dic_info["FROMLAY"].lower()
                                            mrp_tolay = dic_info["TOLAY"].lower()
                                            
                                    if mrp_tolay == next_n_1_layer:
                                        start_seg_index = stackup_info.STACKUP_SEG_INDEX
                                        
                                    # 例如DA8606GB807B1 s6-4的情况
                                    if mrp_fromlay == next_n_1_layer:
                                        start_seg_index = stackup_info.STACKUP_SEG_INDEX
                                        continue
                                    
                                    if seg_index and next_n_2_layer in [mrp_fromlay, mrp_tolay] :
                                        break
                                    
                                    # if stackup_info.PROC_MRP_NAME == dic_info["MRPNAME"]:
                                    if start_seg_index:                                        
                                        if stackup_info.SEGMENT_TYPE_T == "Isolator":
                                            pp_thick += stackup_info.CUST_REQ_THICKNESS_
                                            seg_index = stackup_info.STACKUP_SEG_INDEX
                                            array_seg_index.append(seg_index)
                                        if stackup_info.SEGMENT_TYPE_T == "Core":
                                            pp_thick += stackup_info.CUST_REQ_THICKNESS_ # - layer_copper_thick[0] * 2
                                            seg_index = stackup_info.STACKUP_SEG_INDEX
                                            array_seg_index.append(seg_index)
                                        # break
                                    if seg_index and pp_thick == 0 and array_seg_index[0] - stackup_info.STACKUP_SEG_INDEX == 1:
                                        # 例如D51910PBBE7A1 s9-8
                                        if "-lyh" in self.JOB:
                                            job.PAUSE(str([layer, pp_thick, stackup_info.SEGMENT_TYPE_T, seg_index, stackup_info.STACKUP_SEG_INDEX] ))                                                
                                        if stackup_info.SEGMENT_TYPE_T == "Core":
                                            pp_thick = stackup_info.CUST_REQ_THICKNESS_
                                            
                                        if pp_thick:
                                            break                                                    
                                            
                                    if seg_index and array_seg_index[0] - stackup_info.STACKUP_SEG_INDEX > 2:
                                        break

                                    if seg_index and next_n_2_layer in [mrp_fromlay, mrp_tolay] :
                                        break

                                # break
                                        
                                if "-lyh" in self.JOB:
                                    job.PAUSE(str([layer, layer_copper_thick[0], pp_thick, next_n_1_layer, next_n_2_layer, laser_depth]))
                                    
                                if not pp_thick:
                                    warn_content = "{0}层五代靶添加，获取pp厚度异常，请反馈程序工程师检查！"
                                    msg_dict = {'type': 'critical',
                                                'windowTitle': '警告',
                                                'content': warn_content.format(layer)}
                                    self.warn_content_list.append(warn_content.format(layer))
                                    self.msg_array.append(msg_dict)                                      


                                # if laser_depth < 2.5 and pp_thick + layer_copper_thick[0] > 10:
                                if laser_depth + pp_thick + layer_copper_thick[0] > 10:
                                    # warn_content = "{1}五代靶添加：当N至 N-2层的厚度[实际厚度{0}]:总厚度>10mil时，请提出评审，工艺根据电镀铜厚判断。"
                                    # msg_dict = {'type': 'critical',
                                    #             'windowTitle': '警告',
                                    #             'content': warn_content.format(laser_depth+pp_thick + layer_copper_thick[0], layer, laser_depth)}
                                    # self.warn_content_list.append(warn_content.format(laser_depth+pp_thick + layer_copper_thick[0], layer, laser_depth))
                                    # self.msg_array.append(msg_dict)
                                    is_warning = True
                                    #msg_box = msgBox()
                                    #msg_box.critical(self, '错误', warn_content.format(laser_depth+pp_thick + layer_copper_thick[0], layer, laser_depth), QMessageBox.Ok)
                                    # sys.exit()                            
                        
                    # if laser_depth < 2.5:
                    if not is_warning:                        
                        layer_mid = 'l%s' % int(index_start - 1)
                        layer_to = 'l%s' % int(index_start - 2)
                    else:
                        layer_mid = None
                        layer_to = 'l%s' % int(index_start - 1)
                else:
                    layer_from = 'l%s' % (index_start)                    
                    is_warning = False
                    if layer_from in v5list_o :
                        
                        #if laser_depth > 12.5:
                            #warn_content = "{1}五代靶添加：当N至 N-1层的厚度[实际厚度{0}]:总厚度>12.5mil时，请提出评审，工艺根据电镀铜厚判断。"
                            #msg_dict = {'type': 'critical',
                                        #'windowTitle': '警告',
                                        #'content': warn_content.format(laser_depth, layer)}
                            #self.warn_content_list.append(warn_content.format(laser_depth, layer))
                            #self.msg_array.append(msg_dict)
                            #msg_box = msgBox()
                            #msg_box.critical(self, '错误', warn_content.format(laser_depth, layer), QMessageBox.Ok)
                            #sys.exit()                         
                    
                        next_n_1_layer = 'l%s' % int(index_start + abs(index_start-index_end))
                        next_n_2_layer = 'l%s' % int(index_start + abs(index_start-index_end) + 1)
                        next_laser_drill_layer = "s{0}-{1}".format(next_n_1_layer[1:], next_n_2_layer[1:])
                        if next_laser_drill_layer in blind_list:
                            try:
                                next_depth = [i.laser_depth_mil for i in laser_config if i.layer_name == next_laser_drill_layer][0]
                            except:
                                msg_box = msgBox()
                                msg_box.critical(self, '错误', '料号:%s 资料内镭射层名%s 在inplan未匹配到，请反馈MI同事检查！' % (self.JOB, next_laser_drill_layer), QMessageBox.Ok)
                                sys.exit()
                            layer_copper_thick = [i.CAL_CU_THK for i in layer_cu_info if i.LAYER_NAME == next_n_1_layer][0]
                            # if laser_depth < 2.5 and next_depth + layer_copper_thick > 10:
                            if laser_depth + next_depth + layer_copper_thick > 10:
                                warn_content = "{1}五代靶添加：当N至 N-2层的厚度[实际厚度{0}]:总厚度>10mil时，请提出评审，工艺根据电镀铜厚判断。"
                                msg_dict = {'type': 'critical',
                                            'windowTitle': '警告',
                                            'content': warn_content.format(laser_depth + next_depth + layer_copper_thick, layer, laser_depth)}
                                # self.warn_content_list.append(warn_content.format(laser_depth + next_depth + layer_copper_thick, layer, laser_depth))
                                # self.msg_array.append(msg_dict)
                                is_warning = True
                                #msg_box = msgBox()
                                #msg_box.critical(self, '错误', warn_content.format(laser_depth + next_depth + layer_copper_thick, layer, laser_depth), QMessageBox.Ok)
                                # sys.exit()
                        else:
                            layer_copper_thick = [i.CAL_CU_THK for i in layer_cu_info if i.LAYER_NAME == next_n_1_layer]
                            if layer_copper_thick:                                
                                pp_thick = 0                            
                                #for dic_info in mrp_info:
                                    #if dic_info["FROMLAY"] is None:
                                        #continue
                                    ## job.PAUSE(str([layer, dic_info["TOLAY"],next_n_1_layer] ))
                                    #if dic_info["FROMLAY"].lower() == next_n_1_layer:
                                seg_index = 0
                                array_seg_index = []
                                start_seg_index = 0
                                for stackup_info in sorted(stackup_pp_foil_info, key=lambda x: x.STACKUP_SEG_INDEX ):
                                    # job.PAUSE(str([layer, dic_info["TOLAY"].lower(), next_n_1_layer, stackup_info.PROC_MRP_NAME, dic_info["MRPNAME"], stackup_info.SEGMENT_TYPE_T]))
                                    mrp_name = stackup_info.PROC_MRP_NAME
                                    mrp_fromlay = ""
                                    mrp_tolay = ""
                                    for dic_info in mrp_info:
                                        if dic_info["FROMLAY"] is None:
                                            continue
                                        
                                        if mrp_name == dic_info["MRPNAME"]:                                            
                                            mrp_fromlay = dic_info["FROMLAY"].lower()
                                            mrp_tolay = dic_info["TOLAY"].lower()
                                            
                                    if mrp_fromlay == next_n_1_layer:
                                        start_seg_index = stackup_info.STACKUP_SEG_INDEX
                                        
                                    # 例如DA8606GB807B1 s1-3的情况
                                    if mrp_tolay == next_n_1_layer:
                                        start_seg_index = stackup_info.STACKUP_SEG_INDEX
                                        continue
                                    
                                    if seg_index and next_n_2_layer in [mrp_fromlay, mrp_tolay] :
                                        break
                                            
                                    # if stackup_info.PROC_MRP_NAME == dic_info["MRPNAME"]:
                                    if start_seg_index:                                        
                                        if stackup_info.SEGMENT_TYPE_T == "Isolator":
                                            pp_thick += stackup_info.CUST_REQ_THICKNESS_
                                            seg_index = stackup_info.STACKUP_SEG_INDEX
                                            array_seg_index.append(seg_index)
                                        if stackup_info.SEGMENT_TYPE_T == "Core":
                                            # pp_thick = dic_info["YHTHICK"] * 39.37 # - layer_copper_thick[0] * 2
                                            pp_thick += stackup_info.CUST_REQ_THICKNESS_
                                            seg_index = stackup_info.STACKUP_SEG_INDEX
                                            array_seg_index.append(seg_index)
                                        # break
                                    if seg_index and pp_thick == 0 and stackup_info.STACKUP_SEG_INDEX - array_seg_index[0] == 1:
                                        # 例如D51910PBBE7A1 s2-3的情况
                                        if "-lyh" in self.JOB:
                                            job.PAUSE(str([layer, pp_thick, stackup_info.SEGMENT_TYPE_T, seg_index, stackup_info.STACKUP_SEG_INDEX] ))
                                        if stackup_info.SEGMENT_TYPE_T == "Core":
                                            pp_thick = stackup_info.CUST_REQ_THICKNESS_
                                        
                                        if pp_thick:
                                            break
                                            
                                    if seg_index and stackup_info.STACKUP_SEG_INDEX - array_seg_index[0] > 2:
                                        break
                                        # break
                                    
                                    if seg_index and next_n_2_layer in [mrp_fromlay, mrp_tolay] :
                                        break
                                                                            
                                if "-lyh" in self.JOB:
                                    job.PAUSE(str([layer, layer_copper_thick[0], pp_thick, next_n_1_layer, next_n_2_layer, laser_depth]))
                                    
                                if not pp_thick:
                                    warn_content = "{0}层五代靶添加，获取pp厚度异常，请反馈程序工程师检查！"
                                    msg_dict = {'type': 'critical',
                                                'windowTitle': '警告',
                                                'content': warn_content.format(layer)}
                                    self.warn_content_list.append(warn_content.format(layer))
                                    self.msg_array.append(msg_dict)                                      


                                # if laser_depth < 2.5 and  pp_thick + layer_copper_thick[0] > 10:
                                if laser_depth +  pp_thick + layer_copper_thick[0] > 10:
                                    warn_content = "{1}五代靶添加：当N至 N-2层的厚度[实际厚度{0}]:总厚度>10mil时，请提出评审，工艺根据电镀铜厚判断。"
                                    msg_dict = {'type': 'critical',
                                                'windowTitle': '警告',
                                                'content': warn_content.format(laser_depth +  pp_thick + layer_copper_thick[0], layer, laser_depth)}
                                    # self.warn_content_list.append(warn_content.format(laser_depth +  pp_thick + layer_copper_thick[0], layer, laser_depth))
                                    # self.msg_array.append(msg_dict)
                                    is_warning = True
                                    #msg_box = msgBox()
                                    #msg_box.critical(self, '错误', warn_content.format(laser_depth +  pp_thick + layer_copper_thick[0], layer, laser_depth), QMessageBox.Ok)
                                    # sys.exit()                                
                    
                    # if laser_depth < 2.5:
                    #if "-lyh" in self.JOB:
                        #job.PAUSE(str([layer, is_warning]))
                        

                    if not is_warning:                        
                        layer_mid = 'l%s' % int(index_start + 1)
                        layer_to = 'l%s' % int(index_start + 2)
                    else:
                        layer_mid = None
                        layer_to = 'l%s' % int(index_start + 1)
                #else:
                    #if index_start >= half_layer_num:
                        #layer_from = 'l%s' % (index_start)
                        #layer_mid = None
                        #layer_to = 'l%s' % int(index_start - 1)
                    #else:
                        #layer_from = 'l%s' % (index_start)
                        #layer_mid = None
                        #layer_to = 'l%s' % int(index_start + 1)
                            
                if layer_from in v5list_o:
                    v5_from_list.append(layer_from)
                    v5_mid_list.append(layer_mid)
                    v5_to_list.append(layer_to)
                    laser_list.append(layer)
        # --坐标定义
        ldi5_x1 = sr_xmin - 9.8
        ldi5_x2 = sr_xmax + 9.8
        ldi5_y1 = sr_ymin + 2.54
        ldi5_y2 = sr_ymax + 2
        # 五代靶的防呆不通用往上移，right_fd_v的范围是-5~+2,需要修正为-7~0,故要加6mm修正
        ldi5_y3 = sr_ymax + 5 + (right_fd_v - 6)

        # --优化左下角四靶坐标
        lenth = 5.08 * len(laser_list)
        rect_sym = 'rect5080x%s' % (lenth * 1000)

        rect_x_ll, rect_y_ll = ldi5_x1, ldi5_y1 + lenth * 0.5 - 2.54
        area_xmin = cut_x + 2
        area_xmax = sr_xmin - 2
        area_ymin = sr_ymin + 2
        area_ymax = sr_ymin + sr_width / 3
        # print rect_x_ll, rect_y_ll,rect_sym,area_xmin,area_xmax,area_ymin,area_ymax
        # print 'before_' * 40
        rect_x_ll, rect_y_ll = self.optimize_coord(rect_sym, x=rect_x_ll, y=rect_y_ll, area_xmin=area_xmin,
                                                   area_xmax=area_xmax, area_ymin=area_ymin, area_ymax=area_ymax)

        ldi5_x1 = rect_x_ll
        ldi5_y1 = rect_y_ll - lenth / 2 + 2.54

        ldi5_x2 = profile_xmax - ldi5_x1
        ldi5_y2 = sr_ymax - 2

        rect_x_ul, rect_y_ul = ldi5_x1, ldi5_y2 - lenth * 0.5 + 2.54
        area_ymin = sr_ymin + sr_width * 2.0 / 3
        area_ymax = ldi5_y2 + lenth * 0.5
        rect_x_ul, rect_y_ul = self.optimize_coord(rect_sym, x=rect_x_ul, y=rect_y_ul,
                                                   area_ymin=area_ymin, area_ymax=area_ymax)
        ldi5_y2 = rect_y_ul + lenth / 2 - 2.54
        # === V2.03  右上角向下移，right_fd_v的范围是-5~+2,需要修正为-7~0,故要加6mm修正
        ldi5_y3 = ldi5_y2 + (right_fd_v - 6) - 3

        rect_x_ur, rect_y_ur = ldi5_x2, ldi5_y3 - lenth * 0.5 + 2.54
        # area_xmin = ldi5_x2
        # area_xmax = ldi5_x2
        area_ymin = sr_ymin + sr_width * 2.0 / 3
        area_ymax = ldi5_y3 + lenth * 0.5
        rect_x_ur, rect_y_ur = self.optimize_coord(rect_sym, x=rect_x_ur, y=rect_y_ur,
                                                   area_ymin=area_ymin, area_ymax=area_ymax)
        ldi5_y3 = rect_y_ur + lenth / 2 - 2.54
        info['panel_map'] = self.convert_to_dict(x_list=[rect_x_ll, rect_x_ul, rect_x_ur],
                                                 y_list=[rect_y_ll, rect_y_ul, rect_y_ur], symbol=rect_sym)
        for index, laser_layer in enumerate(laser_list):
            v5_from = v5_from_list[index]
            v5_mid = v5_mid_list[index]
            v5_to = v5_to_list[index]

            # --归集坐标列表
            ldi5_x_list = [ldi5_x1, ldi5_x2, ldi5_x1, ldi5_x2]
            ldi5_y_list = [ldi5_y1, ldi5_y1, ldi5_y2, ldi5_y3]

            if v5_from == 'l1':
                etch_top_x = ldi5_x_list
                etch_top_y = ldi5_y_list
                etch_top_symbol = 'r0'
            if v5_from == 'l%s' % job_signal_numbers:
                etch_bot_x = ldi5_x_list
                etch_bot_y = ldi5_y_list
                etch_bot_symbol = 'r0'
            if v5_from not in info:
                info[v5_from] = self.convert_to_dict(x_list=ldi5_x_list, y_list=ldi5_y_list, symbol='hdi-dwpad')
            else:
                info[v5_from].extend(self.convert_to_dict(x_list=ldi5_x_list, y_list=ldi5_y_list, symbol='hdi-dwpad'))
            info[v5_from].extend(self.convert_to_dict(x_list=ldi5_x_list, y_list=ldi5_y_list, symbol='r0',
                                                      attribute='.fiducial_name,text=317.reg'))
            info[laser_layer] = self.convert_to_dict(x_list=ldi5_x_list, y_list=ldi5_y_list, symbol='hdi-dwdrl')
            # info[v5_mid] = self.convert_to_dict(x_list=ldi5_x_list, y_list=ldi5_y_list,symbol='sh-ldi')

            if v5_to not in info:
                info[v5_to] = self.convert_to_dict(x_list=ldi5_x_list, y_list=ldi5_y_list, symbol='s5080')
            else:
                info[v5_to].extend(self.convert_to_dict(x_list=ldi5_x_list, y_list=ldi5_y_list, symbol='s5080'))
            if v5_mid is not None:
                if v5_mid not in info:
                    info[v5_mid] = self.convert_to_dict(x_list=ldi5_x_list, y_list=ldi5_y_list, symbol='s5080',
                                                        polarity='negative')
                else:
                    info[v5_mid].extend(
                        self.convert_to_dict(x_list=ldi5_x_list, y_list=ldi5_y_list, symbol='s5080',
                                             polarity='negative'))
            ldi5_y1 = ldi5_y1 + 5.08
            ldi5_y2 = ldi5_y2 - 5.08
            ldi5_y3 = ldi5_y3 - 5.08
        # info['蚀刻引线c'] = self.convert_to_dict(x_list=etch_top_x, y_list=etch_top_y, symbol=etch_top_symbol,
        #                                      attribute='.fiducial_name,text=317.reg')
        # info['蚀刻引线s'] = self.convert_to_dict(x_list=etch_bot_x, y_list=etch_bot_y, symbol=etch_bot_symbol,
        #                                      attribute='.fiducial_name,text=317.reg')
        #
        # info['蚀刻引线c'].extend(
        #     self.convert_to_dict(x_list=etch_top_x, y_list=etch_top_y, symbol='sh-dwtop', polarity='negative'))
        # info['蚀刻引线s'].extend(
        #     self.convert_to_dict(x_list=etch_bot_x, y_list=etch_bot_y, symbol='sh-dwbot', polarity='negative'))
        info['选化c'] = self.convert_to_dict(x_list=etch_top_x, y_list=etch_top_y, symbol='s5588', polarity='negative')
        info['选化s'] = self.convert_to_dict(x_list=etch_bot_x, y_list=etch_bot_y, symbol='s5588', polarity='negative')
        #http://192.168.2.120:82/zentao/story-view-5815.html 五代靶防焊盖油 20230724 by lyh 
        info['防焊c'] = self.convert_to_dict(x_list=etch_top_x, y_list=etch_top_y, symbol='s5588', polarity='negative')
        info['防焊s'] = self.convert_to_dict(x_list=etch_bot_x, y_list=etch_bot_y, symbol='s5588', polarity='negative')
        info['档点c'] = self.convert_to_dict(x_list=etch_top_x, y_list=etch_top_y, symbol='s5588', polarity='negative')
        info['档点s'] = self.convert_to_dict(x_list=etch_bot_x, y_list=etch_bot_y, symbol='s5588', polarity='negative')          

        return info

    def change_symbol(self):
        """
        由于镭射层别中添加的五代靶需要打散
        :return:
        :rtype:
        """
        blind_list = self.parm.blind_list
        if len(blind_list) == 0:
            # --没有盲孔不需要添加
            return True
        self.GEN.CLEAR_LAYER()

        for layer in blind_list:
            self.GEN.AFFECTED_LAYER(layer, 'yes')
        self.GEN.FILTER_RESET()
        self.GEN.COM('filter_set,filter_name=popup,update_popup=no,feat_types=pad')
        self.GEN.COM('filter_set,filter_name=popup,update_popup=no,polarity=positive')
        self.GEN.COM('filter_set,filter_name=popup,update_popup=no,include_syms=%s' % 'hdi-dwdrl')
        self.GEN.COM('filter_area_strt')
        self.GEN.COM('filter_area_end,layer=,filter_name=popup,operation=select,area_type=none,'
                     'inside_area=no,intersect_area=no')
        self.GEN.FILTER_RESET()
        count = self.GEN.GET_SELECT_COUNT()
        if count > 0:
            self.GEN.COM('sel_break')


class laser_note(STATIC_SYM):
    """
    添加镭射打码区域
    """

    def __init__(self, frozen_json=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        hdi_num = self.parm.hdi_num
        if hdi_num < 1:
            # --非HDI料号不需要添加
            return info
        true_signal_numbers = self.parm.true_signal_numbers
        half_layer_num = int(true_signal_numbers * 0.5)
        sr_ymin = self.parm.sr_ymin
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        rout_x = self.parm.rout_x

        # --层别定义
        blind_list = self.parm.blind_list
        blind_burry_list = self.parm.blind_burry_list
        blind_burry_start = self.parm.blind_burry_start
        blind_burry_end = self.parm.blind_burry_end
        note_to_top = []
        note_to_bot = []
        top_hdi_list = []
        bot_hdi_list = []
        for i, layer in enumerate(blind_burry_list):
            if layer in blind_list:
                index_start = int(blind_burry_start[i][1:])
                index_end = int(blind_burry_end[i][1:])
                if index_start <= half_layer_num:
                    layer_from = 'l%s' % index_start
                    layer_to = 'l%s' % index_end
                    top_hdi_list.append(layer)
                    note_to_top.append(layer_to)
                else:
                    layer_from = 'l%s' % index_start
                    layer_to = 'l%s' % index_end
                    bot_hdi_list.append(layer)
                    note_to_bot.append(layer_to)
        # --坐标定义
        laser_note_x1 = profile_xmax * 0.5 + 50 + 30
        laser_note_x2 = laser_note_x1 + 30
        laser_note_y = sr_ymax + 5
        laser_note_y1 = sr_ymin - 5
        laser_pad_x1 = laser_note_x1 + 15 - 0.3
        laser_pad_x2 = laser_note_x2 + 15 - 0.3
        laser_pad_y = laser_note_y + 1.25 - 0.3
        laser_pad_y1 = laser_note_y1 + 1.25 - 0.3

        laser_note_x3 = sr_xmax + 7.4
        laser_note_y2 = profile_ymax * 0.5 - 40 - 30

        laser_pad_x3 = laser_note_x3 - 1.25 + 0.3
        laser_pad_y3 = laser_note_y2 + 15 - 0.3

        tmp_check_value = (profile_xmax - rout_x) * 0.5 + rout_x - 3
        note_y3_fdyesorno = 'no'
        if laser_note_x3 > tmp_check_value:
            note_y3_fdyesorno = 'yes'

        # --有顶层镭射时,默认将打码区域加在顶层
        # --归集坐标列表
        # === 需考虑正反面的翻转
        for index, laser in enumerate(top_hdi_list):
            note_to = note_to_top[index]
            if index != 0:
                # --每一次往上移3mm
                laser_note_y = laser_note_y + 3
                laser_pad_y = laser_pad_y + 3
                laser_note_y1 = laser_note_y1 - 3
                laser_pad_y1 = laser_pad_y1 - 3
                if note_y3_fdyesorno == 'yes':
                    if index % 2 != 0:
                        laser_note_y2 = profile_ymax * 0.5 - 40 - 30 - 15
                        laser_pad_y3 = laser_note_y2 + 15 - 0.3
                    else:
                        laser_note_y2 = profile_ymax * 0.5 - 40 - 30
                        laser_pad_y3 = laser_note_y2 + 15 - 0.3
                else:
                    laser_note_x3 = laser_note_x3 + 3
                    laser_pad_x3 = laser_pad_x3 + 3
                    if laser_note_x3 > tmp_check_value:
                        laser_note_x3 = sr_xmax + 7.4
                        laser_pad_x3 = laser_note_x3 - 1.25 + 0.3
            note_x_list = [laser_note_x1, laser_note_x2, laser_note_x1, laser_note_x3]
            note_y_list = [laser_note_y, laser_note_y, laser_note_y1, laser_note_y2]
            laser_pad_x_list = [laser_pad_x1, laser_pad_x2, laser_pad_x1, laser_pad_x3]
            laser_pad_y_list = [laser_pad_y, laser_pad_y, laser_pad_y1, laser_pad_y3]
            angle_list = [0, 0, 0, 270]
            info[laser] = self.convert_to_dict(x_list=note_x_list, y_list=note_y_list, symbol='r501')
            info[note_to] = self.convert_to_dict(x_list=laser_pad_x_list, y_list=laser_pad_y_list,
                                                 symbol='rect30000x2500', angle=angle_list)

        laser_note_x1 = profile_xmax * 0.5 + 50 + 30;

        laser_note_x2 = laser_note_x1 + 30
        laser_note_y = sr_ymax + 5
        laser_note_y1 = sr_ymin - 5
        laser_pad_x1 = laser_note_x1 + 15 - 0.3
        laser_pad_x2 = laser_note_x2 + 15 - 0.3
        # laser_pad_bx1 = laser_note_x1 - 15 + 0.3
        # laser_pad_bx2 = laser_note_x2 - 15 + 0.3
        laser_pad_y = laser_note_y + 1.25 - 0.3
        laser_pad_y1 = laser_note_y1 + 1.25 - 0.3

        # my $laser_note_x3 = $sr_xmax + 5;
        laser_note_x3 = sr_xmax + 7.4  # song change 20190617
        laser_note_y2 = profile_ymax * 0.5 - 40 - 30 + 29.4
        laser_pad_x3 = laser_note_x3 + 1.25 - 0.3
        laser_pad_y3 = laser_note_y2 + 15 - 0.3 - 29.4

        laser_note_by = laser_note_y + 1.9
        laser_note_by1 = laser_note_y1 + 1.9
        laser_note_bx3 = laser_note_x3 + 1.9

        # === 留边窄时发现x3位置会超出锣边，增加判断，当x方向超出锣边时使用Y方向添加，使用两坐标往复防呆
        tmp_check_value = (profile_xmax - rout_x) * 0.5 + rout_x - 3
        note_y3_fdyesorno = 'no'
        if laser_note_x3 > tmp_check_value:
            note_y3_fdyesorno = 'yes'

        # === 顶层底层均需添加
        for index, laser in enumerate(bot_hdi_list[::-1]):
            note_to = note_to_bot[::-1][index]
            if index != 0:
                # --每一次往上移3mm
                laser_note_by = laser_note_by + 3
                laser_pad_y = laser_pad_y + 3
                laser_note_by1 = laser_note_by1 - 3
                laser_pad_y1 = laser_pad_y1 - 3
                if note_y3_fdyesorno == 'yes':
                    if index % 2 != 0:
                        laser_note_y2 = profile_ymax * 0.5 - 40 - 30 - 15 + 29.4
                        laser_pad_y3 = laser_note_y2 + 15 - 0.3 - 29.4
                    else:
                        laser_note_y2 = profile_ymax * 0.5 - 40 - 30 + 29.4
                        laser_pad_y3 = laser_note_y2 + 15 - 0.3 - 29.4
                else:
                    laser_note_bx3 = laser_note_bx3 + 3
                    laser_pad_x3 = laser_pad_x3 + 3
                    if laser_note_x3 > tmp_check_value:
                        laser_note_bx3 = sr_xmax + 7.4
                        laser_pad_x3 = laser_note_bx3 - 1.25 + 0.3
            note_x_list = [laser_note_x1, laser_note_x2, laser_note_x1, laser_note_bx3]
            note_y_list = [laser_note_by, laser_note_by, laser_note_by1, laser_note_y2]
            laser_pad_x_list = [laser_pad_x1, laser_pad_x2, laser_pad_x1, laser_pad_x3]
            laser_pad_y_list = [laser_pad_y, laser_pad_y, laser_pad_y1, laser_pad_y3]
            angle_list = [0, 0, 0, 270]
            info[laser] = self.convert_to_dict(x_list=note_x_list, y_list=note_y_list, symbol='r501')
            info[note_to] = self.convert_to_dict(x_list=laser_pad_x_list, y_list=laser_pad_y_list,
                                                 symbol='rect30000x2500', angle=angle_list)
        return info


class cycle_symbol(STATIC_SYM):
    """
    添加周期
    """

    def __init__(self, frozen_json=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        # job_signal_numbers = self.parm.job_signal_numbers
        sr_xmax = self.parm.sr_xmax
        profile_ymax = self.parm.profile_ymax
        cycle_in_silk = self.parm.cycle_in_silk
        cycle_in_sm = self.parm.cycle_in_sm
        cycle_in_signal = self.parm.cycle_in_signal
        put_copper_out = self.parm.put_copper_out

        oil_type_x = sr_xmax + 3.5 + 3.65
        oil_type_y1 = profile_ymax * 0.5 + 15
        oil_type_y2 = profile_ymax * 0.5 + 25
        oil_pad_x = oil_type_x - 1
        oil_pad_y = oil_type_y1 + 10
        cycle_x = sr_xmax + 3.5
        cycle_y = profile_ymax * 0.5 + 105 + 28 + 12

        if cycle_in_silk:
            # --文字周期
            info['文字c'] = self.convert_to_dict(x_list=[cycle_x], y_list=[cycle_y], symbol='zq-wz', angle=270,
                                               mirror='no')
            info['文字s'] = self.convert_to_dict(x_list=[cycle_x], y_list=[cycle_y], symbol='zq-wz', angle=90,
                                               mirror='yes')

        if cycle_in_sm:
            # --防焊周期
            info['防焊c'] = self.convert_to_dict(x_list=[cycle_x], y_list=[cycle_y], symbol='zq-fh', angle=270,
                                               mirror='no')
            info['防焊s'] = self.convert_to_dict(x_list=[cycle_x], y_list=[cycle_y], symbol='zq-fh', angle=90,
                                               mirror='yes')

        if cycle_in_signal:
            # --蚀刻周期
            if put_copper_out == "yes":
                zq_pol = 'positive'
            else:
                zq_pol = 'negative'
            info['外层c'] = self.convert_to_dict(x_list=[cycle_x], y_list=[cycle_y], symbol='sh-yskzq', angle=270,
                                               mirror='no', polarity=zq_pol)
            info['外层s'] = self.convert_to_dict(x_list=[cycle_x], y_list=[cycle_y], symbol='sh-yskzq', angle=90,
                                               mirror='yes', polarity=zq_pol)
        return info


class hdi_slice(DYNAMIC_SYM):
    """
    HDI右上角切片孔
    """
    priority = 6

    def __init__(self, frozen_json=None, avoidArea=None, priority=6):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        # job_signal_numbers = self.parm.job_signal_numbers
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        profile_ymax = self.parm.profile_ymax
        profile_xmax = self.parm.profile_xmax
        left_after_margin = self.parm.left_after_margin
        top_after_margin = self.parm.top_after_margin
        split_pth = self.parm.split_pth
        split_via = self.parm.split_via
        right_fd_h = self.parm.right_fd_h
        put_copper_out = self.parm.put_copper_out
        # 添加切片孔.
        info = {}
        if split_pth != 'Null' and split_via != 'Null':
            pass
        else:
            # 均有定义时才继续，否则不添加切片孔
            return info
        add_qiepian_special = "no"
        width = 5
        lenth = 7 * 0.508 + split_pth * 3 + split_via * 3 + 3.175 * 2 + 5.0 - 3.175
        rect_sym = 'rect%sx%s' % (lenth * 1000, width * 1000)
        sgt_rect = 'rect%sx%s' % (lenth * 1000 + 508, width * 1000 + 508)
        qie_pian_hole_y = sr_ymax + 4.5
        qie_pian_hole_x = sr_xmax - 65

        rect_x = qie_pian_hole_x
        rect_y = qie_pian_hole_y
        # --左上角坐标优化
        area_ymax = profile_ymax - 4
        area_ymin = sr_ymax + 3
        area_xmin = profile_xmax * 0.5
        area_xmax = sr_xmax
        qie_pian_hole_x, qie_pian_hole_y = self.optimize_coord(rect_sym, x=rect_x, y=rect_y, area_xmin=area_xmin,
                                                               area_xmax=area_xmax, area_ymin=area_ymin,
                                                               area_ymax=area_ymax)
        # info = {}
        info['panel_map'] = self.convert_to_dict(x_list=[qie_pian_hole_x], y_list=[qie_pian_hole_y], symbol=rect_sym)

        start_x = qie_pian_hole_x - lenth * 0.5 + 2.5
        fir_x_list = [start_x + (3.175 + split_via) * 0.5 + 0.508,
                      start_x + (3.175 + split_via) * 0.5 + split_via + 0.508 * 2,
                      start_x + (3.175 + split_via) * 0.5 + split_via * 2 + 0.508 * 3]
        fir_end_x = start_x + (3.175 + split_via) * 0.5 + split_via * 2 + 0.508 * 3
        sec_x_list = [fir_end_x + (split_via + split_pth) * 0.5 + 0.508,
                      fir_end_x + (split_via + split_pth) * 0.5 + split_pth + 0.508 * 2,
                      fir_end_x + (split_via + split_pth) * 0.5 + split_pth * 2 + 0.508 * 3]
        end_x = qie_pian_hole_x + lenth * 0.5 - 2.5
        all_list_x = [start_x] + fir_x_list + sec_x_list + [end_x]
        start_sym = 'r%s' % (3.175 * 1000)
        first_sym = 'r%s' % (split_via * 1000)
        sec_sym = 'r%s' % (split_pth * 1000)        
        symbol_list = [start_sym, first_sym, first_sym, first_sym, sec_sym, sec_sym, sec_sym, start_sym]
        
        # 翟鸣通知 切片孔原大块铜皮转负性，加8 Mil的pad 20230726 by lyh
        signal_start_sym = 'r%s' % (3.175 * 1000 + 254)
        signal_first_sym = 'r%s' % (split_via * 1000 + 254)
        signal_sec_sym = 'r%s' % (split_pth * 1000 + 254)        
        signal_symbol_list = [signal_start_sym, signal_first_sym, signal_first_sym,
                              signal_first_sym, signal_sec_sym, signal_sec_sym,
                              signal_sec_sym, signal_start_sym]
        # 挡点
        md_start_sym = 'r%s' % (3.175 * 1000 + 508)
        md_first_sym = 'r%s' % (split_via * 1000 + 508)
        md_sec_sym = 'r%s' % (split_pth * 1000 + 508)        
        md_symbol_list = [md_start_sym, md_first_sym, md_first_sym,
                              md_first_sym, md_sec_sym, md_sec_sym,
                              md_sec_sym, md_start_sym]        
        
        info_list = []
        info_list.extend(self.convert_to_dict(x_list=all_list_x, y_list=[qie_pian_hole_y] * 8, symbol=symbol_list))
        info['通孔'] = info_list
        # if put_copper_out == "no":
        # 切片孔位置都铺铜 20230317 by lyh
        info['外层'] = self.convert_to_dict(x_list=[qie_pian_hole_x], y_list=[qie_pian_hole_y],
                                              symbol=rect_sym, polarity='negative')        
        info['外层'].extend(self.convert_to_dict(x_list=all_list_x, y_list=[qie_pian_hole_y] * 8,
                                                   symbol=signal_symbol_list))
        
        info['选化'] = self.convert_to_dict(x_list=[qie_pian_hole_x], y_list=[qie_pian_hole_y],
                                          symbol=sgt_rect, polarity='negative')
        
        info['档点'] = self.convert_to_dict(x_list=all_list_x, y_list=[qie_pian_hole_y] * 8,
                                                   symbol=md_symbol_list)       
        return info


class layer_notes(DYNAMIC_SYM):
    """
    添加短边顶部的层别标识
    """
    priority = 6

    def __init__(self, frozen_json=None, avoidArea=None, priority=6):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        sr_xmin = self.parm.sr_xmin
        sr_ymax = self.parm.sr_ymax
        profile_xmax = self.parm.profile_xmax
        profile_ymax = self.parm.profile_ymax
        sr_lenth = self.parm.sr_lenth
        top_after_margin = self.parm.top_after_margin
        job_signal_numbers = self.parm.job_signal_numbers
        loop_number = job_signal_numbers - 2
        len_origin_value = profile_xmax * 0.5 - 53 - loop_number * 5
        global layer_notes_x
        global layer_notes_y
        # --原始坐标定义如下
        if top_after_margin < 7:
            layer_notes_y = profile_ymax - 6.0357475
        else:
            layer_notes_y = sr_ymax + 3.2
        if job_signal_numbers == 2:
            # --双面板不加层别标识
            return info

        # --矩形长宽区域定义
        lenth = 5 * loop_number + 0.3 * 2
        width = 6.35
        rect_sym = 'rect%sx%s' % (lenth * 1000, width * 1000)

        # --获取长边左侧移动优化后的坐标
        layer_notes_xc = len_origin_value - 0.3 + lenth / 2
        layer_notes_yc = layer_notes_y - 0.3 + width / 2
        # --可移动范围定义
        area_xmin = layer_notes_xc - lenth / 2
        # --不能超过profile中心，否则same_key会错误
        area_xmax = sr_xmin + sr_lenth / 2 - 0.5
        area_ymin = sr_ymax
        area_ymax = profile_ymax + 0.5
        layer_notes_xc, layer_notes_yc = self.optimize_coord(rect_sym, x=layer_notes_xc, y=layer_notes_yc,
                                                             area_xmin=area_xmin, area_xmax=area_xmax,
                                                             area_ymin=area_ymin, area_ymax=area_ymax)
        # --坐标优化后,重置实际坐标
        layer_notes_x = layer_notes_xc - lenth / 2 + 0.3
        layer_notes_y = layer_notes_yc - width / 2 + 0.3
        info['panel_map'] = self.convert_to_dict(x_list=[layer_notes_xc], y_list=[layer_notes_yc], symbol=rect_sym)
        return info

    def change_symbol(self):
        """
        因为symbol中心不对称,所以get_sym_info只是在panel_map中添加了矩形，此函数真正添加symbol
        :return:
        :rtype:
        """
        info = {}
        fill_array = self.parm.fill_array
        out_signal_array = self.parm.out_signal_array
        # === TOOD 当存在辅助层别时，此项是否变更 ===
        job_signal_numbers = self.parm.job_signal_numbers
        loop_number = job_signal_numbers - 2
        layer_notes_y1 = layer_notes_y + 0.95
        for index, fill_hash in enumerate(fill_array):
            info_list = []
            layer_name = fill_hash.layer_name
            layer_side = fill_hash.layer_side
            if not layer_name in out_signal_array:
                # --考虑辅助层别
                layer_id = int(layer_name.strip('-fz').split('-')[0][1:])
                if layer_side == '正':
                    mirror = 'no'
                    if layer_id > 9:
                        layer_notes_x1 = layer_notes_x + (index - 1) * 5 + 0.45
                    else:
                        layer_notes_x1 = layer_notes_x + (index - 1) * 5 + 0.85
                else:
                    mirror = 'yes'
                    if layer_id > 9:
                        layer_notes_x1 = layer_notes_x + (index - 1) * 5 + 4.25
                    else:
                        layer_notes_x1 = layer_notes_x + (index - 1) * 5 + 3.55
                if layer_id > 9:
                    x_size = 2.286
                else:
                    x_size = 4.064
                # --内层包括辅助层添加sh_lengnew
                info_list.extend(self.convert_to_dict(x_list=[layer_notes_x], y_list=[layer_notes_y],
                                                      symbol='sh_lengnew', nx=loop_number, dx=5000))
                # --添加文字标示
                info_list.extend(self.convert_to_dict(x_list=[layer_notes_x1], y_list=[layer_notes_y1], text=layer_id,
                                                      x_size=x_size, y_size=3.81, w_factor=2, mirror=mirror))
                # --字典增加键值对,键为当前层别名,值为info_list
                info[layer_name] = info_list
        self.add_symbol(info)
        
class add_md_holes(DYNAMIC_SYM):
    """
    添加钻铆钉气泡孔
    """
    priority = 0.5

    def __init__(self, frozen_json=None, avoidArea=None, priority=0.5):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        hdi_jie = self.parm.hdi_jie
        
        info = {}
        stepname = "panel"
        step = gClasses.Step(job, stepname)
        step.open()             
        
        f_xmin, f_ymin, f_xmax, f_ymax = get_profile_limits(step)
        sr_xmin, sr_ymin, sr_xmax, sr_ymax = get_sr_limits(step)        
        
        arraylist = []
        mrp_info = get_inplan_mrp_info(job.name)
        
        core_layers = []
        mrp_info2 = get_inplan_mrp_info(job.name, "1=1")
        for dic_info in sorted(mrp_info2, key=lambda x: x["PROCESS_NUM"]):
            if dic_info["FROMLAY"] is not None and dic_info["TOLAY"] is not None:                
                from_lay = dic_info["FROMLAY"].lower()
                to_lay = dic_info["TOLAY"].lower()
                process_num = dic_info["PROCESS_NUM"]
                if process_num == 1:
                    core_layers += [from_lay, to_lay]

        pp3_layer = self.parm.pp3_layer
        if len(core_layers) <= 2 and not pp3_layer:
            return {}
        
        for dic_info in sorted(mrp_info, key=lambda x: x["PROCESS_NUM"]):            
            from_lay = dic_info["FROMLAY"].lower()
            to_lay = dic_info["TOLAY"].lower()
            mrp_name = dic_info["MRPNAME"]
            rout_x = dic_info["PNLROUTX"] * 25.4
            rout_y = dic_info["PNLROUTY"] * 25.4
            lb_x = (f_xmax - rout_x) * 0.5
            lb_y = (f_ymax - rout_y) * 0.5        
            
            press_num = dic_info["PROCESS_NUM"] - 1
            
            mai_hole_size = 1.5
            #http://192.168.2.120:82/zentao/story-view-6860.html 20240726
            #  NV系列四阶以上压合次数多，埋孔防爆孔位置容易缺胶。
            if self.JOB[1:4] in ["a86", "d10"] and hdi_jie > 4:
                mai_hole_size = 0.5               
            
            mai_drill_layer = "b{0}-{1}".format(from_lay[1:], to_lay[1:])
            if not mai_drill_layers and "-" not in mrp_name:
                for layer in ["cdc", "cds", "drl"]:
                    if step.isLayer(layer):
                        mai_drill_layer = layer
                        mai_hole_size = 1.5
                        break
                        
            if step.isLayer(mai_drill_layer):
                index = signalLayers.index(from_lay)
                check_layer = signalLayers[index+1]
                
                num = 1
                while  check_layer not in core_layers:
                    check_layer = signalLayers[index+1+num]
                    if num > len(signalLayers) *0.5:
                        break
                    num += 1
                
                step.clearAll()
                step.affect(check_layer)
                step.resetFilter()
                
                step.selectSymbol("sh-mdk-t;sh-mdk-b;hdi1-mdk-t;hdi1-mdk-b", 1, 1)
                if not step.featureSelected():
                    # showMessageInfo(u"{0}层未发现铆钉孔symbol:sh-mdk-t;sh-mdk-b,请检查！".format(check_layer))
                    warn_content = u"{0}层未发现铆钉孔symbol:sh-mdk-t;sh-mdk-b,请手动添加铆钉孔！".format(check_layer)
                    msg_dict = {'type': 'critical',
                                'windowTitle': '警告',
                                'content': warn_content}
                    self.warn_content_list.append(warn_content)
                    self.msg_array.append(msg_dict)
                    continue
            
                layer_cmd = gClasses.Layer(step, check_layer)
                feat_out = layer_cmd.featSelOut(units="mm")["pads"]
                
                all_x = [obj.x for obj in feat_out]
                all_y = [obj.y for obj in feat_out]        
                
                for obj in feat_out:
                    hole_info = (obj.x, obj.y, 4, mai_drill_layer)
                    if hole_info not in arraylist:
                        arraylist.append(hole_info)
                
                    if obj.y < sr_ymin:
                        hole_info1 = (obj.x, obj.y + 6, mai_hole_size, mai_drill_layer)
                        hole_info2 = (obj.x - 2.5, obj.y + 6, mai_hole_size, mai_drill_layer)
                        hole_info3 = (obj.x + 2.5, obj.y + 6, mai_hole_size, mai_drill_layer)
                        if "qc7006gh051c1" in job.name:
                            # 翟鸣通知 此型号短边往外加
                            hole_info1 = (obj.x, obj.y - 6, 1.5, mai_drill_layer)
                            hole_info2 = (obj.x - 2.5, obj.y - 6, 1.5, mai_drill_layer)
                            hole_info3 = (obj.x + 2.5, obj.y - 6, 1.5, mai_drill_layer)                        
                        for info in [hole_info1, hole_info2, hole_info3]:
                            if info not in arraylist:
                                arraylist.append(info)
                    
                    if obj.y > sr_ymax:
                        hole_info1 = (obj.x, obj.y - 6, mai_hole_size, mai_drill_layer)
                        hole_info2 = (obj.x - 2.5, obj.y - 6, mai_hole_size, mai_drill_layer)
                        hole_info3 = (obj.x + 2.5, obj.y - 6, mai_hole_size, mai_drill_layer)
                        if "qc7006gh051c1" in job.name:
                            # 翟鸣通知 此型号短边往外加
                            hole_info1 = (obj.x, obj.y + 6, 1.5, mai_drill_layer)
                            hole_info2 = (obj.x - 2.5, obj.y + 6, 1.5, mai_drill_layer)
                            hole_info3 = (obj.x + 2.5, obj.y + 6, 1.5, mai_drill_layer)                         
                        for info in [hole_info1, hole_info2, hole_info3]:
                            if info not in arraylist:
                                arraylist.append(info)            
        
                    if obj.x < sr_xmin:
                        hole_info1 = (obj.x + 6, obj.y, mai_hole_size, mai_drill_layer)
                        hole_info2 = (obj.x + 6, obj.y - 2.5, mai_hole_size, mai_drill_layer)
                        hole_info3 = (obj.x + 6, obj.y + 2.5, mai_hole_size, mai_drill_layer)
                        for info in [hole_info1, hole_info2, hole_info3]:
                            if info not in arraylist:
                                arraylist.append(info)         
        
                    if obj.x > sr_xmax:
                        hole_info1 = (obj.x - 6, obj.y, mai_hole_size, mai_drill_layer)
                        hole_info2 = (obj.x - 6, obj.y - 2.5, mai_hole_size, mai_drill_layer)
                        hole_info3 = (obj.x - 6, obj.y + 2.5, mai_hole_size, mai_drill_layer)
                        for info in [hole_info1, hole_info2, hole_info3]:
                            if info not in arraylist:
                                arraylist.append(info)
                                
                if arraylist:
                    break        
        
        for dic_info in sorted(mrp_info, key=lambda x: x["PROCESS_NUM"]):
            from_lay = dic_info["FROMLAY"].lower()
            to_lay = dic_info["TOLAY"].lower()
            mrp_name = dic_info["MRPNAME"]
            rout_x = dic_info["PNLROUTX"] * 25.4
            rout_y = dic_info["PNLROUTY"] * 25.4
            lb_x = (f_xmax - rout_x) * 0.5
            lb_y = (f_ymax - rout_y) * 0.5
            if "-" not in mrp_name:
                for x, y, size, drill_layer in arraylist:
                    
                    if y < sr_ymin:
                        if abs(y - sr_ymin) < 3 + size * 0.5:
                            continue
                        
                    if y > sr_ymax:
                        if abs(y - sr_ymax) < 3 + size * 0.5:
                            continue
                    
                    if x < sr_xmin:
                        if abs(x - sr_xmin) < 3 + size * 0.5:
                            continue
                    
                    if x > sr_xmax:
                        if abs(x - sr_xmax) < 3 + size * 0.5:
                            continue
                        
                    step.clearAll()
                    step.affect(drill_layer)
                    step.addAttr(".string,text=mdk-hole", valType="")
                    if drill_layer in ["cdc", "cds", "drl"]:
                        if size == 0.5:
                            step.addPad(x, y, "r{0}".format(1.5*1000+500), attributes="yes")
                        else:
                            step.addPad(x, y, "r{0}".format(size*1000+500), attributes="yes")
                    else:
                        step.addPad(x, y, "r{0}".format(size*1000), attributes="yes")
                    
                    if drill_layer in mai_drill_layers:                
                        if y < sr_ymin:
                            if y < lb_y:
                                continue
                            
                        if y > sr_ymax:
                            if y > f_ymax - lb_y:
                                continue
                        
                        if x < sr_xmin:
                            if x < lb_x:
                                continue
                        
                        if x > sr_xmax:
                            if x > f_xmax - lb_x:
                                continue
                            
                        for layer in ["cdc", "cds", "drl"]:
                            if step.isLayer(layer):
                                step.clearAll()
                                step.affect(layer)
                                step.addAttr(".string,text=mdk-hole", valType="")
                                if size == 0.5:
                                    step.addPad(x, y, "r{0}".format(1.5*1000+500), attributes="yes")
                                else:
                                    step.addPad(x, y, "r{0}".format(size*1000+500), attributes="yes")
                                break
                        
                    for md_layer in ["md1", "md2"]:
                        if step.isLayer(md_layer):
                            step.clearAll()
                            step.affect(md_layer)
                            if size == 0.5:                                
                                step.addPad(x, y, "r{0}".format(2508), attributes="yes")
                            else:
                                step.addPad(x, y, "r{0}".format(size*1000+500+508), attributes="yes")
        step.clearAll()
        
        return {}

class add_four_lengnew(DYNAMIC_SYM):
    """
    右下角板角层别标识
    """
    priority = 7

    def __init__(self, frozen_json=None, avoidArea=None, priority=7):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        core_count = self.parm.core_count
        # is_winding_board = self.parm.is_winding_board
        job_signal_numbers = self.parm.job_signal_numbers
        if job_signal_numbers <= 2:
            # --双面板不用加
            return info
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        rout_y = self.parm.rout_y
        rout_x = self.parm.rout_x
        gm_array = self.parm.gm_array

        sec_gm_starty = gm_array[len(gm_array) - 2].gm_starty
        sec_gm_x = gm_array[len(gm_array) - 2].gm_endx

        global rect_x_LR
        global rect_y_LR

        rout_dis_x = (panel_x - rout_x) / 2
        rout_dis_y = (panel_y - rout_y) / 2
        rect_sym = 'rect5800x6500'
        lenth, width = 5.8, 6.5
        conner_nun_x_LR = sec_gm_x - 5.3

        rect_x_LR = conner_nun_x_LR
        rect_y_LR = sec_gm_starty + width / 2 + 2

        # --右下角可移动范围定义
        area_ymin = sec_gm_starty
        area_ymax = rect_y_LR + width / 2 + 20
        # area_xmin = rect_x_LR - lenth / 2 - 0.5
        # --不能超过profile

        # === TODO 此处使用除最外层外的最大干膜计算
        # area_xmax = sec_gm_x
        rect_x_LR, rect_y_LR = self.optimize_coord(rect_sym, x=rect_x_LR, y=rect_y_LR, area_ymin=area_ymin,
                                                   area_ymax=area_ymax, move_other=True, same_key='xmax',
                                                   other_key='ymax')

        # --坐标优化后,重置实际坐标
        rect_x_list = [rect_x_LR]
        rect_y_list = [rect_y_LR]
        # info = {}
        info = {'panel_map': self.convert_to_dict(x_list=rect_x_list, y_list=rect_y_list, symbol=rect_sym,
                                                  polarity='positive')}
        return info

    def change_symbol(self):
        """
        因为symbol中心不对称,所以get_sym_info只是在panel_map中添加了矩形，此函数真正添加symbol
        :return:
        :rtype:
        """
        info = {}
        job_signal_numbers = self.parm.job_signal_numbers
        if job_signal_numbers <= 2:
            # --双面板不用加
            return
        core_count = self.parm.core_count
        # is_winding_board = self.parm.is_winding_board
        fill_array = self.parm.fill_array
        out_signal_array = self.parm.out_signal_array

        conner_nun_x_LR = rect_x_LR - 2.5
        conner_nun_y_LR = rect_y_LR - 5.7357475 / 2

        conner_world_x_LR = conner_nun_x_LR + 1
        conner_world_y_LR = conner_nun_y_LR + 1

        # if core_count < 2 or not is_winding_board:
        # --两张core以上才加，线圈板才加
        if job_signal_numbers > 2:
            # --只加右下角
            pad_x_list = [conner_nun_x_LR]
            pad_y_list = [conner_nun_y_LR]
            text_y_list = [conner_world_y_LR]
            angle_list = [0]

        for index, fill_hash in enumerate(fill_array):
            info_list = []
            layer_name = fill_hash.layer_name
            layer_side = fill_hash.layer_side
            if not layer_name in out_signal_array:
                info_list.extend(
                    self.convert_to_dict(x_list=pad_x_list, y_list=pad_y_list, symbol='sh_lengnew', angle=angle_list))
                # --考虑辅助层别
                layer_id = int(layer_name.strip('-fz').split('-')[0][1:])
                if layer_side == '正':
                    if layer_id > 9:
                        word_x_LR = conner_world_x_LR - 0.5
                        x_size = 2.286
                    else:
                        word_x_LR = conner_world_x_LR
                        x_size = 4.064
                    # --非线圈板只加右下角,但是奇偶都要加文字
                    text_x_list = [word_x_LR]
                    info_list.extend(self.convert_to_dict(x_list=text_x_list, y_list=text_y_list, text=layer_id,
                                                          x_size=x_size, y_size=3.81, w_factor=2, angle=angle_list))
                else:
                    # --非线圈板只加右下角,但是奇偶都要加文字
                    # if len(pad_x_list) == 1:
                    if layer_id > 9:
                        word_x_LR = conner_world_x_LR + 3.5
                        x_size = 2.286
                    else:
                        word_x_LR = conner_world_x_LR + 3
                        x_size = 4.064
                    if len(pad_x_list) == 1:
                        # --非线圈板只加右下角,但是奇偶都要加文字,线圈板bot面不加
                        text_x_list = [word_x_LR]
                        info_list.extend(self.convert_to_dict(x_list=text_x_list, y_list=text_y_list, text=layer_id,
                                                              x_size=x_size, y_size=3.81, w_factor=2,
                                                              angle=angle_list,
                                                              mirror='yes'))
                # --字典增加键值对,键为当前层别名,值为info_list
                info[layer_name] = info_list
        self.add_symbol(info)


class ldi_stamp(DYNAMIC_SYM):
    """
    板边添加hdi_orbldi_stamp
    """
    priority = 8

    def __init__(self, frozen_json=None, avoidArea=None, priority=8):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        # sh_site = self.parm.sh_site
        # if sh_site != '胜宏六厂':
        #     # --仅六处板边添加hdi_orbldi_stamp
        #     return info
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        sr_ymin = self.parm.sr_ymin
        add_number_y = self.parm.add_number_y
        panel_y = self.parm.panel_y
        top_after_margin = self.parm.top_after_margin
        panel_case = self.parm.panel_case
        flow_content = self.parm.flow_content
        # if panel_case == 'case2':
        #     ldi_stamp_x_org = sr_xmin + 60.96 + 53.35 + 15
        # else:
        #     ldi_stamp_x_org = sr_xmin + 60.96 + 53.35 + 4
        ldi_stamp_x_org = sr_xmax - 60.96 - 53.35 - 4

        # === 认为上下留边一致
        ldi_stamp_y_org = sr_ymin - 10.54 + 0.026 + 4.5
        add_gm_y1,add_gm_y2 = self.get_gm_cor()
        if top_after_margin < 9.4:
            ldi_stamp_y_org = sr_ymin - 4.7
        elif top_after_margin < 14.4:
            minus_margin = (top_after_margin - 9.4) * 0.5
            ldi_stamp_y_org = sr_ymin - minus_margin - 4.7
        elif top_after_margin < 21:
            ldi_stamp_y_org = sr_ymin - 10
        else:
            # 20200427 更改此值上移3mm，由18mm—>15mm http://192.168.2.120:82/zentao/story-view-1178.html
            ldi_stamp_y_org = sr_ymin - 15

        if ldi_stamp_y_org - add_gm_y1 < 7.5:
            ldi_stamp_y_org = add_gm_y1 + 7.5
        # 20231215 距离板内至少1mm http://192.168.2.120:82/zentao/story-view-6269.html ynh
        if sr_ymin - ldi_stamp_y_org < 3.7:
            ldi_stamp_y_org = sr_ymin - 3.7
        sr_lenth = self.parm.sr_lenth
        # 厂内要求追溯码由8码改成13码，只改暗码 symbol 由hdi_orbldi_stamp 变成hdi_orbldi_stamp_1 20230714 by lyh
        # http://192.168.2.120:82/zentao/story-view-5781.html
        sym = 'hdi_orbldi_stamp_1'
        angle_top = 0
        angle_bot = 0
        lenth, width = self.get_sym_LIMITS(sym)
        # --可移动范围定义
        # area_xmin = ldi_stamp_x_org - lenth / 2
        area_xmax = ldi_stamp_x_org - lenth / 2
        # --最多可以平移到左侧与profile中心平齐
        # area_xmax = sr_xmin + sr_lenth / 2 - 0.5 + lenth
        area_xmin = sr_xmax - sr_lenth / 2 + 0.5 - lenth
        # --获取长边左侧移动优化后的坐标
        ldi_stamp_x, ldi_stamp_y = self.optimize_coord(sym, x=ldi_stamp_x_org, y=ldi_stamp_y_org, area_xmin=area_xmin,
                                                       area_xmax=area_xmax)
        # if ldi_stamp_x == ldi_stamp_x_org and ldi_stamp_y == ldi_stamp_y_org:
        #     # --坐标与优化前相比没有变化,继续放到长边右侧再优化
        #     # --优化后放在rj_dw对位槽正下方
        #     panel_y_inch = float(panel_y) * 0.03937
        #     rj_dw_y3 = (panel_y_inch * 0.5 - add_number_y) * 25.4
        #     rm_dw_sym_y5 = rj_dw_y3 - 76.4
        #     ldi_stamp_y_org = rm_dw_sym_y5 - 12 - lenth/2
        #     ldi_stamp_x_org = sr_xmax + 10.54 - 0.026 - 4.5
        #     # --可移动范围定义
        #     area_ymin = sr_ymin + 0.5 + lenth/2
        #     area_ymax = ldi_stamp_y_org + lenth/2
        #     angle_top = 270
        #     angle_bot = 90
        #     # --获取长边左侧移动优化后的坐标
        #     ldi_stamp_x, ldi_stamp_y = self.optimize_coord(sym, x=ldi_stamp_x_org, y=ldi_stamp_y_org,
        #                                                    area_ymin=area_ymin, area_ymax=area_ymax)
        info = {}
        info['内层c'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol=sym, angle=angle_top)
        info['内层s'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol=sym, mirror='yes',
                                           angle=angle_bot)
        # === 二次铜时不添加ldi stamp
        if flow_content == '一次铜':
            info['外层c'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol=sym, angle=angle_top)
            info['外层s'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol=sym, mirror='yes',
                                               angle=angle_bot)
        info['防焊c'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol=sym, polarity='negative',
                                           angle=angle_top)
        info['防焊s'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol=sym, polarity='negative',
                                           mirror='yes', angle=angle_bot)

        info['选化'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol='rect49016.92x6377.94',
                                          polarity='negative',
                                          mirror='yes', angle=angle_top)
        #
        # info['防焊'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol='rect49016.92x6377.94', polarity='negative')
        # info['档点'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol='rect49016.92x6377.94', polarity='negative')

        # # === Song 2021.03.24 ===
        # info['防焊c'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol='rect49016.92x6377.94', polarity='negative', angle=angle_top)
        # info['防焊s'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol='rect49016.92x6377.94', polarity='negative', mirror='yes', angle=angle_bot)
        #
        # info['档点c'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol='rect49016.92x6377.94', polarity='negative', angle=angle_top)
        # info['档点s'] = self.convert_to_dict(x_list=[ldi_stamp_x], y_list=[ldi_stamp_y], symbol='rect49016.92x6377.94', polarity='negative', mirror='yes', angle=angle_bot)
        return info

    def get_gm_cor(self):
        lamination = self.parm.lamination
        yh_num = len(lamination)
        gm_array = self.parm.gm_array
        # ===  cut_y 待转化为最外层干膜尺寸
        add_gm_y1 = max([i.gm_starty for i in gm_array])
        add_gm_y2 = min([i.gm_endy for i in gm_array ])
        return add_gm_y1, add_gm_y2


class same_circle(DYNAMIC_SYM):
    """
    同心圆
    """
    priority = 2

    def __init__(self, frozen_json=None, avoidArea=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_negative_size(self):
        """
        获取同心圆净空圆环大小
        :return:
        :rtype:
        """
        negative_size = 1000
        fill_array = self.parm.fill_array
        out_signal_array = self.parm.out_signal_array
        for index, fill_hash in enumerate(fill_array):
            layer_name = fill_hash.layer_name
            copper_thick = fill_hash.copper_thick
            if not layer_name in out_signal_array:
                compensate_value = 0
                if copper_thick == "5OZ":
                    compensate_value = 5
                elif copper_thick == "4OZ":
                    compensate_value = 4
                elif copper_thick == "3OZ":
                    compensate_value = 3
                elif copper_thick == "2OZ":
                    compensate_value = 2
                elif copper_thick == "1OZ":
                    compensate_value = 1
                else:
                    compensate_value = 0.5
                    pass
                compensate_value = compensate_value * 25.4 * 2
                if index == 1:
                    negative_size = negative_size + compensate_value + 4 * 25.4
                else:
                    negative_size = negative_size + 8 * 25.4 + compensate_value + 4 * 25.4
        negative_size = negative_size + 20 * 25.4  # 负片加大点.
        return negative_size

    def get_gm_cor(self):
        lamination = self.parm.lamination
        yh_num = len(lamination)
        gm_array = self.parm.gm_array
        # ===  cut_y 待转化为次外层的干膜尺寸，parameter.json 中是否有这个
        add_gm_y1 = max([i.gm_starty for i in gm_array if i.lamin_num != yh_num])
        add_gm_y2 = min([i.gm_endy for i in gm_array if i.lamin_num != yh_num])
        return add_gm_y1, add_gm_y2

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        sr_xmax = self.parm.sr_xmax
        sr_ymax = self.parm.sr_ymax
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        panel_x = self.parm.panel_x
        panel_y = self.parm.panel_y
        sr_lenth = self.parm.sr_lenth
        sr_width = self.parm.sr_width
        job_signal_numbers = self.parm.job_signal_numbers
        # === 双面板不加同心圆 ===
        if job_signal_numbers <= 2:
            info = {}
            return info
        negative_size = self.get_negative_size()
        sym = 'r%s' % negative_size
        # === HDI的同心圆
        circle_y1 = sr_ymin - (negative_size * 0.5 / 1000) - 3 - 6
        circle_y2 = sr_ymax + (negative_size * 0.5 / 1000) + 3 + 6

        gm_y1, gm_y2 = self.get_gm_cor()
        # 改为边缘距干膜线3mm   http://192.168.2.120:82/zentao/story-view-6269.html
        if circle_y1 - gm_y1 < 3:
            circle_y1 = gm_y1 + 3.5
        if gm_y2 - circle_y2 < 3:
            circle_y2 = gm_y2 - 3.5

        # --左下角拉伸同心圆
        circle_x_ll = sr_xmin - 0.5 + negative_size / 2000
        area_xmin = sr_xmin - 0.5
        area_xmax = sr_xmin + sr_lenth / 3
        circle_x_ll, circle_y_ll = self.optimize_coord(sym, x=circle_x_ll, y=circle_y1, area_xmin=area_xmin,
                                                       area_xmax=area_xmax)
        # --左上角拉伸同心圆
        circle_x_ul = sr_xmin - 0.5 + negative_size / 2000
        area_xmin = sr_xmin - 0.5
        area_xmax = sr_xmin + sr_lenth / 3
        circle_x_ul, circle_y_ul = self.optimize_coord(sym, x=circle_x_ul, y=circle_y2, area_xmin=area_xmin,
                                                       area_xmax=area_xmax)
        # --右下角拉伸同心圆
        circle_x_lr = sr_xmax + 0.5 - negative_size / 2000
        area_xmin = sr_xmax - sr_lenth / 3
        area_xmax = sr_xmax + 0.5
        circle_x_lr, circle_y_lr = self.optimize_coord(sym, x=circle_x_lr, y=circle_y1, area_xmin=area_xmin,
                                                       area_xmax=area_xmax)
        # --右上角拉伸同心圆
        circle_x_ur = sr_xmax + 0.5 - negative_size / 2000
        area_xmin = sr_xmax - sr_lenth / 3
        area_xmax = sr_xmax + 0.5
        circle_x_ur, circle_y_ur = self.optimize_coord(sym, x=circle_x_ur, y=circle_y2, area_xmin=area_xmin,
                                                       area_xmax=area_xmax)
        circle_x_list = [circle_x_ll, circle_x_ul, circle_x_lr, circle_x_ur]
        circle_y_list = [circle_y_ll, circle_y_ul, circle_y_lr, circle_y_ur]
        attribute = '.bit,text=scale_yes'

        ctext_x_ll = circle_x_ll - negative_size / 2000 - 0.2
        ctext_y_ll = circle_y_ll - negative_size / 2000 - 0.2
        ctext_x_ul = circle_x_ul - negative_size / 2000 - 0.2
        ctext_y_ul = circle_y_ul + negative_size / 2000 + 0.2

        ctext_x_lr = circle_x_lr + negative_size / 2000 + 0.2
        ctext_y_lr = circle_y_lr - negative_size / 2000 - 0.2
        ctext_x_ur = circle_x_ur + negative_size / 2000 + 0.2
        ctext_y_ur = circle_y_ur + negative_size / 2000 + 0.2

        scale_ctext_x_list = [ctext_x_ll, ctext_x_ul, ctext_x_lr, ctext_x_ur]
        scale_ctext_y_list = [ctext_y_ll, ctext_y_ul, ctext_y_lr, ctext_y_ur]

        # --长边.out_scale属性不拉伸同心圆
        # circle_y3 = sr_ymin + 5
        # circle_y4 = sr_ymax - 5
        # --左下角out_scale同心圆
        out_scale_x_ll = circle_x_ll + 9
        # area_xmin = sr_xmin - 1
        area_xmin = circle_x_ll
        area_xmax = sr_xmin + sr_lenth / 3
        out_scale_x_ll, out_scale_y_ll = self.optimize_coord(sym, x=out_scale_x_ll, y=circle_y1, area_xmin=area_xmin,
                                                             area_xmax=area_xmax)
        # out_scale_y_ll += 1
        # --左上角out_scale同心圆
        out_scale_x_ul = circle_x_ul + 9
        # area_xmin = sr_xmin - 1
        area_xmin = circle_x_ul
        area_xmax = sr_xmin + sr_lenth / 3

        out_scale_x_ul, out_scale_y_ul = self.optimize_coord(sym, x=out_scale_x_ul, y=circle_y2, area_xmin=area_xmin,
                                                             area_xmax=area_xmax)
        # out_scale_y_ul -= 1
        # --右下角out_scale同心圆
        out_scale_x_lr = circle_x_lr - 9
        # area_ymin = sr_ymin + 0.5 - (negative_size*0.5/1000)
        # area_ymax = sr_ymin + sr_width/3 - (negative_size*0.5/1000)
        area_xmin = sr_xmax - sr_lenth / 3
        # area_xmax = sr_xmax + 1
        area_xmax = circle_x_lr
        out_scale_x_lr, out_scale_y_lr = self.optimize_coord(sym, x=out_scale_x_lr, y=circle_y1, area_xmin=area_xmin,
                                                             area_xmax=area_xmax)
        # out_scale_y_lr += 1
        # --右上角out_scale同心圆
        out_scale_x_ur = circle_x_ur - 9
        # area_ymin = sr_ymax - sr_width/3 + (negative_size*0.5/1000)
        #         # area_ymax = sr_ymax - 0.5 + (negative_size*0.5/1000)
        area_xmin = sr_xmax - sr_lenth / 3
        # area_xmax = sr_xmax + 1
        area_xmax = circle_x_ur
        out_scale_x_ur, out_scale_y_ur = self.optimize_coord(sym, x=out_scale_x_ur, y=circle_y2, area_xmin=area_xmin,
                                                             area_xmax=area_xmax)
        # out_scale_y_ur -= 1
        out_scale_x_list = [out_scale_x_ll, out_scale_x_ul, out_scale_x_lr, out_scale_x_ur]
        out_scale_y_list = [out_scale_y_ll, out_scale_y_ul, out_scale_y_lr, out_scale_y_ur]

        # --定义M字样的坐标
        ctext_x_ll = out_scale_x_ll - negative_size / 2000 - 0.2
        ctext_y_ll = out_scale_y_ll - negative_size / 2000 - 0.2
        ctext_x_ul = out_scale_x_ul - negative_size / 2000 - 0.2
        ctext_y_ul = out_scale_y_ul + negative_size / 2000 + 0.2

        ctext_x_lr = out_scale_x_lr + negative_size / 2000 + 0.2
        ctext_y_lr = out_scale_y_lr - negative_size / 2000 - 0.2
        ctext_x_ur = out_scale_x_ur + negative_size / 2000 + 0.2
        ctext_y_ur = out_scale_y_ur + negative_size / 2000 + 0.2

        out_scale_ctext_x_list = [ctext_x_ll, ctext_x_ul, ctext_x_lr, ctext_x_ur]
        out_scale_ctext_y_list = [ctext_y_ll, ctext_y_ul, ctext_y_lr, ctext_y_ur]

        scale_ctext_sym_list = ['circle_2', 'circle_1', 'circle_3', 'circle_4']
        out_scale_ctext_sym_list = ['circle_b', 'circle_a', 'circle_c', 'circle_d']
        # --对单角symbol进行调试用
        # circle_x_list = []
        # circle_y_list = []
        # out_scale_x_list = [out_scale_x_ll]
        # out_scale_y_list = [out_scale_y_ll]
        # --生成字典信息,键是层别类型,值是字典
        info = {
            '内层': self.convert_to_dict(x_list=circle_x_list, y_list=circle_y_list, symbol=sym,
                                       attribute=attribute, polarity='negative'),
            # '辅助层': self.convert_to_dict (x_list=circle_x_list, y_list=circle_y_list, symbol=sym,
            #                              attribute=attribute, polarity='negative'),
        }
        # --不拉伸同心圆中心pad
        info['内层'].extend(self.convert_to_dict(x_list=circle_x_list, y_list=circle_y_list, symbol=sym,
                                               attribute=attribute))
        # info['辅助层'].extend (self.convert_to_dict (x_list=circle_x_list, y_list=circle_y_list, symbol=sym,
        #                                           attribute=attribute))
        # --out_scale同心圆净空区
        info['内层'].extend(self.convert_to_dict(x_list=out_scale_x_list, y_list=out_scale_y_list, symbol=sym,
                                               attribute='.out_scale', polarity='negative'))
        # info['辅助层'].extend (self.convert_to_dict (x_list=out_scale_x_list, y_list=out_scale_y_list, symbol=sym,
        #                                           attribute='.out_scale', polarity='negative'))
        # --out_scale同心圆中心pad
        info['内层'].extend(self.convert_to_dict(x_list=out_scale_x_list, y_list=out_scale_y_list, symbol=sym,
                                               attribute='.out_scale'))
        # info['辅助层'].extend (self.convert_to_dict (x_list=out_scale_x_list, y_list=out_scale_y_list, symbol=sym,
        #                                           attribute='.out_scale'))
        # --out_scale同心圆=== 字母靶 ===
        info['内层'].extend(self.convert_to_dict(x_list=out_scale_ctext_x_list, y_list=out_scale_ctext_y_list,
                                               symbol=out_scale_ctext_sym_list,
                                               attribute='.out_scale'))
        # info['辅助层'].extend (self.convert_to_dict (x_list=out_scale_ctext_x_list, y_list=out_scale_ctext_y_list,
        #                                           symbol=out_scale_ctext_sym_list,
        #                                           attribute='.out_scale'))
        # --out_scale同心圆=== 数字靶 ===
        info['内层'].extend(
            self.convert_to_dict(x_list=scale_ctext_x_list, y_list=scale_ctext_y_list, symbol=scale_ctext_sym_list))
        # info['辅助层'].extend (
        #     self.convert_to_dict (x_list=scale_ctext_x_list, y_list=scale_ctext_y_list, symbol=scale_ctext_sym_list))
        return info

    def change_symbol(self):
        """
        每个层别的OZ标示都不一样，add_symbol是统一按0OZ添加的，所以每个层别均需要change_text
        :return:
        :rtype:
        """
        negative_size = self.get_negative_size()
        sym_org = 'r%s' % negative_size
        negative_size = 1016
        fill_array = self.parm.fill_array
        out_signal_array = self.parm.out_signal_array
        inner_index = 0
        for index, fill_hash in enumerate(fill_array):
            layer_name = fill_hash.layer_name
            copper_thick = fill_hash.copper_thick
            # === V2.06 要求不能用fz
            if 'fz' in layer_name:
                continue
            if not layer_name in out_signal_array:
                inner_index += 1
                compensate_value = 0
                if copper_thick == "5OZ":
                    compensate_value = 5
                elif copper_thick == "4OZ":
                    compensate_value = 4
                elif copper_thick == "3OZ":
                    compensate_value = 3
                elif copper_thick == "2OZ":
                    compensate_value = 2
                elif copper_thick == "1OZ":
                    compensate_value = 1
                elif copper_thick == "1.5OZ":
                    # === V2.06
                    compensate_value = 1.5
                else:
                    compensate_value = 0.5
                compensate_value = compensate_value * 25.4 * 2
                if inner_index == 1:
                    # === 避免L2层起始点多补偿
                    negative_size = negative_size + compensate_value * 0.5
                    sym_new = "r%s" % negative_size
                else:
                    negative_size = negative_size + 4 * 25.4
                    negative_size1 = negative_size + 8 * 25.4 + compensate_value
                    sym_new = "donut_r%sx%s" % (negative_size1, negative_size)
                    negative_size = negative_size1
                self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
                self.GEN.FILTER_RESET()
                self.GEN.COM('filter_set,filter_name=popup,update_popup=no,feat_types=pad')
                self.GEN.COM('filter_set,filter_name=popup,update_popup=no,polarity=positive')
                self.GEN.COM('filter_set,filter_name=popup,update_popup=no,include_syms=%s' % sym_org)
                if not PRODUCT:
                    # --genesis环境or条件下过滤选属性
                    self.GEN.COM('filter_atr_logic,filter_name=popup,logic=or')
                    self.GEN.COM('filter_atr_set,filter_name=popup,condition=yes,attribute=.out_scale,text=scale_yes')
                    self.GEN.COM('filter_atr_set,filter_name=popup,condition=yes,attribute=.bit,text=scale_yes')
                else:
                    # --InCAM环境or条件下过滤选属性
                    self.GEN.COM('set_filter_attributes,filter_name=popup,exclude_attributes=no,condition=yes,'
                                 'attribute=.bit,min_int_val=0,max_int_val=0,min_float_val=0,max_float_val=0,'
                                 'option=,text=scale_yes')
                    self.GEN.COM('set_filter_attributes,filter_name=popup,exclude_attributes=no,condition=no,'
                                 'attribute=.out_scale,min_int_val=0,max_int_val=0,min_float_val=0,max_float_val=0,'
                                 'option=,text=')
                    self.GEN.COM('set_filter_and_or_logic,filter_name=popup,criteria=inc_attr,logic=or')
                self.GEN.COM('filter_area_strt')
                self.GEN.COM('filter_area_end,layer=,filter_name=popup,operation=select,area_type=none,'
                             'inside_area=no,intersect_area=no')
                self.GEN.FILTER_RESET()
                count = self.GEN.GET_SELECT_COUNT()
                if count > 0:
                    self.GEN.COM('sel_change_sym,symbol=%s,reset_angle=no' % sym_new)
                self.GEN.COM('affected_layer,name=%s,mode=single,affected=no' % layer_name)


class yh_py_pad(DYNAMIC_SYM):
    """
    压合偏移测试pad
    """
    priority = 3

    def __init__(self, frozen_json=None, avoidArea=None, priority=3):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        # 取消此模块 按下面新class yh_measure_pad: symbol类型添加 20240223 by lyh 20240430翟鸣通知导正
        return info

        core_count = self.parm.core_count
        # TODO HDI暂不设定两张core
        # if core_count < 2:
        #     # --两张core及以上才添加
        #     return info
        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        sr_lenth = self.parm.sr_lenth
        profile_ymin = self.parm.profile_ymin
        profile_ymax = self.parm.profile_ymax
        rout_y = self.parm.rout_y
        fill_array = self.parm.fill_array
        job_signal_numbers = self.parm.job_signal_numbers
        loop_number = job_signal_numbers - 2
        out_signal_array = self.parm.out_signal_array

        rect_lenth = 2.54 * loop_number + 0.2 * loop_number
        rect_width = 2.74
        rect_sym = "rect%sx%s" % (rect_lenth * 1000, rect_width * 1000)
        yh_py_x1 = sr_xmin + 5 + rect_lenth / 2
        yh_py_x2 = sr_xmax - 5 - rect_lenth / 2
        yh_py_y1 = profile_ymin + (profile_ymax - rout_y) * 0.5 + 1.54 + 3
        yh_py_y2 = profile_ymax - (profile_ymax - rout_y) * 0.5 - 1.54 - 3

        # --左下角
        yh_pyx_ll, yh_pyy_ll = yh_py_x1, yh_py_y1
        area_xmin = sr_xmin + 5
        area_xmax = sr_xmin + sr_lenth / 3
        yh_pyx_ll, yh_pyy_ll = self.optimize_coord(rect_sym, x=yh_pyx_ll, y=yh_pyy_ll, area_xmin=area_xmin,
                                                   area_xmax=area_xmax)
        # --左上角
        yh_pyx_ul, yh_pyy_ul = yh_py_x1, yh_py_y2
        area_xmin = sr_xmin + 5
        area_xmax = sr_xmin + sr_lenth / 3
        yh_pyx_ul, yh_pyy_ul = self.optimize_coord(rect_sym, x=yh_pyx_ul, y=yh_pyy_ul, area_xmin=area_xmin,
                                                   area_xmax=area_xmax)
        # --右下角
        yh_pyx_lr, yh_pyy_lr = yh_py_x2, yh_py_y1
        area_xmax = sr_xmax - 5
        area_xmin = sr_xmax - sr_lenth / 3
        yh_pyx_lr, yh_pyy_lr = self.optimize_coord(rect_sym, x=yh_pyx_lr, y=yh_pyy_lr, area_xmin=area_xmin,
                                                   area_xmax=area_xmax)
        # --右上角
        yh_pyx_ur, yh_pyy_ur = yh_py_x2, yh_py_y2
        area_xmax = sr_xmax - 5
        area_xmin = sr_xmax - sr_lenth / 3
        yh_pyx_ur, yh_pyy_ur = self.optimize_coord(rect_sym, x=yh_pyx_ur, y=yh_pyy_ur, area_xmin=area_xmin,
                                                   area_xmax=area_xmax)
        # --定义矩形中心坐标
        rect_x1 = max(yh_pyx_ll, yh_pyx_ul)
        rect_x2 = min(yh_pyx_lr, yh_pyx_ur)
        rect_y1 = min(yh_pyy_ll, yh_pyy_lr)
        rect_y2 = max(yh_pyy_ul, yh_pyy_ur)
        rect_x_list = [rect_x1, rect_x1, rect_x2, rect_x2]
        rect_y_list = [rect_y1, rect_y2, rect_y1, rect_y2]
        # --定义圆pad中心坐标
        yh_py_x1 = rect_x1 - rect_lenth / 2 + 0.1 + 2.54 / 2
        yh_py_x2 = rect_x2 - rect_lenth / 2 + 0.1 + 2.54 / 2
        yh_py_y1 = rect_y1
        yh_py_y2 = rect_y2
        yh_pyx_list = [yh_py_x1, yh_py_x1, yh_py_x2, yh_py_x2]
        yh_pyy_list = [yh_py_y1, yh_py_y2, yh_py_y1, yh_py_y2]
        # --定义属性
        attribute = '.string,text=del_after_done'
        # --外面大矩形只添加在panel_map层别,可以划定识别区
        info['panel_map'] = self.convert_to_dict(x_list=rect_x_list, y_list=rect_y_list, symbol=rect_sym,
                                                 attribute=attribute)
        # --定义标示坐标
        my_world_x1 = yh_py_x1 + 0.825
        my_world_x2 = yh_py_x2 + 0.825
        my_world_y1 = yh_py_y1 - 1.24
        my_world_y2 = yh_py_y2 - 1.24
        # --分别定义左侧和右侧圆pad坐标
        left_yhpy_x = yh_py_x1
        right_yhpy_x = yh_py_x2
        for index, fill_hash in enumerate(fill_array):
            info_list = []
            layer_name = fill_hash.layer_name
            if not layer_name in out_signal_array:
                # --考虑辅助层别
                layer_id = int(layer_name.strip('-fz').split('-')[0][1:])
                if layer_id > 9:
                    wd_content = str(layer_id)[1:]
                else:
                    wd_content = str(layer_id)
                # --内层包括辅助层添加s2540
                info_list.extend(self.convert_to_dict(x_list=yh_pyx_list, y_list=yh_pyy_list, symbol='s2540',
                                                      nx=loop_number, dx=2740, polarity='negative'))
                # --添加圆pad
                pad_x_list = [left_yhpy_x, left_yhpy_x, right_yhpy_x, right_yhpy_x]
                pad_y_list = [yh_py_y1, yh_py_y2, yh_py_y1, yh_py_y2]
                info_list.extend(self.convert_to_dict(x_list=pad_x_list, y_list=pad_y_list, symbol='r1524'))
                # --添加文字标示
                text_x_list = [my_world_x1, my_world_x1, my_world_x2, my_world_x2]
                text_y_list = [my_world_y1, my_world_y2, my_world_y1, my_world_y2]
                info_list.extend(self.convert_to_dict(x_list=text_x_list, y_list=text_y_list, text=wd_content,
                                                      x_size=0.508, y_size=0.635, w_factor=0.5))
                # --字典增加键值对,键为当前层别名,值为info_list
                info[layer_name] = info_list
                # --坐标自增并进入下一轮循环
                left_yhpy_x = left_yhpy_x + 0.2 + 2.54
                right_yhpy_x = right_yhpy_x + 0.2 + 2.54
                my_world_x1 = left_yhpy_x + 0.825
                my_world_x2 = right_yhpy_x + 0.825
        # --返回由列表组成的字典,字典是无序的,要特别留意symbol添加顺序
        return info
    
    
class yh_measure_pad(DYNAMIC_SYM):
    """
    Pluritec X-ray打靶机导入新靶标设计
    """
    priority = 3

    def __init__(self, frozen_json=None, avoidArea=None, priority=3):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        # 翟鸣通知 暂时不导入 20240229 by lyh 20240430 翟鸣通知导正
        # return info
    
        core_count = self.parm.core_count
        # TODO HDI暂不设定两张core
        # if core_count < 2:
        #     # --两张core及以上才添加
        #     return info
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        profile_xmax = self.parm.profile_xmax
        profile_xmin = self.parm.profile_xmin
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        
        fill_array = self.parm.fill_array
        job_signal_numbers = self.parm.job_signal_numbers
        loop_number = job_signal_numbers - 2
        out_signal_array = self.parm.out_signal_array
        if job_signal_numbers <= 2:
            return {}
        
        stepname = "panel"
        step = gClasses.Step(job, stepname)
        step.open()
        
        mrp_info = get_inplan_mrp_info(job.name.upper(), condtion="1=1")
        ganmo_size_info = get_StackupData(job.name.upper())
        
        yahe_mrp_info = get_inplan_mrp_info(job.name.upper())
        #core_layers = []
        #ciwai_layers = []
        
        outer_process_num = -1
        for i, dic_info in enumerate(sorted(mrp_info, key=lambda x: x["PROCESS_NUM"] * -1)): 
            mrp_name = dic_info["MRPNAME"]
            
            #from_lay = dic_info["FROMLAY"].lower()
            #to_lay = dic_info["TOLAY"].lower()
            #if dic_info["PROCESS_NUM"] == 1:
                #core_layers.append([from_lay, to_lay])
            #else:
                #if "-" in mrp_name:
                    #ciwai_layers.append([from_lay, to_lay])            
            
            if "-" not in mrp_name:
                outer_process_num = dic_info["PROCESS_NUM"]
                
                outer_rout_x = dic_info["PNLROUTX"] * 25.4
                outer_rout_y = dic_info["PNLROUTY"] * 25.4                
                
        #core_layers.sort(key=lambda x: int(x[0][1:]))
        #ciwai_layers.sort(key=lambda x: int(x[0][1:]) * -1)
        
        symbolname ,symbol_length = self.cr_symbols(step, innersignalLayers, job_signal_numbers, [list(pair) for pair in zip(innersignalLayers[::2], innersignalLayers[1::2])])
        
        include_rect = []
        gm_starty = 0
        gm_startx = 0
        for dic_info in mrp_info:
            rout_x = dic_info["PNLROUTX"] * 25.4
            rout_y = dic_info["PNLROUTY"] * 25.4              
            panel_x = dic_info["PNLXINCH"] * 25.4
            panel_y = dic_info["PNLYINCH"] * 25.4
            input_rout_x = dic_info["PNLROUTX"] * 25.4
            input_rout_y = dic_info["PNLROUTY"] * 25.4            
            lb_x = (panel_x - rout_x) * 0.5
            lb_y = (panel_y - rout_y) * 0.5       
            
            if len(yahe_mrp_info) == 1:
                # 一次压合的 按芯板上来计算
                lb_x = (panel_x - outer_rout_x) * 0.5
                lb_y = (panel_y - outer_rout_y) * 0.5  
                pass
            else:
                if dic_info["PROCESS_NUM"] != outer_process_num - 1:
                    continue            
            
            f_xmin, f_ymin, f_xmax, f_ymax = 0, 0, panel_x, panel_y
            
            for ganmo_info in ganmo_size_info:
                if ganmo_info["MRP_NAME"] == dic_info["MRPNAME"]:
                    current_gm_size = ganmo_info['DF_WIDTH'] * 25.4
                    if input_rout_x < current_gm_size <= input_rout_y:
                        gm_startx = (panel_x - input_rout_x) * 0.5
                        gm_starty = (panel_y - current_gm_size) * 0.5
                        gm_endx = gm_startx + input_rout_x
                        gm_endy = gm_starty + current_gm_size
                        
                    elif current_gm_size <= input_rout_x:
                        gm_startx = (panel_x - current_gm_size) * 0.5
                        gm_starty = (panel_y - input_rout_y) * 0.5
                        gm_endx = gm_startx + current_gm_size
                        gm_endy = gm_starty + input_rout_y
         
            
            # avoid_area = []
            #避开夹头区域
            if dic_info["PNLYINCH"] < 24.5:
                range_list = [(2.5, 80), (155, 225), ((f_xmax+f_xmin)*0.5 - lb_y - 35, (f_xmax+f_xmin)*0.5 - lb_y)]
                # y方向锣边后小于等于24.5的夹短边
                for cur_range in range_list:
                    for cur_dis_y in [(0, 10+lb_y), (f_ymax, f_ymax - 10-lb_y)]:
                        y1 = cur_dis_y[0]
                        y2 = cur_dis_y[1]
                        for cur_dis_x in [((f_xmax+f_xmin)*0.5 + cur_range[0],
                                           (f_xmax+f_xmin)*0.5 + cur_range[1]),
                                          ((f_xmax+f_xmin)*0.5 - cur_range[1],
                                           (f_xmax+f_xmin)*0.5 - cur_range[0])]:
                            x1 = cur_dis_x[0]
                            x2 = cur_dis_x[1]                        
                            # avoid_area.append([x1, y1,x2, y2])
                            avoid_area = RECTANGLE(symbol="r100.1", xmin=x1, ymin=y1, xmax=x2, ymax=y2)
                            include_rect.append(avoid_area)
            else:
                range_list = [(2.5, 80), (155, 225), ((f_ymax+f_ymin)*0.5 - lb_x - 37.5, (f_ymax+f_ymin)*0.5 - lb_x)]
                # y方向锣边后大于24.5的夹长边
                for cur_range in range_list:
                    for cur_dis_x in [(0, 10+lb_x), (f_xmax, f_xmax - 10 - lb_x)]:
                        x1 = cur_dis_x[0]
                        x2 = cur_dis_x[1]
                        for cur_dis_y in [((f_ymax+f_ymin)*0.5 + cur_range[0],
                                           (f_ymax+f_ymin)*0.5 + cur_range[1]),
                                          ((f_ymax+f_ymin)*0.5 - cur_range[1],
                                           (f_ymax+f_ymin)*0.5 - cur_range[0])]:
                            y1 = cur_dis_y[0]
                            y2 = cur_dis_y[1]
                            # avoid_area.append([x1, y1,x2, y2])
                            avoid_area = RECTANGLE(symbol="r100.1", xmin=x1, ymin=y1, xmax=x2, ymax=y2)
                            include_rect.append(avoid_area)
                            # step.PAUSE(str([x1, y1,x2, y2]))
        
        ####
        area_xmax = profile_xmin + 100 # profile_xmax / 2 - 50
        area_xmin = profile_xmin + lb_x
        area_ymax = sr_ymin - 2
        area_ymin = profile_ymin + lb_y
        if gm_starty:
            area_ymin = gm_starty + 3           
        if gm_startx:
            area_xmin = gm_startx + 3         
            
        fx = "X"
        step_x = 0.5
        step_y = 0.5
        # neg_symbolname = "rect7500x30500"
        add_x = profile_xmin + 40
        add_y = profile_ymin + lb_y + 2 + 3.5
        angle = 0
        
        if "-lyh" in self.JOB:
            step.removeLayer("measure_area_tmp")
            step.createLayer("measure_area_tmp")
            step.clearAll()
            step.affect("measure_area_tmp")          
        
        rect_area = self.optimize_coord_find_area_rect(symbolname, x=add_x, y=add_y, area_xmin=area_xmin,
                                                       area_xmax=area_xmax,area_ymin=area_ymin, area_ymax=area_ymax,
                                                       move_fx=fx, move_x_step=step_x, move_y_step=step_y, 
                                                       return_rect="yes",include_rect=include_rect,step=None, 
                                                       four_corner2ll="yes",to_feature_size=0.5)

        if "-lyh" in self.JOB:
            step.clearAll()
            step.affect("measure_area_tmp")
            # step.addRectangle(area_xmin, area_ymin, area_xmax, area_ymax)
            for x, y, rect in rect_area:
                step.addPad(x, y, symbolname)
                
            for other_rect in include_rect:
                step.addRectangle(other_rect.xmin, other_rect.ymin, other_rect.xmax, other_rect.ymax)
        
        arraylist = []
        if rect_area:
            # 取出最小X
            all_x = [x for x, y, _ in rect_area]
            find_xy = sorted([(x, y) for x, y, _ in rect_area if x == min(all_x)])
            x, y = find_xy[0]
        else:
            area_xmax = sr_xmin - 2
            area_xmin = profile_xmin + lb_x
            area_ymax = profile_ymin + 120# profile_ymax / 2 - 50
            area_ymin = profile_ymin + lb_y
            if gm_starty:
                area_ymin = gm_starty + 3           
            if gm_startx:
                area_xmin = gm_startx + 3
                
            fx = "Y"
            step_x = 0.5
            step_y = 0.5
            # neg_symbolname = "rect7500x30500"
            add_x = profile_xmin + 40
            add_y = profile_ymin + lb_y + 2 + 3.5
            angle = 270
            
            if "-lyh" in self.JOB:
                step.clearAll()
                step.affect("measure_area_tmp")
                step.addRectangle(area_xmin, area_ymin, area_xmax, area_ymax)            
            
            rect_area = self.optimize_coord_find_area_rect(symbolname, sym_angle=270, x=add_x, y=add_y, area_xmin=area_xmin,
                                                           area_xmax=area_xmax,area_ymin=area_ymin, area_ymax=area_ymax,
                                                           move_fx=fx, move_x_step=step_x, move_y_step=step_y, 
                                                           return_rect="yes",include_rect=include_rect,step=step, 
                                                           four_corner2ll="yes",to_feature_size=0.5)
            if rect_area:
                # 取出最小y
                all_y = [y for x, y, _ in rect_area]
                find_xy = sorted([(x, y) for x, y, _ in rect_area if y == min(all_y)])
                x, y = find_xy[0]
            else:
                angle = 0
                warn_content = "Pluritec X-ray打靶机新靶标无法自动找到合适位置，请手动调整避开各类靶标，需上下左右对称调整！"
                msg_dict = {'type': 'critical',
                            'windowTitle': '警告',
                            'content': 'symbol : %s %s' % (self.__class__.__doc__, warn_content)}
                self.warn_content_list.append(warn_content)
                self.msg_array.append(msg_dict)
                
                x = profile_xmin + lb_x + 80 + 2 + symbol_length *0.5
                y = sr_ymin - 2 - 3.5# profile_ymin + lb_y + 2 + 3.5            
                    
        # 左下角
        if angle == 0:            
            add_pad_x1 = x - symbol_length *0.5 + 2.2
            add_pad_y1 = y
        else:
            add_pad_x1 = x 
            add_pad_y1 = y - symbol_length *0.5 + 2.2
            
        arraylist.append([add_pad_x1, add_pad_y1, 1])
        
        # 左上角
        add_pad_x2 = add_pad_x1
        add_pad_y2 = profile_ymax - add_pad_y1
        if angle == 270:
            add_pad_y2 = profile_ymax - y - symbol_length *0.5 + 2.2
            
        arraylist.append([add_pad_x2, add_pad_y2, 2])
        
        # 右下角
        add_pad_x3 = profile_xmax - add_pad_x1
        if angle == 0:
            add_pad_x3 = profile_xmax - x - symbol_length *0.5 + 2.2
            
        add_pad_y3 = add_pad_y1
        arraylist.append([add_pad_x3, add_pad_y3, 3])
        
        # 右上角
        add_pad_x4 = profile_xmax - add_pad_x1
        if angle == 0:
            add_pad_x4 = profile_xmax - x - symbol_length *0.5 + 2.2
            
        add_pad_y4 = profile_ymax - add_pad_y1
        if angle == 270:
            add_pad_y4 = profile_ymax - y - symbol_length *0.5 + 2.2
            
        arraylist.append([add_pad_x4, add_pad_y4, 4])
        info['避开区域'] = []
        for worklayer in innersignalLayers:
            info_list = []
            #step.clearAll()
            #step.affect(worklayer)
            index = int(worklayer[1:])            
            for x, y , num in arraylist:
                # symbolname = "measure_l%s_%s_%s" % (job_signal_numbers, index, "l" if num in [1, 2] else "r")
                symbolname = "measure_l%s_%s_%s" % (job_signal_numbers, index, "l")
                if num == 3:
                    # symbolname = "measure_fd_l%s_%s_%s" % (job_signal_numbers, index, "l" if num in [1, 2] else "r")
                    symbolname = "measure_fd_l%s_%s_%s" % (job_signal_numbers, index, "l")
                
                new_angle = angle
                #if angle == 270:
                    #if num in [2, 4]:
                        #new_angle = 90
                    
                info_list.extend(self.convert_to_dict(x_list=[x], y_list=[y], symbol=symbolname, angle=new_angle))
                if num in [1, 2]:                
                    info['避开区域'].extend(self.convert_to_dict(x_list=[x + symbol_length * 0.5 - 2.2], y_list=[y], symbol='rect{0}x{1}'.format(symbol_length*1000, 6000)))
                else:
                    info['避开区域'].extend(self.convert_to_dict(x_list=[x - symbol_length * 0.5 + 2.2], y_list=[y], symbol='rect{0}x{1}'.format(symbol_length*1000, 6000)))
                # step.addPad(x, y, symbolname)
            info[worklayer] = info_list
            
        # step.clearAll()
        # --返回由列表组成的字典,字典是无序的,要特别留意symbol添加顺序
        return info
    
    def cr_symbols(self, step, innersignalLayers, job_signal_numbers, layers_zu):
        worklayer = "create_sym_tmp"
        step.removeLayer(worklayer)
        step.createLayer(worklayer)
        step.clearAll()
        step.affect(worklayer)
        # step = gClasses.Step(job, step.name)
        for fx in ["l", "r"]:
            for i, inn_layer in enumerate(innersignalLayers):
                index = int(inn_layer[1:])
                symbolname = "measure_l%s_%s_%s" % (job_signal_numbers, index, fx)
    
                step.resetFilter()
                step.selectAll()
                if step.featureSelected():
                    step.selectDelete()
                
                step.reset_fill_params()
                if fx == "l":
                    step.addRectangle(-2.2, -3, 4 + 2.74 * (len(innersignalLayers) / 2 - 1)+1.47, 3)
                    # step.addRectangle(4-2.54*0.5, -3, 4 + 2.74 * (len(innersignalLayers) / 2 - 1) + 2.54*0.5+0.15, 3, polarity="negative")
                else:
                    step.addRectangle(2.2, -3, -4 - 2.74 * (len(innersignalLayers) / 2 - 1) - 1.47, 3)
                    # step.addRectangle(-4+2.54*0.5, -3, -4 - 2.74 * (len(innersignalLayers) / 2 - 1) - 2.54*0.5-0.15, 3, polarity="negative")
                
                symbol_rect = "rect{0}x{1}".format((4 + 2.74 * (len(innersignalLayers) / 2 - 1)+1.47+2.2+0.15) *1000, 6000)
                
                step.addPad(0, 0, "rect4000x5600", polarity="negative")                
                step.addPad(0, 0, "r2500")
                    
                    
                move_size = 0
                if index >= 10:
                    move_size = -0.35
                #if dic_layer_mirror[inn_layer] =="yes":
                    #move_size = -0.508
                    
                for j,zu_layer in enumerate(layers_zu):
    
                    if symbolname.endswith("l"):
                        step.addPad(4 + 2.74 * j, 1.5, "s2540", polarity="negative")
                        step.addPad(4 + 2.74 * j, -1.5, "s2540", polarity="negative")
                        #if not i % 2:
                            #if (j + 1) * 2 == index:
                        if inn_layer == zu_layer[0]:
                            step.resetAttr()
                            step.COM('cur_atr_set,attribute=.string,text={0}'.format(index))
                            step.addPad(4 + 2.74 * j, 1.5, "r1524", attributes="yes")
                            #step.addText(4 + 2.74 * j + 0.825+move_size, 1.5-1.24, str(index),
                                         #0.508, 0.635, 0.5, # mirror=dic_layer_mirror[inn_layer],
                                         #fontname="simplex")
                        #else:
                            #if (j + 1) * 2 == index - 1:
                        if inn_layer == zu_layer[1]:
                            step.resetAttr()
                            step.COM('cur_atr_set,attribute=.string,text={0}'.format(index))                          
                            step.addPad(4 + 2.74 * j, -1.5, "r1524", attributes="yes")
                            #step.addText(4 + 2.74 * j + 0.825+move_size, -1.5-1.24, str(index),
                                         #0.508, 0.635, 0.5, # mirror=dic_layer_mirror[inn_layer],
                                         #fontname="simplex")                   
                    else:
                        step.addPad(-4 - 2.74 * j, 1.5, "s2540", polarity="negative")
                        step.addPad(-4 - 2.74 * j, -1.5, "s2540", polarity="negative")
                        #if not i % 2:
                            #if (j + 1) * 2 == index:
                        if inn_layer == zu_layer[0]:
                            step.resetAttr()
                            step.COM('cur_atr_set,attribute=.string,text={0}'.format(index))                          
                            step.addPad(-4 - 2.74 * j, 1.5, "r1524", attributes="yes")
                            #step.addText(-4 - 2.74 * j + 0.825+move_size, 1.5-1.24, str(index),
                                         #0.508, 0.635, 0.5, # mirror=dic_layer_mirror[inn_layer],
                                         #fontname="simplex")
                        #else:
                            #if (j + 1) * 2 == index - 1:
                        if inn_layer == zu_layer[1]:
                            step.resetAttr()
                            step.COM('cur_atr_set,attribute=.string,text={0}'.format(index))                      
                            step.addPad(-4 - 2.74 * j, -1.5, "r1524", attributes="yes")
                            #step.addText(-4 - 2.74 * j + 0.825+move_size, -1.5-1.24, str(index),
                                         #0.508, 0.635, 0.5, # mirror=dic_layer_mirror[inn_layer],
                                         #fontname="simplex")
                step.COM(
                    "sel_create_sym,symbol=%s,x_datum=0,y_datum=0,delete=no,"
                    "fill_dx=2.54,fill_dy=2.54,attach_atr=no,retain_atr=yes"% symbolname)
                
                # if fx == "r":
                step.resetAttr()
                symbolname = "measure_fd_l%s_%s_%s" % (job_signal_numbers, index, fx)
                step.resetFilter()
                step.selectSymbol("r2500", 1, 1)
                if step.featureSelected():
                    step.changeSymbol("r2000")
                    step.COM(
                        "sel_create_sym,symbol=%s,x_datum=0,y_datum=0,delete=no,"
                        "fill_dx=2.54,fill_dy=2.54,attach_atr=no,retain_atr=yes"% symbolname)
                        
        step.removeLayer(worklayer)
        return symbol_rect,4 + 2.74 * (len(innersignalLayers) / 2 - 1)+1.47+2.2 +0.15    


# ----------------------------------------------------------------------------------------------------------------------
class moving_test(object):
    """
    测试moving算法
    """
    priority = 4

    def __init__(self, frozen_json=None, avoidArea=None, priority=4):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        self.JOB = os.environ.get('JOB', None)
        self.GEN = genCOM.GEN_COM()
        self.avoidArea = avoidArea
        self.avoidArea['inner'] = self.get_rects()
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=self.avoidArea, priority=priority,
                             avoidType=self.avoidType)
        self.GEN.WORK_LAYER('panel_map')

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:
        :rtype:
        """
        info = {}
        sr_xmax = self.parm.sr_xmax
        sr_xmin = self.parm.sr_xmin
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        sr_lenth = self.parm.sr_lenth
        profile_ymin = self.parm.profile_ymin
        profile_ymax = self.parm.profile_ymax
        rout_y = self.parm.rout_y
        fill_array = self.parm.fill_array
        job_signal_numbers = self.parm.job_signal_numbers
        loop_number = job_signal_numbers - 2
        out_signal_array = self.parm.out_signal_array

        rect_lenth = 1.50
        rect_width = 1.50
        rect_sym = "rect%sx%s" % (rect_lenth * 1000, rect_width * 1000)
        # rect_sym = 'r2540'
        rect_x1 = sr_xmin + 0.5 + rect_lenth / 2
        rect_x2 = sr_xmax - 0.5 - rect_lenth / 2
        rect_y1 = sr_ymin - 3
        rect_y2 = sr_ymax + 3

        # --短边左下角
        area_xmin = sr_xmin + 0.5
        area_xmax = 40
        area_ymin = 30
        area_ymax = rect_y1 + (rect_width * 0.5)
        # rect_x1, rect_y1 = self.optimize_coord(rect_sym, x=rect_x1, y=rect_y1, area_xmin=area_xmin,
        #                                        area_ymin=area_ymin, area_xmax=area_xmax, area_ymax=area_ymax)
        rect_x_list = [rect_x1]
        rect_y_list = [rect_y1]

        # --短边左上角
        area_xmin = sr_xmin + 0.5
        area_xmax = 40
        area_ymin = rect_y2 - (rect_width * 0.5)
        area_ymax = rect_y2 + (rect_width * 0.5) + 30
        # rect_x1, rect_y2 = self.optimize_coord(rect_sym, x=rect_x1, y=rect_y2, area_xmin=area_xmin,
        #                                        area_ymin=area_ymin, area_xmax=area_xmax, area_ymax=area_ymax)
        rect_x_list = [rect_x1]
        rect_y_list = [rect_y2]

        # --短边右下角
        area_xmin = sr_xmax - 0.5
        area_xmax = sr_xmax - 40
        area_ymin = 30
        area_ymax = rect_y1 + (rect_width * 0.5)
        # rect_x2, rect_y1 = self.optimize_coord(rect_sym, x=rect_x2, y=rect_y1, area_xmin=area_xmin,
        #                                        area_ymin=area_ymin, area_xmax=area_xmax, area_ymax=area_ymax)
        # rect_x_list = [rect_x2]
        # rect_y_list = [rect_y1]

        # --短边右上角
        area_xmin = sr_xmax - 0.5
        area_xmax = sr_xmax - 40
        area_ymin = rect_y2 - (rect_width * 0.5)
        area_ymax = rect_y2 + (rect_width * 0.5) + 30
        # rect_x2, rect_y2 = self.optimize_coord(rect_sym, x=rect_x2, y=rect_y2, area_xmin=area_xmin,
        #                                        area_ymin=area_ymin, area_xmax=area_xmax, area_ymax=area_ymax)
        rect_x_list = [rect_x2]
        rect_y_list = [rect_y2]

        # --长边右上角
        rect_y1 = sr_ymin + 0.5 + rect_width / 2
        rect_y2 = sr_ymax - 0.5 - rect_width / 2
        rect_x1 = sr_xmin - 3
        rect_x2 = sr_xmax + 3
        area_xmin = rect_x2 - (rect_lenth * 0.5)
        area_xmax = sr_xmax + 15
        area_ymin = sr_ymax - 35
        area_ymax = sr_ymax - 0.5
        # rect_x2, rect_y2 = self.optimize_coord(rect_sym, x=rect_x2, y=rect_y2, area_xmin=area_xmin,
        #                                        area_ymin=area_ymin, area_xmax=area_xmax, area_ymax=area_ymax)
        rect_x_list = [rect_x2]
        rect_y_list = [rect_y2]

        # --长边右下角
        area_xmin = rect_x2 - (rect_lenth * 0.5)
        area_xmax = sr_xmax + 15
        area_ymin = sr_ymin + 0.5
        area_ymax = sr_ymin + 35
        rect_x2, rect_y1 = self.optimize_coord(rect_sym, x=rect_x2, y=rect_y1, area_xmin=area_xmin,
                                               area_ymin=area_ymin, area_xmax=area_xmax, area_ymax=area_ymax)
        rect_x_list = [rect_x2]
        rect_y_list = [rect_y1]

        # --长边左上角
        area_xmin = sr_xmin - 15
        area_xmax = rect_x1 + (rect_lenth * 0.5)
        area_ymin = sr_ymax - 35
        area_ymax = sr_ymax - 0.5
        # rect_x1, rect_y2 = self.optimize_coord(rect_sym, x=rect_x1, y=rect_y2, area_xmin=area_xmin,
        #                                        area_ymin=area_ymin, area_xmax=area_xmax, area_ymax=area_ymax)
        # rect_x_list = [rect_x1]
        # rect_y_list = [rect_y2]

        # --长边左下角
        area_xmin = sr_xmin - 15
        area_xmax = rect_x1 + (rect_lenth * 0.5)
        area_ymin = sr_ymin + 0.5
        area_ymax = sr_ymin + 35
        # rect_x1, rect_y1 = self.optimize_coord(rect_sym, x=rect_x1, y=rect_y1, area_xmin=area_xmin,
        #                                        area_ymin=area_ymin, area_xmax=area_xmax, area_ymax=area_ymax)
        # rect_x_list = [rect_x1]
        # rect_y_list = [rect_y1]

        info['panel_map'] = self.convert_to_dict(x_list=rect_x_list, y_list=rect_y_list, symbol=rect_sym)
        return info

    def get_rects(self):
        """
        获取当前可移动区域内symbol所占用的矩形区域
        :return: rectangles
        :rtype: list
        """
        rects = []
        info = self.GEN.INFO('-t layer -e %s/panel/panel_map -m script -d FEATURES' % self.JOB)
        for line in info[1:]:
            getline = line.split()
            xc = float(getline[1])
            yc = float(getline[2])
            symbol = getline[3]
            # --此处的rect5000x10000暂未考虑方向
            lenth, width = symbol.strip('rect').split('x')
            width = float(width) / 1000
            lenth = float(lenth) / 1000
            xmin = xc - lenth / 2 - 0.5
            xmax = xc + lenth / 2 + 0.5
            ymin = yc - width / 2 - 0.5
            ymax = yc + width / 2 + 0.5
            rect = RECTANGLE(symbol=symbol, xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax)
            rects.append(rect)
        return rects


# ----------------------------------------------------------------------------------------------------------------------
class pin_donut(STATIC_SYM):
    """
    方向孔
    """

    def __init__(self, frozen_json=None, priority=2):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:字典的列表，保持symbol的添加顺序
        :rtype:list of dict
        """
        job_signal_numbers = self.parm.job_signal_numbers
        top_after_margin = self.parm.top_after_margin
        left_after_margin = self.parm.left_after_margin
        L_margin = self.parm.L_margin
        R_margin = self.parm.R_margin
        profile_xmax = self.parm.profile_xmax
        profile_xmin = self.parm.profile_xmin
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        sh_site = self.parm.sh_site
        flow_content = self.parm.flow_content
        put_copper_out = self.parm.put_copper_out
        put_copper_md = self.parm.put_copper_md
        add_first_plant = self.parm.add_first_plant
        blind_burry_by_lamin = self.parm.blind_burry_by_lamin
        burry_list = self.parm.burry_list
        burry_sz_dict = self.parm.burry_sz_dict
        lamination = self.parm.lamination
        jx_drill_list = self.parm.jx_drill_list
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        hdi_num = self.parm.hdi_num
        pin_fd_h = self.parm.pin_fd_h
        lr_layer = self.parm.lr_layer
        sh_site = self.parm.sh_site
        panel_case = self.parm.panel_case

        fir_silk_station = self.parm.fir_silk_station
        sec_silk_station = self.parm.sec_silk_station
        thd_silk_station = self.parm.thd_silk_station
        add_eagle_panel = self.parm.add_eagle_panel

        pin_x_array = []
        pin_y_array = []
        # --埋孔方向孔
        pin_x_burry = []
        pin_y_burry = []
        # --机械盲孔方向孔
        pin_x_mach = []
        pin_y_mach = []
        pin_x_array_2mm = []
        pin_y_array_2mm = []
        # --inn层只加四个孔，第五个防呆孔不加
        if job_signal_numbers == 2:
            # --双面板用r2000的范围孔代替
            sym_array_inn = [None, None, None, None, None]
            # === 2021.09.03 双面板，锣后尺寸使用板尺寸 ===
            rout_x = profile_xmax
            rout_y = profile_ymax
        else:
            sym_array_inn = ['r3175', 'r3175', 'r3175', 'r3175', 'r3175']
        # --不管档点是否铺铜,方向孔对应档点均做成neg属性
        sym_array_md = 'sh-fxpad'
        if put_copper_md == 'no':
            pol_array_md = 'negative'
        else:
            pol_array_md = 'negative'
        inner_r0_dict = []
        sz_info_dict = []
        sym_array_ast = ['sh-pindonut', 'sh-pindonut', 'sh-pindonut', 'sh-pindonut', None]
        # --一厂外层五个方向孔对应symbol全部为sh-pin-fx
        sym_array_out_top = ['sh-pin-fx', 'sh-pin-fx', 'sh-pin-fx', 'sh-pin-fx', 'sh-pin-fx']
        sym_array_out_bot = ['sh-pin-fx', 'sh-pin-fx', 'sh-pin-fx', 'sh-pin-fx', 'sh-pin-fx']
        pol_array_out = ['positive', 'positive', 'positive', 'positive', 'positive']
        sm_pol = 'positive'
        if add_first_plant == 'no':
            # --其它厂别防焊symbol为r3683
            # sm_symbol = 'r3683'
            sm_symbol = ['s4429', 's4429', 's4429', 'r3683', 's4429']
            sm_pol = 'negative'
            # --喷锡板也不能露铜,需求story-view-2735 ==> HDI 无此要求
            pn_seven = self.JOB[6]
            if pn_seven in ['h', 'l']:
                sm_pol = 'positive'
            else:
                sm_pol = 'negative'
            if flow_content == '一次铜':
                sym_array_out_top = ['sh-dwtop2013', 'sh-dwtop2013', 'sh-dwtop2013', 'chris-3683symbol', 'sh-dwtop2013']
                sym_array_out_bot = ['sh-dwbot2013', 'sh-dwbot2013', 'sh-dwbot2013', 'chris-3683symbol', 'sh-dwbot2013']
                pol_array_out = ['negative', 'negative', 'negative', 'positive', 'negative']
            else:
                sym_array_out_top = ['chris-3683symbol', 'chris-3683symbol', 'chris-3683symbol', 'chris-3683symbol',
                                     'chris-3683symbol']
                sym_array_out_bot = ['chris-3683symbol', 'chris-3683symbol', 'chris-3683symbol', 'chris-3683symbol',
                                     'chris-3683symbol']
        else:
            # --一厂防焊symbol为r3150
            sm_symbol = 'r3150'
            # sm_symbol = ['s4429', 's4429', 's4429', 'r3150', 's4429']
        if top_after_margin < 7:
            # --短边留边不足7mm时，方向孔设计在长边，坐标旋转如下
            pin_x_max = sr_xmax + 4.3
            pin_y_max = sr_ymax - 3
            pin_x_min = sr_xmin - 4.3
            pin_y_max = sr_ymin
            pin_y_min2 = sr_ymin + 7.323

            pin_y_min3 = sr_ymax - 3 - 7.323
            pin_y_min4 = sr_ymin + 7.323 + 6

            pin_y_min2fd = pin_y_min2 + pin_fd_h

            pin_x_array = [pin_x_min, pin_x_max, pin_x_max, pin_x_min, pin_x_min]
            pin_y_array = [pin_y_max, pin_y_max, pin_y_max, pin_y_max, pin_y_min2fd]

            # --埋孔在左下角偏移5.5mm以与通孔防呆
            for layer in burry_list:
                # if layer.startswith ('b'):
                pin_y_min2fd += 5.5
                pin_x_burry.append(pin_x_min)
                pin_y_burry.append(pin_y_min2fd)
                for burry_sz in burry_sz_dict:
                    if burry_sz.mach_drill == layer:
                        sz_info_dict.append([burry_sz.dq_layer, pin_x_min, pin_y_min2fd])
                        sz_info_dict.append([burry_sz.sz_layer, pin_x_min, pin_y_min2fd])

                # === 仅有埋孔的压合，使用板角位置孔做线路对位
                for index, cur_lamin in enumerate(lamination, 1):
                    tmp_lamin = [i for i in blind_burry_by_lamin if int(i.cur_yh_num) == index]
                    if len(tmp_lamin) != 0:
                        current_lamin_hole = tmp_lamin[0]
                        # current_lamin_hole = [i for i in blind_burry_by_lamin if int (i.cur_yh_num) == index][0]
                        if hasattr(current_lamin_hole, 'burryLayer') and not hasattr(current_lamin_hole,
                                                                                     'blindLayer'):
                            if layer == current_lamin_hole.burryLayer:
                                tmp_array = [cur_lamin.FROMLAY.lower(), cur_lamin.TOLAY.lower(), pin_x_min,
                                             pin_y_min2fd]
                                inner_r0_dict.append(tmp_array)
                # === 非零压且不属于其他压合的埋孔 ===
                get_burry_list = [i.burryLayer for i in blind_burry_by_lamin if hasattr(i, 'burryLayer')]
                not_in_lamin_burry = list(
                    set(burry_list).difference(set(get_burry_list)))  # burry_list中有而get_burry_list中没有的      非常高效！
                for b_layer in not_in_lamin_burry:
                    from_lay = 'l%s' % (b_layer.strip('b').split('-')[0])
                    to_lay = 'l%s' % (b_layer.strip('b').split('-')[1])
                    tmp_array = [from_lay, to_lay, pin_x_min, pin_y_min2fd]
                    inner_r0_dict.append(tmp_array)
            # --机械盲孔在左下角偏移5.5mm以与通孔防呆
            for layer in jx_drill_list:
                # --自增5.5mm,可能有机械盲孔和埋孔共存板，如966/072,机械盲孔需要用到pin_yl_min2
                pin_y_min2fd += 5.5
                pin_x_mach.append(pin_x_min)
                pin_y_mach.append(pin_y_min2fd)
        else:
            if L_margin > 20 and R_margin > 20 and add_first_plant == 'no':
                # --长边留边大于20mm,非一厂料号
                pin_y_max = sr_ymax + 4.3
                pin_y_min = sr_ymin - 4.3
                # V2.11 双面板板角孔需在dbk范围内，5.5->改成 6
                tmp_value = 5.5
                if abs(profile_xmax - rout_x) < 0.01:
                    tmp_value = 6
                pin_x_max = profile_xmax - (profile_xmax - rout_x) * 0.5 - tmp_value
                pin_x_min = profile_xmin + (profile_xmax - rout_x) * 0.5 + tmp_value
                pin_x_min1 = pin_x_min + 7.323
                pin_x_min2 = pin_x_min + 7.323
                # 如果pin_x_min2防呆孔距离X-min不足4mm,坐标计算移动至4mm范围内
                if pin_x_min2 < sr_xmin - 6.5875:
                    pin_x_min2 = sr_xmin - 2.5875
            else:
                # --一厂料号
                pin_y_max = sr_ymax + 4.3
                pin_x_max = sr_xmax - 3
                pin_y_min = sr_ymin - 4.3
                pin_x_min = sr_xmin
                pin_x_min1 = sr_xmin + 7.323
                pin_x_min2 = sr_xmin + 7.323
            pin_x_min3 = sr_xmax - 3 - 7.323
            pin_x_min4 = sr_xmin + 7.323 + 6
            if hdi_num < 1:
                if top_after_margin > 20.5:
                    # pin_y_max = profile_ymax - (profile_ymax - rout_y) * 0.5 - 5 - 3.175 * 0.5
                    # pin_y_min = profile_ymin + (profile_ymax - rout_y) * 0.5 + 5 + 3.175 * 0.5
                    # ===  避让dbk层 板角的6mm位置 ===
                    pin_y_max = profile_ymax - (profile_ymax - rout_y) * 0.5 - 6 - 3.175
                    pin_y_min = profile_ymin + (profile_ymax - rout_y) * 0.5 + 6 + 3.175
                    # 最多不超过板内13mm
                    if pin_y_max > sr_ymax + 10.4125 and pin_y_min < sr_ymin - 10.4125:
                        pin_y_max = sr_ymax + 10.4125
                        pin_y_min = sr_ymin - 10.4125
            pin_x_min2fd = pin_x_min2 + pin_fd_h
            # === 在静态symbol的添加中增加此pin_donut(转换为s4650)避让四靶，如果有移动，使用移动后的坐标增加防呆值进行添加
            pin_fd_x, pin_y = self.optimize_static('s4650', x_org=pin_x_min2fd, y_org=pin_y_min,
                                                   area_xmin=pin_x_min2fd - 2.5,
                                                   area_xmax=pin_x_min2fd + 50)
            if pin_x_min2fd != pin_fd_x:
                pin_x_min2fd = pin_fd_x + pin_fd_h
            # print pin_fd_x
            # self.GEN.PAUSE('xxxxxxxxxxxxxxxxxxxxxx')
            pin_x_array = [pin_x_min, pin_x_max, pin_x_max, pin_x_min, pin_x_min2fd]
            pin_y_array = [pin_y_max, pin_y_max, pin_y_min, pin_y_min, pin_y_min]
            
            #左下角另加一颗3.175mm钻孔。优先与防呆孔平齐。可移动。依外围孔设计掏开外层和阻焊开窗 给到成型锣带制作防呆用 20240401 by lyh
            rout_fd_hole_x = [pin_x_max - 30 - 5 *random.random() - pin_fd_h]
            rout_fd_hole_y = [pin_y_min]
            
            # --埋孔在左下角偏移5.5mm以与通孔防呆
            for layer in burry_list:
                # if layer.startswith ('b'):
                # --自增5.5mm,可能有机械盲孔和埋孔共存板，如966/072,机械盲孔需要用到pin_xl_min2
                pin_x_min2fd += 5.5
                pin_x_burry.append(pin_x_min2fd)
                pin_y_burry.append(pin_y_min)

                for burry_sz in burry_sz_dict:
                    if burry_sz.mach_drill == layer:
                        sz_info_dict.append([burry_sz.dq_layer, pin_x_min2fd, pin_y_min])
                        sz_info_dict.append([burry_sz.sz_layer, pin_x_min2fd, pin_y_min])

                # === 仅有埋孔的压合，使用板角位置孔做线路对位 开料埋孔类型不满足此规则见类hdi_tag_symbol
                for index, cur_lamin in enumerate(lamination, 1):
                    tmp_lamin = [i for i in blind_burry_by_lamin if int(i.cur_yh_num) == index]
                    if len(tmp_lamin) != 0:
                        current_lamin_hole = tmp_lamin[0]
                        if hasattr(current_lamin_hole, 'burryLayer') and not hasattr(current_lamin_hole, 'blindLayer'):
                            if layer == current_lamin_hole.burryLayer:
                                tmp_array = [cur_lamin.FROMLAY.lower(), cur_lamin.TOLAY.lower(), pin_x_min2fd,
                                             pin_y_min]
                                inner_r0_dict.append(tmp_array)
                # === 非零压且不属于其他压合的埋孔 ===
                get_burry_list = [i.burryLayer for i in blind_burry_by_lamin if hasattr(i, 'burryLayer')]
                not_in_lamin_burry = list(
                    set(burry_list).difference(set(get_burry_list)))  # burry_list中有而get_burry_list中没有的      非常高效！
                for b_layer in not_in_lamin_burry:
                    from_lay = 'l%s' % (b_layer.strip('b').split('-')[0])
                    to_lay = 'l%s' % (b_layer.strip('b').split('-')[1])
                    tmp_array = [from_lay, to_lay, pin_x_min2fd, pin_y_min]
                    inner_r0_dict.append(tmp_array)

            # --机械盲孔在左下角偏移5.5mm以与通孔防呆
            for layer in self.parm.jx_drill_list:
                pin_x_min2fd += 5.5
                pin_x_mach.append(pin_x_min2fd)
                pin_y_mach.append(pin_y_min)

        # if sh_site == "HDI二厂":
        #     # http://192.168.2.120:82/zentao/story-view-3333.html
        #     silk_layer = "文字"
        # else:
        #     silk_layer = "非一次文字"

        silk_layer = '文字'
        if fir_silk_station == '文字喷印':
            silk_layer = "非一次文字"

        if sec_silk_station == '文字印刷':
            if fir_silk_station == '文字印刷':
                silk_layer = '文字'
            else:
                silk_layer = "非一次文字"

        # if put_copper_out == 'yes' and flow_content == '一次铜':
        #     # --依据add_copper_under_sym,symbol下面加底铜
        #     sym_array_out = ['s5191', 's5191', 's5191', 'r4648.2', 's5191']
        #     info = {}
        #     info['外层'] = self.convert_to_dict (x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_out,
        #                                        attribute='.string,text=under_copper')
        #     # --底铜先添加,保证在最底下,因为字典是无序的,不能保证底铜优先,所以底铜在此独立出来
        #     self.add_symbol (info)
        # === 2021.09.08 周涌需求，选化层先套开负性，再添加与孔等大的pad
        info = {}
        sym_array_out = ['s5191', 's5191', 's5191', 'r4648.2', 's5191']
        info['选化'] = self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_out,
                                          attribute='.string,text=under_copper', polarity='negative')
        # --底铜先添加,保证在最底下,因为字典是无序的,不能保证底铜优先,所以底铜在此独立出来
        self.add_symbol(info)
        # --收集到坐标信息后生成info
        info = {
            # http://192.168.2.120:82/zentao/story-view-5815.html
            # 为省金，取消次两组线路靶标20230724 by lyh
            # '外层c': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_out_top,
                                        #polarity=pol_array_out),
            #'外层s': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_out_bot,
                                        #polarity=pol_array_out),
            # === 选化层，与孔等大的实心pad === 周涌纠错于2021.08.31===
            '选化': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='r3175'),
            '化金': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='sh-fxpad', polarity='negative'),
            # '蚀刻引线': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='r3683', polarity='negative'),
            '印选化油': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='r2972', polarity='negative'),
            '防焊': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol=sm_symbol, polarity=sm_pol),
            '通孔': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array,
                                           symbol='r3175', attribute='.string,text=drl_fxk'),
            '铝片': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='r3175'),
            '埋孔': self.convert_to_dict(x_list=pin_x_array[:-1] + [None], y_list=pin_y_array[:-1] + [None],
                                       symbol=sym_array_inn[:-1] + [None]),
            '埋孔铝片': self.convert_to_dict(x_list=pin_x_array[:-1] + [None], y_list=pin_y_array[:-1] + [None],
                                         symbol=sym_array_inn[:-1] + [None]),
            '埋孔导气': self.convert_to_dict(x_list=pin_x_array[:-1] + [None], y_list=pin_y_array[:-1] + [None],
                                         symbol=sym_array_inn[:-1] + [None]),
            '档点': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_md,
                                       polarity=pol_array_md),
            # === 文字层不加 ===
            # '文字': self.convert_to_dict (x_list=pin_x_array, y_list=pin_y_array, symbol='sh-fxpad'),
            silk_layer: self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='sh-fxpad'),
            '内层': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='sh-pindonut',
                                       polarity='negative'),
            '外层': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='r3429',
                                       polarity='negative'),              
            '辅助层': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_ast,
                                        polarity='negative'),
            '碳油': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='sh-fxpad'),
            # 'bdc.inn': self.convert_to_dict (x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_inn),
            # 'bds.inn': self.convert_to_dict (x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_inn),
            # === 2022.05.13 V2.09 周涌钉钉沟通，2nd.inn 仅跑出四孔
            '2nd.inn': self.convert_to_dict(x_list=pin_x_array[:-2] + [pin_x_array[-1]], y_list=pin_y_array[:-2] + [pin_y_array[-1]] , symbol=sym_array_inn[:-2]+[sym_array_inn[-1]]),
            # --inn层不需要四个方向孔,保要三个靶孔即可
            # 'inn' : self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_inn),
            # '埋孔inn' : self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_inn),
            # '机械盲孔inn' : self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_inn),
            # 内层已添加，埋孔内层不需要多加一次symbol，此处用来占位
            '埋孔内层': self.convert_to_dict(x_list=[None, None, None, None, None], y_list=[None, None, None, None, None],
                                         symbol=None,
                                         polarity='negative'),
            '机械盲孔': self.convert_to_dict(x_list=pin_x_array[:-1] + [None], y_list=pin_y_array[:-1] + [None],
                                         symbol=sym_array_inn[:-1] + [None]),
            # 内层已添加，机械盲孔内层不需要多加一次symbol，此处用来占位
            '机械盲孔内层': self.convert_to_dict(x_list=[None, None, None, None, None], y_list=[None, None, None, None, None],
                                           symbol=None,
                                           polarity='negative'),
            # 'bd-sz.lpc': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='r3175'),
            # 'bd-sz.lps': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='r3175'),
            # 'sz.lp': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='r3175'),
            '树脂导气': self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='r3175'),
        }
        
        #http://192.168.2.120:82/zentao/story-view-5456.html 20230504 by lyh
        """1.跑Panel时背钻及控深钻位置将通孔四个角的方向孔 其中一个防呆 到背钻及控深钻的靶孔层，大小改为2.0mm        
        2.Led板除外
        3.输出钻带时2.0mm固定放最后一把刀，按T99刀序"""
        #--V2.17
        if add_eagle_panel == "否":    
            # self.GEN.PAUSE(str([self.parm.drl, self.parm.drill_array]))
            for bd_lay in self.parm.drill_array:
                if re.match("^bd-?[cs]$|^cd-?[cs]$|^cs-?[cs]$|^cb-?[cs]$", bd_lay) or \
                   re.match("^[bc]d[cs]-?[1-9]$|^[bc]d[cs]-?[1-9]$", bd_lay) or \
                   re.match("^[bc]d-[1-9][cs][2-9]?$|^[bc]d-[1-9][cs][2-9]?$", bd_lay) or \
                   re.match("^c[bs][cs]-?[1-9]$|^c[bs][cs]-?[1-9]$", bd_lay) or \
                   re.match("^c[bs]-[1-9][cs][2-9]?$|^c[bs]-[1-9][cs][2-9]?$", bd_lay):
                        info[bd_lay] = self.convert_to_dict(x_list=pin_x_array[:3]+[pin_x_array[-1]],
                                                            y_list=pin_y_array[:3]+[pin_y_array[-1]], symbol='r1998')
                    
        # --档点层增加与孔等大的档点，防止油墨入孔
        # info['档点'].extend (self.convert_to_dict (x_list=pin_x_array, y_list=pin_y_array, symbol=sym_array_md_addition))
        if lr_layer:
            info[lr_layer] = self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='r3175')
            
        # --因取消尾孔 在左下角加一个锣带制作防呆孔
        for key, value in info.items():
            if key == '通孔':
                value.extend(self.convert_to_dict(x_list=rout_fd_hole_x, y_list=rout_fd_hole_y, symbol='r3175',
                                                  polarity='positive', attribute='.string,text=rout_fd_fxk'))
            if key == '档点':
                value.extend(self.convert_to_dict(x_list=rout_fd_hole_x, y_list=rout_fd_hole_y, symbol='r3429',
                                                  polarity='positive', attribute='.string,text=rout_fd_fxk'))                
            if key == '防焊':
                value.extend(self.convert_to_dict(x_list=rout_fd_hole_x, y_list=rout_fd_hole_y, symbol=sm_symbol,
                                                  polarity=sm_pol, attribute='.string,text=rout_fd_fxk'))                
            if key == '外层':
                value.extend(self.convert_to_dict(x_list=rout_fd_hole_x, y_list=rout_fd_hole_y, symbol="r3429",
                                                  polarity="negative", attribute='.string,text=rout_fd_fxk'))                 

        # --埋孔在左下角加一个孔
        for key, value in info.items():
            if key == '埋孔内层':
                value.extend(self.convert_to_dict(x_list=pin_x_burry, y_list=pin_y_burry, symbol='sh-pindonut',
                                                  polarity='negative'))
            elif key == '埋孔':
                value.extend(self.convert_to_dict(x_list=pin_x_burry, y_list=pin_y_burry, symbol='r3175'))
            # elif key == '埋孔铝片':
            #     value.extend (self.convert_to_dict (x_list=pin_x_burry, y_list=pin_y_burry, symbol='r3175'))
            # elif key == '埋孔导气':
            #     value.extend (self.convert_to_dict (x_list=pin_x_burry, y_list=pin_y_burry, symbol='r3175'))
            else:
                # --其它层symbol全部默认为None,若有需要可指定
                value.extend(self.convert_to_dict(x_list=pin_x_burry, y_list=pin_y_burry))
        # --机械盲孔在左下角再加一个孔
        for key, value in info.items():
            if key == '机械盲孔内层':
                value.extend(self.convert_to_dict(x_list=pin_x_mach, y_list=pin_y_mach, symbol='sh-pindonut',
                                                  polarity='negative'))
            elif key == '机械盲孔':
                value.extend(self.convert_to_dict(x_list=pin_x_mach, y_list=pin_y_mach, symbol='r3175'))
            else:
                # --其它层symbol全部默认为None,若有需要可指定
                value.extend(self.convert_to_dict(x_list=pin_x_mach, y_list=pin_y_mach))
        # info = {}
        # info['l2'] = self.convert_to_dict(x_list=pin_x_array, y_list=pin_y_array, symbol='sh-pindonut')
        if len(inner_r0_dict) > 0:
            for tmp_array in inner_r0_dict:
                info[tmp_array[0]] = self.convert_to_dict(x_list=pin_x_array[:-2] + [tmp_array[2]],
                                                          y_list=pin_y_array[:-2] + [tmp_array[3]], symbol='r0',
                                                          attribute='.fiducial_name,text=317.reg')
                info[tmp_array[1]] = self.convert_to_dict(x_list=pin_x_array[:-2] + [tmp_array[2]],
                                                          y_list=pin_y_array[:-2] + [tmp_array[3]], symbol='r0',
                                                          attribute='.fiducial_name,text=317.reg')
        if len(sz_info_dict) > 0:
            for tmp_array in sz_info_dict:
                info[tmp_array[0]] = self.convert_to_dict(x_list=[tmp_array[1]], y_list=[tmp_array[2]], symbol='r3175')

        return info

    def change_symbol(self):
        """
        芯板有镭射或者机械钻孔的需要更改线路层的四角钻孔的对位标靶
        :return:
        """
        lr_layer = self.parm.lr_layer
        blind_burry_by_lamin = self.parm.blind_burry_by_lamin
        jx_drill_list = self.parm.jx_drill_list

        if lr_layer:
            tmp_check = [i for i in blind_burry_by_lamin if int(i.cur_yh_num) == 0]
            if len(tmp_check) == 1:
                zero_lamin = tmp_check[0]
                if hasattr(zero_lamin, 'blindLayer'):
                    toplayer = 'l%s' % zero_lamin.start_num
                    botlayer = 'l%s' % zero_lamin.end_num
                    self.GEN.CLEAR_LAYER()
                    self.GEN.AFFECTED_LAYER(toplayer, 'yes')
                    self.GEN.FILTER_RESET()
                    self.GEN.FILTER_SET_TYP('pad')
                    self.GEN.FILTER_SET_INCLUDE_SYMS('sh-pindonut')
                    self.GEN.FILTER_SELECT()
                    self.GEN.FILTER_RESET()
                    count = self.GEN.GET_SELECT_COUNT()
                    if count > 0:
                        self.GEN.COM('sel_change_sym,symbol=%s,reset_angle=no' % 'sh-dwtop2013')

                    self.GEN.CLEAR_LAYER()
                    self.GEN.AFFECTED_LAYER(botlayer, 'yes')
                    self.GEN.FILTER_RESET()
                    self.GEN.FILTER_SET_TYP('pad')
                    self.GEN.FILTER_SET_INCLUDE_SYMS('sh-pindonut')
                    self.GEN.FILTER_SELECT()
                    self.GEN.FILTER_RESET()
                    count = self.GEN.GET_SELECT_COUNT()
                    if count > 0:
                        self.GEN.COM('sel_change_sym,symbol=%s,reset_angle=no' % 'sh-dwbot2013')
                    self.GEN.CLEAR_LAYER()
        if len(jx_drill_list) > 0:
            fill_array = self.parm.fill_array
            out_signal_array = self.parm.out_signal_array
            jx_drill_list = self.parm.jx_drill_list
            jx_drill_start = self.parm.jx_drill_start
            jx_drill_end = self.parm.jx_drill_end
            info = {}
            for i, layer in enumerate(jx_drill_list):
                # --考虑到两次埋孔，所以加了个index,坐标顺序是按jx_drill_list的顺序压入数组的，不担心会错乱
                layer_start = int(jx_drill_start[i][1:])
                layer_end = int(jx_drill_end[i][1:])
                # === 非core层钻带不需要更改 ===
                if abs(layer_end - layer_start) != 1:
                    continue
                for fill_hash in fill_array:
                    layer_name = fill_hash.layer_name
                    if layer_name in out_signal_array:
                        # --机械盲孔外层不加pad
                        continue
                    # --考虑辅助层
                    layer_side = fill_hash.layer_side
                    layer_id = int(layer_name.strip('.fz').split('-')[0][1:])
                    if layer_id == layer_start or layer_id == layer_end:
                        self.GEN.CLEAR_LAYER()
                        self.GEN.COM('affected_layer,name=%s,mode=single,affected=yes' % layer_name)
                        if layer_side == "正":
                            des_symbol = 'sh-dwtop2013'
                        elif layer_side == "反":
                            des_symbol = 'sh-dwbot2013'
                        else:
                            des_symbol = None

                        self.GEN.FILTER_RESET()
                        self.GEN.FILTER_SET_TYP('pad')
                        self.GEN.FILTER_SET_INCLUDE_SYMS('sh-pindonut')
                        self.GEN.FILTER_SELECT()
                        self.GEN.FILTER_RESET()
                        count = self.GEN.GET_SELECT_COUNT()
                        get_data = self.GEN.INFO("-t layer -e %s/panel/%s -d FEATURES -o feat_index+select,units=mm" % (
                            self.JOB, layer_name))
                        for line_i in range(1, len(get_data) - 4):
                            # === 保留选择前三个和最后一个，中间的取消选择 ===
                            get_index = get_data[-1 - line_i].split(' ')[0].strip('#')
                            self.GEN.COM(
                                'sel_layer_feat,operation=unselect,layer=%s,index=%s' % (layer_name, get_index))
                        # TODO === 此处数值应为4个 ===
                        if count > 0:
                            self.GEN.COM('sel_change_sym,symbol=%s,reset_angle=no' % des_symbol)
                        self.GEN.CLEAR_LAYER()
                        get_data_in_use = get_data[1:4] + [get_data[-1]]
                        r0_pad_x_list = [i.split()[2] for i in get_data_in_use]
                        r0_pad_y_list = [i.split()[3] for i in get_data_in_use]
                        info[layer_name] = self.convert_to_dict(x_list=r0_pad_x_list, y_list=r0_pad_y_list, symbol='r0',
                                                                attribute='.fiducial_name,text=317.reg')
            self.add_symbol(info)

        # === 非零压类，非by压合的埋孔
        tmp_check = [i for i in blind_burry_by_lamin if int(i.cur_yh_num) == 0]


class out_ccd(DYNAMIC_SYM):
    """
    外层ccd
    """
    priority = 2.1

    def __init__(self, frozen_json=None, avoidArea=None, priority=2.1):
        self.parm = frozen_json
        self.priority = priority
        # self.avoidType = 'outer'
        self.avoidType = 'all'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:字典的列表，保持symbol的添加顺序
        :rtype:list of dict
        """
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        profile_ymax = self.parm.profile_ymax
        profile_xmax = self.parm.profile_xmax
        hdi_num = self.parm.hdi_num
        sel_jsz = self.parm.sel_jsz
        flow_content = self.parm.flow_content
        put_copper_out = self.parm.put_copper_out
        put_copper_md = self.parm.put_copper_md
        job_signal_numbers = self.parm.job_signal_numbers
        add_first_plant = self.parm.add_first_plant
        other_fd_h = self.parm.right_fd_h
        right_fd_h = self.parm.right_fd_h
        pin_fd_h = self.parm.pin_fd_h
        blind_burry_by_lamin = self.parm.blind_burry_by_lamin
        yh_num = len(self.parm.lamination)
        # --原始坐标定义
        out_ccd_xmin = sr_xmin + 6 + other_fd_h
        out_ccd_xmax = sr_xmax - 6 + other_fd_h
        out_ccd_ymin = sr_ymin - 2.5
        out_ccd_ymax = sr_ymax + 2.5

        # --坐标修正
        ccd_distance = out_ccd_xmax - out_ccd_xmin
        ccd_y_dis = profile_ymax * 0.5 - sr_ymin + 2.5
        if ccd_distance < 120:
            # --TODO CCD Symbol X间距不够120mm，跑完后请检查ccd.
            pass
        if ccd_y_dis < 320:
            pn_eight = self.JOB[7]
            if pn_eight in ["h", "y", "r", "l", "s"]:
                out_ccd_ymin = sr_ymin - 2.5 - 1.2
                out_ccd_ymax = sr_ymax + 2.5 + 1.2

        if sel_jsz == "是":
            # --如果是金手指板需要就CCD靶标往板外移动1.3-1.5
            out_ccd_ymin -= 1.3
            out_ccd_ymax += 1.3
        rect_sym = 'rect4000x4000'
        # out_ccd_x_wn,out_ccd_y_wn = out_ccd_xmin,out_ccd_ymax
        area_xmin_w = out_ccd_xmin - 2.0
        if area_xmin_w < sr_xmin:            
            out_ccd_xmin = sr_xmin + 6 - other_fd_h
            area_xmin_w = out_ccd_xmin - 2.0
            
        area_xmax_w = profile_xmax * 0.5 - 60
        out_ccd_x_wn, out_ccd_y_wn = self.optimize_coord(rect_sym, x=out_ccd_xmin, y=out_ccd_ymax,
                                                         area_xmin=area_xmin_w,
                                                         area_xmax=area_xmax_w)
        area_xmin_e = profile_xmax * 0.5 + 60
        area_xmax_e = out_ccd_xmax + 2.0
        if area_xmax_e > sr_xmax:
            out_ccd_xmax = sr_xmax - 6 + other_fd_h
            area_xmax_e = out_ccd_xmax + 2
            
            
        out_ccd_x_en, out_ccd_y_en = self.optimize_coord(rect_sym, x=out_ccd_xmax, y=out_ccd_ymax,
                                                         area_xmin=area_xmin_e,
                                                         area_xmax=area_xmax_e)
            
        out_ccd_x_es, out_ccd_y_es = self.optimize_coord(rect_sym, x=out_ccd_xmax, y=out_ccd_ymin,
                                                         area_xmin=area_xmin_e,
                                                         area_xmax=area_xmax_e)
        
        out_ccd_x_ws, out_ccd_y_ws = self.optimize_coord(rect_sym, x=out_ccd_x_wn + 3 + pin_fd_h, y=out_ccd_ymin,
                                                         area_xmin=out_ccd_x_wn - 2 + 3 + pin_fd_h,
                                                         area_xmax=area_xmax_w)

        # out_ccd_x_ws = out_ccd_xmin
        # out_ccd_y_ws = out_ccd_ymin
        # 周涌通知 要保持直角梯形  此处不一致时要调整下 20240527 by lyh
        if out_ccd_x_en <> out_ccd_x_es:
            out_ccd_x_es = out_ccd_x_en

        # --坐标列表定义
        out_ccdx_array = [out_ccd_x_wn, out_ccd_x_en, out_ccd_x_es, out_ccd_x_ws]
        out_ccdy_array = [out_ccd_ymax, out_ccd_ymax, out_ccd_ymin, out_ccd_ymin]
        if flow_content == "一次铜":
            pol_array_out = ['negative', 'negative', 'negative', 'negative']
        else:
            pol_array_out = ['positive', 'positive', 'positive', 'positive']

        # --收集到坐标信息后生成info
        info = {
            '外层c': self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='sh-dwtop2013',
                                        polarity=pol_array_out),
            '外层s': self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='sh-dwbot2013',
                                        polarity=pol_array_out),
            '选化c': self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='sh-dwtop2013'),
            '选化s': self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='sh-dwbot2013'),
            '化金c': self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='sh-dwtop2013'),
            '化金s': self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='sh-dwbot2013'),
            # '蚀刻引线c': self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='sh-dwtop2013',
            #                               polarity='negative'),
            # '蚀刻引线s': self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='sh-dwbot2013',
            #                               polarity='negative'),
            '通孔': self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='r3175'),
        }

        if hdi_num < 1 or not [i for i in blind_burry_by_lamin if
                               int(i.cur_yh_num) == yh_num and hasattr(i, 'blindLayer')]:
            # === 2021.09.17 通孔板，使用钻孔的四孔对位 ===
            info['外层c'].extend(self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='r0',
                                                    attribute='.fiducial_name,text=317.reg'))
            info['外层s'].extend(self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='r0',
                                                    attribute='.fiducial_name,text=317.reg'))
            info['蚀刻引线c']=self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='r0',
                                                      attribute='.fiducial_name,text=317.reg')
            info['蚀刻引线s']=self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='r0',
                                                      attribute='.fiducial_name,text=317.reg')

        if add_first_plant == "no":
            info['防焊c'] = self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='s4430',
                                               polarity='negative')
            info['防焊s'] = self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='s4430',
                                               polarity='negative')
        # --档点 2021.08.06 更改为直接加挡油pad
        info['档点'] = self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='r3683')
        if job_signal_numbers == 2:
            # --双面板防焊在外层ccd位置加r3175圆pad,add_lyd_change
            info['防焊'] = self.convert_to_dict(x_list=out_ccdx_array, y_list=out_ccdy_array, symbol='r3175')
        return info
    
    #def change_symbol(self):
        #self.GEN.PAUSE("ddd")
    
class inner_vrs_laser_barcode_surface(STATIC_SYM):
    """
    静态
    内层增加镭射打码铜皮区
    此打码位置加两次 铺铜后固定加一次  后续动态加一次
    若动态加成功则删除 固定加的
    http://192.168.2.120:82/zentao/story-view-6482.html
    """
    priority = 0.1    
    
    def __init__(self, frozen_json=None, priority=0.1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:字典的列表，保持symbol的添加顺序
        :rtype:list of dict
        """
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        profile_xmax = self.parm.profile_xmax
        profile_xmin = self.parm.profile_xmin
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        
        # --原始坐标定义
        info = {}
        
        if profile_ymax <= 622.5:
            # 左下角短边            
            area_xmin = profile_xmin + 130
            area_xmax = profile_xmax - 130
            area_ymax = sr_ymin - 4
            area_ymin = profile_ymin + (profile_ymax - rout_y) * 0.5 + 0.5
            fx = "X"
            step_x = 0.5
            step_y = 0.5
            symbolname = "rect30000x7000"
            neg_symbolname = "rect30500x7500"
            add_x = profile_xmin + 130 + 15
            add_y = profile_ymin + (profile_ymax - rout_y) * 0.5 + 3.5
        else:
            # 左下角长边            
            area_xmax = sr_xmin - 4
            area_xmin = profile_xmin + (profile_xmax - rout_x) * 0.5 + 0.5
            area_ymax = profile_ymax - 130
            area_ymin = profile_ymin + 130
            fx = "Y"
            step_x = 0.5
            step_y = -0.5
            symbolname = "rect7000x30000"
            neg_symbolname = "rect7500x30500"
            add_x = profile_xmin + (profile_xmax - rout_x) * 0.5 + 3.5
            add_y = profile_ymin + 130 + 15         
            
        #rect_area = self.optimize_coord_find_area_rect(symbolname, x=add_x, y=add_y, area_xmin=area_xmin,
                                                       #area_xmax=area_xmax,area_ymin=area_ymin, area_ymax=area_ymax,
                                                       #move_fx=fx, move_x_step=step_x, move_y_step=step_y, 
                                                       #return_rect="yes",include_rect=None,
                                                       #four_corner2ll="no",to_feature_size=0.5)
        
        #if "-lyh" in self.JOB:
            #job = gClasses.Job(self.JOB)
            #step = gClasses.Step(job, "panel")
            #step.removeLayer("laser_area_tmp")
            #step.createLayer("laser_area_tmp")
            #step.clearAll()
            #step.affect("laser_area_tmp")
            #step.addRectangle(area_xmin, area_ymin, area_xmax, area_ymax)
            #for x, y, rect in rect_area:
                #step.addPad(x, y, symbolname)            
            ## step.PAUSE(str(rect_area))
            
        # for x, y, rect in rect_area:
        info['内层'] = self.convert_to_dict(x_list=[add_x], y_list=[add_y], symbol=neg_symbolname,
                                              polarity='negative', attribute='.string,text=vrs_laser_barcode_area_static')
        info['内层'].extend(self.convert_to_dict(x_list=[add_x], y_list=[add_y], symbol=symbolname,
                                                  polarity='positive', attribute='.string,text=vrs_laser_barcode_area_static'))
      

        return info
    
class inner_vrs_laser_barcode_surface_new(DYNAMIC_SYM):
    """
    动态
    内层增加镭射打码铜皮区
    此打码位置加两次 铺铜后固定加一次  后续动态加一次
    若动态加成功则删除 固定加的
    http://192.168.2.120:82/zentao/story-view-6482.html
    """
    priority = 100

    def __init__(self, frozen_json=None, avoidArea=None, priority=100):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:字典的列表，保持symbol的添加顺序
        :rtype:list of dict
        """
        sr_xmin = self.parm.sr_xmin
        sr_ymin = self.parm.sr_ymin
        sr_ymax = self.parm.sr_ymax
        profile_xmax = self.parm.profile_xmax
        profile_xmin = self.parm.profile_xmin
        profile_ymax = self.parm.profile_ymax
        profile_ymin = self.parm.profile_ymin
        rout_x = self.parm.rout_x
        rout_y = self.parm.rout_y
        
        # --原始坐标定义
        info = {}
        
        if profile_ymax <= 622.5:
            # 左下角短边            
            area_xmin = profile_xmin + 130
            area_xmax = profile_xmax - 130
            area_ymax = sr_ymin - 4
            area_ymin = profile_ymin + (profile_ymax - rout_y) * 0.5 + 0.5
            fx = "X"
            step_x = 0.5
            step_y = 0.5
            symbolname = "rect30000x7000"
            neg_symbolname = "rect30500x7500"
            add_x = profile_xmin + 130 + 15
            add_y = profile_ymin + (profile_ymax - rout_y) * 0.5 + 3.5
        else:
            # 左下角长边            
            area_xmax = sr_xmin - 4
            area_xmin = profile_xmin + (profile_xmax - rout_x) * 0.5 + 0.5
            area_ymax = profile_ymax - 130
            area_ymin = profile_ymin + 130
            fx = "Y"
            step_x = 0.5
            step_y = -0.5
            symbolname = "rect7000x30000"
            neg_symbolname = "rect7500x30500"
            add_x = profile_xmin + (profile_xmax - rout_x) * 0.5 + 3.5
            add_y = profile_ymin + 130 + 15         
            
        rect_area = self.optimize_coord_find_area_rect(symbolname, x=add_x, y=add_y, area_xmin=area_xmin,
                                                       area_xmax=area_xmax,area_ymin=area_ymin, area_ymax=area_ymax,
                                                       move_fx=fx, move_x_step=step_x, move_y_step=step_y, 
                                                       return_rect="yes",include_rect=None,
                                                       four_corner2ll="no",to_feature_size=0.5)
        
        #if "-lyh" in self.JOB:
            #job = gClasses.Job(self.JOB)
            #step = gClasses.Step(job, "panel")
            #step.removeLayer("laser_area_tmp")
            #step.createLayer("laser_area_tmp")
            #step.clearAll()
            #step.affect("laser_area_tmp")
            #step.addRectangle(area_xmin, area_ymin, area_xmax, area_ymax)
            #for x, y, rect in rect_area:
                #step.addPad(x, y, symbolname)            
            # step.PAUSE(str(rect_area))
            
        for x, y, rect in rect_area:
            info['内层'] = self.convert_to_dict(x_list=[x], y_list=[y], symbol=neg_symbolname,
                                                  polarity='negative', attribute='.string,text=vrs_laser_barcode_area_dynamic')
            info['内层'].extend(self.convert_to_dict(x_list=[x], y_list=[y], symbol=symbolname,
                                                  polarity='positive', attribute='.string,text=vrs_laser_barcode_area_dynamic'))
            break        

        return info
    
    def change_symbol(self):
        """检测是否动态symbol添加成功 则删除静态的"""
        job = gClasses.Job(self.JOB)
        step = gClasses.Step(job, "panel")
        step.open()
        
        step.clearAll()
        if innersignalLayers:            
            for worklayer in innersignalLayers:
                step.affect(worklayer)
            
            step.resetFilter()
            step.setAttrFilter(".string,text=vrs_laser_barcode_area_dynamic")
            step.selectAll()
            if step.featureSelected():
                step.selectNone()
                step.resetFilter()
                step.setAttrFilter(".string,text=vrs_laser_barcode_area_static")
                step.selectAll()
                if step.featureSelected():
                    step.selectDelete()
                    
        step.clearAll()

class silk_py(STATIC_SYM):
    """
    文字手动对位pad,长边四组，短边四组
    """

    def __init__(self, frozen_json=None, priority=4):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'outer'
        STATIC_SYM.__init__(self, priority=priority, avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:字典的列表，保持symbol的添加顺序
        :rtype:dict of list
        """
        # === 2021.08.16 周涌钉钉沟通，取消文字手动对位pad ===
        info = {}
        return info

        # --前置变量定义
        short_he_value = self.parm.short_he_value
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        other_fd_h = self.parm.right_fd_h
        other_fd_v = self.parm.right_fd_v
        right_fd_v = self.parm.right_fd_v
        right_fd_h = self.parm.right_fd_h

        # --坐标定义
        silk_py_ymax = sr_ymax
        silk_py_xmax = sr_xmax
        silk_py_ymin = sr_ymin
        silk_py_xmin = sr_xmin

        if short_he_value == "yes":
            silk_py_ymax = sr_ymax + 2.5
            silk_py_xmax = sr_xmax + 2.5
            silk_py_ymin = sr_ymin - 2.5
            silk_py_xmin = sr_xmin - 2.5
        else:
            silk_py_ymax = sr_ymax + 3
            silk_py_xmax = sr_xmax + 3
            silk_py_ymin = sr_ymin - 3
            silk_py_xmin = sr_xmin - 3

        silk_x1 = sr_xmin + 27.94 + other_fd_h
        silk_x2 = sr_xmax - 27.94 - other_fd_h
        silk_x3 = sr_xmin + 34.29 + other_fd_h
        silk_x4 = sr_xmax - 27.94 + right_fd_h

        silk_y1 = sr_ymax - 27.94 + other_fd_v
        silk_y1fd = sr_ymax - 27.94 - 3 + right_fd_v
        silk_y2 = sr_ymin + 30.48 - other_fd_v

        # --top面坐标字典定义
        silk_pyx_toparray = [silk_x1, silk_x4, silk_x2, silk_x3, silk_py_xmax, silk_py_xmax, silk_py_xmin, silk_py_xmin]
        silk_pyy_toparray = [silk_py_ymax, silk_py_ymax, silk_py_ymin, silk_py_ymin, silk_y1fd, silk_y2, silk_y2,
                             silk_y1]

        # silk_pyx_toparray = [silk_x_UL, silk_x_UR, silk_x_LR, silk_x_LL,
        #                      silk_py_xmax, silk_py_xmax, silk_py_xmin, silk_py_xmin]
        # silk_pyy_toparray = [silk_py_ymax, silk_py_ymax, silk_py_ymin, silk_py_ymin,
        #                      silk_y_UR, silk_y_LR, silk_y_LL, silk_y_UL]
        silk_pya_toparray = [0, 180, 180, 0, 90, 270, 270, 90]
        silk_pya_botarray = [0, 180, 180, 0, 90, 270, 270, 90]

        # --收集到坐标信息后生成top面info
        info = {
            '外层c': self.convert_to_dict(x_list=silk_pyx_toparray, y_list=silk_pyy_toparray, symbol='sh-qpsig3',
                                        angle=silk_pya_toparray),
            '防焊c': self.convert_to_dict(x_list=silk_pyx_toparray, y_list=silk_pyy_toparray, symbol='sh-qpsd',
                                        angle=silk_pya_toparray),
            '档点c': self.convert_to_dict(x_list=silk_pyx_toparray, y_list=silk_pyy_toparray, symbol='rect8539.48x2540',
                                        angle=silk_pya_toparray),
            '选化c': self.convert_to_dict(x_list=silk_pyx_toparray, y_list=silk_pyy_toparray, symbol='rect9251.2x3251.2',
                                        angle=silk_pya_toparray, polarity='negative'),
            '文字c': self.convert_to_dict(x_list=silk_pyx_toparray, y_list=silk_pyy_toparray, symbol='sh-qpsk',
                                        angle=silk_pya_toparray),
            '碳油c': self.convert_to_dict(x_list=silk_pyx_toparray, y_list=silk_pyy_toparray, symbol='sh-qpsk',
                                        angle=silk_pya_toparray),
        }

        # --s面的坐标在c面基础上防呆3mm
        silk_x1 = silk_x1 + 3;
        silk_x2 = silk_x2 - 3;
        silk_x3 = silk_x3 + 3;
        silk_x4 = silk_x4 - 3;
        silk_y1 = silk_y1 - 3;
        silk_y1fd = silk_y1fd - 3;
        silk_y2 = silk_y2 + 3;
        silk_pyx_botarray = [silk_x1, silk_x4, silk_x2, silk_x3, silk_py_xmax, silk_py_xmax, silk_py_xmin, silk_py_xmin]
        silk_pyy_botarray = [silk_py_ymax, silk_py_ymax, silk_py_ymin, silk_py_ymin, silk_y1fd, silk_y2, silk_y2,
                             silk_y1]
        # silk_pyx_botarray = [silk_x_UL, silk_x_UR, silk_x_LR, silk_x_LL, silk_py_xmax, silk_py_xmax, silk_py_xmin,
        #                      silk_py_xmin]
        # silk_pyy_botarray = [silk_py_ymax, silk_py_ymax, silk_py_ymin, silk_py_ymin, silk_y_UR, silk_y_LR, silk_y_LL,
        #                      silk_y_UL]

        # --收集到坐标信息后生成bot面info
        info['外层s'] = self.convert_to_dict(x_list=silk_pyx_botarray, y_list=silk_pyy_botarray, symbol='sh-qpsig3',
                                           angle=silk_pya_botarray)
        info['防焊s'] = self.convert_to_dict(x_list=silk_pyx_botarray, y_list=silk_pyy_botarray, symbol='sh-qpsd',
                                           angle=silk_pya_botarray)
        info['档点s'] = self.convert_to_dict(x_list=silk_pyx_botarray, y_list=silk_pyy_botarray,
                                           symbol='rect8539.48x2540', angle=silk_pya_botarray)
        info['选化s'] = self.convert_to_dict(x_list=silk_pyx_botarray, y_list=silk_pyy_botarray,
                                           symbol='rect9251.2x3251.2', angle=silk_pya_botarray, polarity='negative')
        info['文字s'] = self.convert_to_dict(x_list=silk_pyx_botarray, y_list=silk_pyy_botarray, symbol='sh-qpsk',
                                           angle=silk_pya_botarray)
        info['碳油s'] = self.convert_to_dict(x_list=silk_pyx_botarray, y_list=silk_pyy_botarray, symbol='sh-qpsk',
                                           angle=silk_pya_botarray)

        return info


class sh_dwsd(DYNAMIC_SYM):
    """
    防焊ccd
    """
    priority = 1

    def __init__(self, frozen_json=None, avoidArea=None, priority=1):
        self.parm = frozen_json
        self.priority = priority
        self.avoidType = 'all'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        """
        获取symbol添加时的坐标极性等相关信息
        :return:字典的列表，保持symbol的添加顺序
        :rtype:list of dict
        """
        # --前置变量定义
        sh_site = self.parm.sh_site
        top_after_margin = self.parm.top_after_margin
        sr_ymax = self.parm.sr_ymax
        sr_ymin = self.parm.sr_ymin
        sr_xmin = self.parm.sr_xmin
        sr_xmax = self.parm.sr_xmax
        other_fd_h = self.parm.right_fd_h
        right_fd_h = self.parm.right_fd_h
        other_fd_v = self.parm.right_fd_v
        right_fd_v = self.parm.right_fd_v
        board_thick = self.parm.board_thick
        profile_ymax = self.parm.profile_ymax
        add_hj_panel = self.parm.add_hj_panel
        add_px_panel = self.parm.add_px_panel
        add_ld_symbol = self.parm.add_ld_symbol

        silk_sym = 'sh-dwsd2014'
        # if add_hj_panel == "是":
        #     silk_sym = 'sh_silk_autodw_2020'
        # if add_px_panel == '是':
        #     silk_sym = 'sh_silk_autodw_2020'

        # --坐标定义
        silk_dw_ymax = sr_ymax + 2 + 1.2
        silk_dw_xmax = sr_xmax + 2 + 1.2
        silk_dw_ymin = sr_ymin - 2 - 1.2
        silk_dw_xmin = sr_xmin - 2 - 1.2

        silk_dw_x1 = sr_xmin + 50.8 + other_fd_h
        silk_dw_x2 = sr_xmax - 40.64 - other_fd_h

        # === V2.08 左下角有与CCD重合可能，改为动态坐标 ===
        silk_dw_x1,silk_dw_y_tmp = self.optimize_static('s3650', x_org=silk_dw_x1, y_org=silk_dw_ymin,
                                                           area_xmin=sr_xmin+5, area_xmax=sr_xmax/3)
        silk_dw_fdx2 = sr_xmax - 43.64 + right_fd_h
        if silk_dw_fdx2 < silk_dw_x2:
            silk_dw_fdx3 = silk_dw_fdx2 - 3.5
        else:
            silk_dw_fdx3 = silk_dw_fdx2 + 3.5

        silk_dw_y1 = sr_ymax - 38.1 + other_fd_v
        silk_dw_fdy1 = sr_ymax - 41.1 + right_fd_v
        # silk_dw_y2 = sr_ymin + 12.7 - other_fd_v
        silk_dw_y3 = sr_ymin + 7.62 + 7.5 + 2.5 - other_fd_v
        silk_dw_fdy2 = silk_dw_fdy1 + 3.5

        # === Y 方向的坐标有和备用标靶重合的可能，做上下移动
        silk_dw_x_tmp, silk_dw_fdy1 = self.optimize_static('s3650', x_org=silk_dw_xmax, y_org=silk_dw_fdy1,
                                                           area_ymin=(sr_ymax * 2 / 3), area_ymax=(silk_dw_fdy1 + 2))
        # silk_dw_x_tmp, silk_dw_y2 = self.optimize_static('s3650', x_org=silk_dw_xmax, y_org=silk_dw_y2,
        #                                                  area_ymin=(silk_dw_y2 - 2), area_ymax=(sr_ymax * 1 / 3))
        silk_dw_x_tmp, silk_dw_y3 = self.optimize_coord('s3650', x=silk_dw_xmin, y=silk_dw_y3, area_ymin=(silk_dw_y3 - 2),
                                                        area_ymax=(sr_ymax * 1 / 3), four_corner2ll='down')
        # silk_dw_x_tmp, silk_dw_y3 = self.optimize_static('s3650', x_org=silk_dw_xmin, y_org=silk_dw_y3,
        #                                                  area_ymin=(silk_dw_y3 - 2), area_ymax=(sr_ymax * 1 / 3))
        silk_dw_x_tmp, silk_dw_y1 = self.optimize_static('s3650', x_org=silk_dw_xmin, y_org=silk_dw_y1,
                                                         area_ymin=(sr_ymax * 2 / 3), area_ymax=(silk_dw_y1 + 2),
                                                         move_down='yes')

        # --定义坐标
        #silk_dwx_array = [silk_dw_x1, silk_dw_x1, silk_dw_x2, silk_dw_fdx2, silk_dw_xmax, silk_dw_xmax, silk_dw_xmin,
                          #silk_dw_xmin]
        #silk_dwy_array = [silk_dw_ymin, silk_dw_ymax, silk_dw_ymin, silk_dw_ymax, silk_dw_fdy1, silk_dw_y2, silk_dw_y3,
                          #silk_dw_y1]
        # 周涌通知防呆角位置c面跟s面要错开 顾此处先将防呆位置去掉 20230203 by lyh
        # 长边左下角和右下角要在一条直线上
        silk_dwx_array = [silk_dw_x1, silk_dw_x1, silk_dw_x2, silk_dw_xmax, silk_dw_xmin,silk_dw_xmin]
        silk_dwy_array = [silk_dw_ymin, silk_dw_ymax, silk_dw_ymin, silk_dw_y3, silk_dw_y3,silk_dw_y1]

        # === TODO V2.00 取消左上角的标靶向下添加 标靶会与dld重叠，由于dldL形定位使用左下角坐标，建立左下角map用于防呆
        # map_y1_list = [profile_ymax - silk_dw_y1,silk_dw_y2,silk_dw_y3]
        # map_x1_list = [silk_dw_xmin,silk_dw_xmin,silk_dw_xmin]
        map_y1_list = [silk_dw_y3, silk_dw_y3]
        map_x1_list = [silk_dw_xmin, silk_dw_xmin]
        # --20201015李家兴依据story-view-2035添加，小于0.4mm板厚，做s5000的档油pad
        if board_thick > 0.4:
            silk_dot = 's3454'
        else:
            silk_dot = 's5000'
        # --定义对应的初始层别,symbol字典,长边短边在防焊层不一样，故分成两个数组
        info = {
            '外层': self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol='sh-dwsig2014'),
            '次外层': self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol='s3429'),
            '化金': self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol='sh-dwsig2014'),
            '选化': self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol='sh-dwsig2014'),
            # '蚀刻引线': self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol='sh-dwsig2014'), # V2.11
            
            '防焊': self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol='sh-dwsd2014'),            
            '碳油': self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol='sh-dwsd2014'),
            
            '档点': self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol=silk_dot),
            '文字': self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol=silk_sym),
            
            #短长边错开防呆
            '外层c': self.convert_to_dict(x_list=[silk_dw_fdx2, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy1], symbol='sh-dwsig2014'),
            '次外层c': self.convert_to_dict(x_list=[silk_dw_fdx2, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy1], symbol='s3429'),
            '化金c': self.convert_to_dict(x_list=[silk_dw_fdx2, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy1], symbol='sh-dwsig2014'),
            '选化c': self.convert_to_dict(x_list=[silk_dw_fdx2, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy1], symbol='sh-dwsig2014'),
            '防焊c': self.convert_to_dict(x_list=[silk_dw_fdx2, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy1], symbol='sh-dwsd2014'),
            '碳油c': self.convert_to_dict(x_list=[silk_dw_fdx2, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy1], symbol='sh-dwsd2014'),
            
            '档点c': self.convert_to_dict(x_list=[silk_dw_fdx2, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy1], symbol=silk_dot),
            '文字c': self.convert_to_dict(x_list=[silk_dw_fdx2, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy1], symbol=silk_sym),
            
            '外层s': self.convert_to_dict(x_list=[silk_dw_fdx3, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy2], symbol='sh-dwsig2014'),
            '次外层s': self.convert_to_dict(x_list=[silk_dw_fdx3, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy2], symbol='s3429'),
            '化金s': self.convert_to_dict(x_list=[silk_dw_fdx3, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy2], symbol='sh-dwsig2014'),
            '选化s': self.convert_to_dict(x_list=[silk_dw_fdx3, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy2], symbol='sh-dwsig2014'),
            '防焊s': self.convert_to_dict(x_list=[silk_dw_fdx3, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy2], symbol='sh-dwsd2014'),
            '碳油s': self.convert_to_dict(x_list=[silk_dw_fdx3, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy2], symbol='sh-dwsd2014'),
            
            '档点s': self.convert_to_dict(x_list=[silk_dw_fdx3, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy2], symbol=silk_dot),
            '文字s': self.convert_to_dict(x_list=[silk_dw_fdx3, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy2], symbol=silk_sym),
            # end
            
            'panel_map': self.convert_to_dict(x_list=map_x1_list, y_list=map_y1_list, symbol='s3454')}
        
        # http://192.168.2.120:82/zentao/story-view-5815.html
        # 为省金，防焊ccd套开窗距线路靶标10mil20230724 by lyh
        # 由s4179 修改为s4470.4  -176mil  -ynh
        info['防焊'] = self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol='s4470.4',
                                          polarity='negative') + info['防焊']
        info['防焊c'] = self.convert_to_dict(x_list=[silk_dw_fdx2, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy1],
                                           symbol='s4470.4', polarity='negative') + info['防焊c']
        info['防焊s'] = self.convert_to_dict(x_list=[silk_dw_fdx3, silk_dw_xmax], y_list=[silk_dw_ymax, silk_dw_fdy2],
                                           symbol='s4470.4', polarity='negative') + info['防焊s']

        # http://192.168.2.120:82/zentao/story-view-6537.html 防焊对位靶点防焊设计变更 20240306 by lyh 追加一个symbol改为s3800
        # http://192.168.2.120:82/zentao/story-view-7179.html 防焊对位靶点防焊设计变更大小为s88mil  r2235.2 um ynh -20240719
        info['防焊'] = info['防焊'] + self.convert_to_dict(x_list=silk_dwx_array, y_list=silk_dwy_array, symbol='r2235.2',
                                                       polarity='positive')
        info['防焊c'] = info['防焊c'] + self.convert_to_dict(x_list=[silk_dw_fdx2, silk_dw_xmax],
                                                         y_list=[silk_dw_ymax, silk_dw_fdy1],
                                                         symbol='r2235.2', polarity='positive')
        info['防焊s'] = info['防焊s'] + self.convert_to_dict(x_list=[silk_dw_fdx3, silk_dw_xmax],
                                                         y_list=[silk_dw_ymax, silk_dw_fdy2],
                                                         symbol='r2235.2', polarity='positive')
        
        if add_ld_symbol == "是":
            # === 有镭雕时，用负片盖住文字pad，用于镭雕对位 ===
            info['文字'].extend(self.convert_to_dict(x_list=silk_dwx_array[:3], y_list=silk_dwy_array[:3],
                                                   symbol='s3400', polarity='negative'))
            info['文字c'].extend(self.convert_to_dict(x_list=[silk_dw_fdx2], y_list=[silk_dw_ymax],
                                                   symbol='s3400', polarity='negative'))
            info['文字s'].extend(self.convert_to_dict(x_list=[silk_dw_fdx3], y_list=[silk_dw_ymax],
                                                   symbol='s3400', polarity='negative'))            
        # --文字偏移测试pad上的r0改到防焊ccd上,长边左边两个右边一个
        #r0_top_xlist = [silk_dw_x1, silk_dw_x1, silk_dw_x2, silk_dw_fdx2]
        #r0_top_ylist = [silk_dw_ymin, silk_dw_ymax, silk_dw_ymin, silk_dw_ymax]
        
        r0_top_xlist = [silk_dw_x1, silk_dw_x1, silk_dw_x2]
        r0_top_ylist = [silk_dw_ymin, silk_dw_ymax, silk_dw_ymin]        

        info['防焊'].extend(self.convert_to_dict(x_list=r0_top_xlist, y_list=r0_top_ylist, symbol='r0',
                                               attribute='.fiducial_name,text=317.reg'))
        info['化金'].extend(self.convert_to_dict(x_list=r0_top_xlist, y_list=r0_top_ylist, symbol='r0',
                                               attribute='.fiducial_name,text=317.reg'))
        info['选化'].extend(self.convert_to_dict(x_list=r0_top_xlist, y_list=r0_top_ylist, symbol='r0',
                                               attribute='.fiducial_name,text=317.reg'))
        
        info['防焊c'].extend(self.convert_to_dict(x_list=[silk_dw_fdx2], y_list=[silk_dw_ymax], symbol='r0',
                                               attribute='.fiducial_name,text=317.reg'))
        info['化金c'].extend(self.convert_to_dict(x_list=[silk_dw_fdx2], y_list=[silk_dw_ymax], symbol='r0',
                                               attribute='.fiducial_name,text=317.reg'))
        info['选化c'].extend(self.convert_to_dict(x_list=[silk_dw_fdx2], y_list=[silk_dw_ymax], symbol='r0',
                                               attribute='.fiducial_name,text=317.reg'))
        
        info['防焊s'].extend(self.convert_to_dict(x_list=[silk_dw_fdx3], y_list=[silk_dw_ymax], symbol='r0',
                                               attribute='.fiducial_name,text=317.reg'))
        info['化金s'].extend(self.convert_to_dict(x_list=[silk_dw_fdx3], y_list=[silk_dw_ymax], symbol='r0',
                                               attribute='.fiducial_name,text=317.reg'))
        info['选化s'].extend(self.convert_to_dict(x_list=[silk_dw_fdx3], y_list=[silk_dw_ymax], symbol='r0',
                                               attribute='.fiducial_name,text=317.reg'))

        # 碱性蚀刻周涌要求蚀刻etch-c,etch-s层增加4颗靶，靶symbol为C面（sh-dwtop),反面（sh-dwbot)-dwsig2014位置
        # http://192.168.2.120:82/zentao/story-view-6782.html
        figer_dp_positive = self.parm.figer_dp_positive
        silk_dwx_array_etc = [silk_dw_x1, silk_dw_x1, silk_dw_x2, silk_dw_fdx2]
        silk_dwy_array_etc = [silk_dw_ymin, silk_dw_ymax, silk_dw_ymin, silk_dw_ymax]
        if figer_dp_positive == 'yes':
            for k_lay, v_sym in {'蚀刻引线c': 'sh-dwtop', '蚀刻引线s': 'sh-dwbot'}.items():
                if info.has_key(k_lay):
                    info[k_lay].extend(
                        self.convert_to_dict(x_list=silk_dwx_array_etc, y_list=silk_dwy_array_etc, symbol=v_sym, polarity='negative'))
                else:
                    info[k_lay] = self.convert_to_dict(x_list=silk_dwx_array_etc, y_list=silk_dwy_array_etc,
                                                       symbol=v_sym,polarity='negative')

        # --防焊加ccd间距
        dis_x2 = silk_dw_x2
        dis_x1 = silk_dw_x1
        dis_y2 = silk_dw_ymax
        dis_y1 = silk_dw_ymin
        film_x_value = dis_x2 - dis_x1
        film_y_value = dis_y2 - dis_y1
        film_x_value = "%.1f" % film_x_value
        film_y_value = "%.1f" % film_y_value
        film_dis_x = 130
        film_dis_y = -3
        text_x = 100
        text_content = 'X: %s Y: %s' % (film_x_value, film_y_value)
        text_y = -6
        text_x_bot = 166
        info['防焊c'].extend(self.convert_to_dict(x_list=[film_dis_x], y_list=[film_dis_y], symbol='rect80000x7000'))
        info['防焊c'].extend(self.convert_to_dict(x_list=[text_x], y_list=[text_y], text=text_content, x_size=4,
                                                y_size=4, w_factor=1.312335968, polarity='negative'))
        info['防焊s'].extend(self.convert_to_dict(x_list=[film_dis_x], y_list=[film_dis_y], symbol='rect80000x7000'))
        info['防焊s'].extend(self.convert_to_dict(x_list=[text_x_bot], y_list=[text_y], text=text_content, x_size=4,
                                                y_size=4, w_factor=1.312335968, polarity='negative', mirror='yes'))
        # --防焊对位点切铜
        return info

    def clip_copper(self):
        """
        防焊对位点切铜
        :return:
        :rtype:
        """
        pn_seven = self.JOB[6]

        if pn_seven != "g":
            return

        self.GEN.CLEAR_LAYER()
        self.GEN.COM('affected_filter,filter=(type=solder_mask&context=board&side=top|bottom)')
        self.GEN.COM('get_affect_layer')
        layers = self.GEN.COMANS.split()
        self.GEN.CLEAR_LAYER()
        for layer in layers:
            self.GEN.AFFECTED_LAYER(layer, 'yes')
            self.GEN.COM("filter_reset,filter_name=popup")
            # --20200831李家兴依据story-view-1933修改,增加了symbol sh-dwsd2020
            self.GEN.COM("filter_set,filter_name=popup,update_popup=no,include_syms=sh-dwsd2014\;sh-dwsd2020")
            self.GEN.COM("filter_area_strt")
            self.GEN.COM("filter_area_end,layer=,filter_name=popup,operation=select,area_type=none,inside_area=no,"
                         "intersect_area=no,lines_only=no,ovals_only=no,min_len=0,max_len=0,min_angle=0,max_angle=0")
            self.GEN.FILTER_SELECT()
            count = self.GEN.GET_SELECT_COUNT()
            if count > 0:
                self.GEN.SEL_COPY(layer+"_tmp_qie_tong")
                self.GEN.CLEAR_LAYER()
                self.GEN.AFFECTED_LAYER(layer+"_tmp_qie_tong", 'yes')
                self.GEN.SEL_CHANEG_SYM("s3500")
                
                self.GEN.CLEAR_LAYER()
                self.GEN.AFFECTED_LAYER(layer, 'yes')
                self.GEN.COM("clip_area_strt")
                self.GEN.COM("clip_area_end,layers_mode=affected_layers,layer=,area=reference,area_type=rectangle,"
                             "inout=inside,contour_cut=yes,margin=8000,ref_layer=%s,feat_types=surface" % (layer+"_tmp_qie_tong"))
                self.GEN.COM("delete_layer, layer=%s" % (layer+"_tmp_qie_tong"))
                
            self.GEN.COM("filter_reset,filter_name=popup")
            self.GEN.AFFECTED_LAYER(layer, 'no')


class long7short5(DYNAMIC_SYM):
    """
    添加长七短五的压合偏移对位pad
    """
    priority = 18

    def __init__(self, frozen_json=None, avoidArea=None, priority=18):
        self.parm = frozen_json
        self.priority = priority
        # self.avoidType = None
        self.avoidType = 'inner'
        DYNAMIC_SYM.__init__(self, frozen_json=frozen_json, avoidArea=avoidArea, priority=priority,
                             avoidType=self.avoidType)

    def get_sym_info(self):
        info = {}
        job_signal_numbers = self.parm.job_signal_numbers
        if job_signal_numbers < 4:
            return info
        lamination = self.parm.lamination
        core_count = self.parm.core_count
        pp3_layer = self.parm.pp3_layer
        yh_num = len(lamination)
        # 跑边程序优化，针对b58系列不区分融合板及非融合板，板边全加长7短5涨缩pad 20221115 by lyh
        # http://192.168.2.120:82/zentao/story-view-4499.html
        
        if core_count < 2 and len(pp3_layer) == 0:
            mode = 'long7short5'
        else:
            if self.JOB[1:4] == "b58" or self.JOB == 'H00022O6B52A1-test'.lower():
                mode = 'long7short5'
            else:                
                mode = 'middle_two_mode'                 

        tmp_map, cor_dict = self.add_map_pad(mode)
        if mode == 'middle_two_mode':
            # === 获取层别的坐标信息，以及rectpad大小，用于套铜
            feature_line = self.GEN.INFO("-t layer -e %s/%s/%s -d FEATURES, units=mm" % (self.JOB, 'panel', tmp_map))
            SF = SplitFeature()
            features_dict = SF.parseFeatureInfo(feature_line)
            # print  features_dict
            mid_two_x = [features_dict['pads'][l].x for l in range(len(features_dict['pads']))]
            mid_two_y = [features_dict['pads'][l].y for l in range(len(features_dict['pads']))]
            mid_symbol = [features_dict['pads'][l].symbol for l in range(len(features_dict['pads']))]
            mid_angle = [features_dict['pads'][l].rotation for l in range(len(features_dict['pads']))]
            attribute_middle_two = '.string,text=yh_py_pad'
            info['内层'] = self.convert_to_dict(x_list=mid_two_x, y_list=mid_two_y, symbol=mid_symbol,
                                              attribute=attribute_middle_two, polarity='negative', angle=mid_angle)
            mid_y_list = list(set(mid_two_y))
            mid_y = ''                
            if len(mid_y_list) == 1:
                mid_y = mid_y_list[0]
            else:
                return False
            # print mid_y
            for index, cur_lamin in enumerate(lamination, 1):
                (from_lyr, to_lyr) = (str(cur_lamin.FROMLAY).lower(), str(cur_lamin.TOLAY).lower())
                cur_yh = index
                from_id = int(from_lyr[1:])
                from_next = from_id + 1
                to_id = int(to_lyr[1:])
                to_pre = to_id - 1
                cur_add_y = mid_y - (yh_num - 1) * 0.5 * 5.08 + (cur_yh - 1) * 5.08

                self.GEN.AFFECTED_LAYER('l%s' % from_next, 'yes')
                self.GEN.AFFECTED_LAYER('l%s' % to_pre, 'yes')
                from_layer = 'l%s' % from_next
                to_layer = 'l%s' % to_pre
                if cur_yh == yh_num:
                    add_text = 't'
                else:
                    add_text = cur_yh
                add_sym = 'hdi1-by%s' % add_text
                cur_add_y_list = [cur_add_y, cur_add_y]
                if from_layer not in info:
                    info[from_layer] = self.convert_to_dict(x_list=mid_two_x, y_list=cur_add_y_list, symbol=add_sym,
                                                            attribute=attribute_middle_two)
                else:
                    info[from_layer].extend(
                        self.convert_to_dict(x_list=mid_two_x, y_list=cur_add_y_list, symbol=add_sym,
                                             attribute=attribute_middle_two))
                if to_layer not in info:
                    info[to_layer] = self.convert_to_dict(x_list=mid_two_x, y_list=cur_add_y_list, symbol=add_sym,
                                                          attribute=attribute_middle_two)
                else:
                    info[to_layer].extend(self.convert_to_dict(x_list=mid_two_x, y_list=cur_add_y_list, symbol=add_sym,
                                                               attribute=attribute_middle_two))
                if cur_yh == 1:
                    if to_pre - from_next > 1:
                        for tmp_ind in range(from_next + 1, to_pre - 1 + 1):
                            in_layer = 'l%s' % tmp_ind
                            if in_layer not in info:
                                info[in_layer] = self.convert_to_dict(x_list=mid_two_x, y_list=cur_add_y_list,
                                                                      symbol=add_sym,
                                                                      attribute=attribute_middle_two)
                            else:
                                info[in_layer].extend(
                                    self.convert_to_dict(x_list=mid_two_x, y_list=cur_add_y_list, symbol=add_sym,
                                                         attribute=attribute_middle_two))
        else:
            # === long7short5 ===
            # self.GEN.VOF ()
            # self.GEN.COM ("delete_layer, layer=%s" % tmp_add_inn_sym)
            #             # self.GEN.COM ("delete_layer, layer=%s" % tmp_map)
            #             # self.GEN.VON ()
            # self.GEN.CLEAR_LAYER ()
            # === 获取map层信息，并且分类
            vertical_startx = cor_dict['vertical_startx']
            vertical_dx = cor_dict['vertical_dx']
            vertical_ylist = cor_dict['vertical_ylist']

            horizontal_starty = cor_dict['horizontal_starty']
            horizontal_xlist = cor_dict['horizontal_xlist']
            horizontal_dy = cor_dict['horizontal_dy']

            attribute_add = '.string,text=yh_py_pad'

            add_sym = 's2541'
            ver_x_list = []
            ver_y_list = []
            for add_verY in vertical_ylist:
                team_starty = add_verY - (yh_num - 1) / 2 * 2.54 - (yh_num - 1) / 2 * 0.2
                team_dy = 2.740
                ver_x_list += [vertical_startx] * yh_num
                ver_x_list += [vertical_startx + vertical_dx * 0.001] * yh_num
                ver_y_list += [(team_starty + i * team_dy) for i in range(yh_num)]
                # === 需添加两次Y坐标
                ver_y_list += [(team_starty + i * team_dy) for i in range(yh_num)]

            hor_x_list = []
            hor_y_list = []
            for add_verX in horizontal_xlist:
                team_startx = add_verX - (yh_num - 1) / 2 * 2.54 - (yh_num - 1) / 2 * 0.2
                team_dx = 2.740
                hor_x_list += [(team_startx + i * team_dx) for i in range(yh_num)]
                # === 需添加两次X坐标
                hor_x_list += [(team_startx + i * team_dx) for i in range(yh_num)]
                hor_y_list += [horizontal_starty] * yh_num
                hor_y_list += [horizontal_starty + horizontal_dy * 0.001] * yh_num

            all_x = ver_x_list + hor_x_list
            all_y = ver_y_list + hor_y_list
            info['内层'] = self.convert_to_dict(x_list=all_x, y_list=all_y, symbol=add_sym, attribute=attribute_add,
                                              polarity='negative')

            for index, cur_lamin in enumerate(lamination, 1):
                (from_lyr, to_lyr) = (str(cur_lamin.FROMLAY).lower(), str(cur_lamin.TOLAY).lower())
                cur_yh = index
                from_id = int(from_lyr[1:])
                from_next = from_id + 1
                to_id = int(to_lyr[1:])
                to_pre = to_id - 1
                from_layer = 'l%s' % from_next
                to_layer = 'l%s' % to_pre
                add_x_list = []
                add_y_list = []
                add_text_x_list = []
                add_text_y_list = []
                add_sym = 'r1524'

                if cur_yh == 1:
                    if to_pre - from_next > 1:
                        for tmp_ind in range(from_next + 1, to_pre - 1 + 1):
                            self.GEN.AFFECTED_LAYER('l%s' % tmp_ind, 'yes')
                if cur_yh == yh_num:
                    add_text = 'T'
                else:
                    add_text = cur_yh

                for add_verY in vertical_ylist:
                    cur_add_y = add_verY - (yh_num - 1) / 2 * 2.54 - (yh_num - 1) / 2 * 0.2 + (cur_yh - 1) * 2.54 + (
                            cur_yh - 1) * 0.2
                    add_text_x1 = vertical_startx + 0.825
                    add_text_x2 = vertical_startx + vertical_dx * 0.001 + 0.825
                    add_text_y = cur_add_y - 1.24
                    add_text_x_list += [add_text_x1, add_text_x2]
                    add_text_y_list += [add_text_y, add_text_y]
                    add_x_list += [vertical_startx, vertical_startx + vertical_dx * 0.001]
                    add_y_list += [cur_add_y, cur_add_y]

                for add_verX in horizontal_xlist:
                    cur_add_x = add_verX - (yh_num - 1) / 2 * 2.54 - (yh_num - 1) / 2 * 0.2 + (cur_yh - 1) * 2.54 + (
                            cur_yh - 1) * 0.2
                    add_text_x = cur_add_x + 0.825
                    add_text_y1 = horizontal_starty - 1.24
                    add_text_y2 = horizontal_starty + horizontal_dy * 0.001 - 1.24
                    add_x_list += [cur_add_x, cur_add_x]
                    add_y_list += [horizontal_starty, horizontal_starty + horizontal_dy * 0.001]
                    add_text_x_list += [add_text_x, add_text_x]
                    add_text_y_list += [add_text_y1, add_text_y2]

                if from_layer not in info:
                    info[from_layer] = self.convert_to_dict(x_list=add_x_list, y_list=add_y_list, symbol=add_sym,
                                                            attribute=attribute_add)
                else:
                    info[from_layer].extend(self.convert_to_dict(x_list=add_x_list, y_list=add_y_list, symbol=add_sym,
                                                                 attribute=attribute_add))
                if to_layer not in info:
                    info[to_layer] = self.convert_to_dict(x_list=add_x_list, y_list=add_y_list, symbol=add_sym,
                                                          attribute=attribute_add)
                else:
                    info[to_layer].extend(self.convert_to_dict(x_list=add_x_list, y_list=add_y_list, symbol=add_sym,
                                                               attribute=attribute_add))
                info[from_layer].extend(self.convert_to_dict(x_list=add_text_x_list, y_list=add_text_y_list,
                                                             text=add_text, x_size=0.508, y_size=0.635, w_factor=0.5,
                                                             attribute=attribute_add))
                info[to_layer].extend(self.convert_to_dict(x_list=add_text_x_list, y_list=add_text_y_list,
                                                           text=add_text, x_size=0.508, y_size=0.635, w_factor=0.5,
                                                           attribute=attribute_add))
                if cur_yh == 1:
                    if to_pre - from_next > 1:
                        for tmp_ind in range(from_next + 1, to_pre - 1 + 1):
                            in_layer = 'l%s' % tmp_ind
                            if in_layer not in info:
                                info[in_layer] = self.convert_to_dict(x_list=add_x_list, y_list=add_y_list,
                                                                      symbol=add_sym,
                                                                      attribute=attribute_add)
                            else:
                                info[in_layer].extend(
                                    self.convert_to_dict(x_list=add_x_list, y_list=add_y_list, symbol=add_sym,
                                                         attribute=attribute_add))
                            info[in_layer].extend(
                                self.convert_to_dict(x_list=add_text_x_list, y_list=add_text_y_list, text=add_text,
                                                     x_size=0.508, y_size=0.635, w_factor=0.5, attribute=attribute_add))
        return info

    def add_map_pad(self, add_mode):
        """
        通过内层已经添加的标靶，生成map层，供get_sym_info函数生成添加标靶的基准位置
        :return:
        """
        tmp_add_inn_sym = '__tmpallinnsym__'
        tmp_map = '__tmp_yh_map__'
        self.GEN.VOF()
        self.GEN.COM("delete_layer, layer=%s" % tmp_add_inn_sym)
        self.GEN.COM("delete_layer, layer=%s" % tmp_map)
        self.GEN.VON()
        self.GEN.CREATE_LAYER(tmp_map)
        self.GEN.CLEAR_LAYER()
        # === 内层pad参考层建立===
        self.GEN.COM('affected_filter,filter=(side=inner)')
        self.GEN.FILTER_RESET()
        self.GEN.FILTER_SET_TYP('pad\;text')
        self.GEN.FILTER_SELECT()
        if int(self.GEN.GET_SELECT_COUNT()) > 0:
            self.GEN.SEL_COPY(tmp_add_inn_sym)
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(tmp_add_inn_sym, 'yes')
        self.GEN.FILTER_RESET()
        # === 2021.06.28 屏蔽板边铺铜模块 panel_symbol_top0 panel_symbol_bot0 ===
        self.GEN.FILTER_SET_INCLUDE_SYMS('panel_symbol*')
        self.GEN.FILTER_SELECT()
        if int(self.GEN.GET_SELECT_COUNT()) > 0:
            self.GEN.SEL_DELETE()
        self.GEN.CLEAR_LAYER()
        cor_dict = {}
        if add_mode == 'middle_two_mode':
            self.middle_two_mode(tmp_add_inn_sym, tmp_map)
        elif add_mode == 'long7short5':
            cor_dict = self.long7short5_mode(tmp_add_inn_sym, tmp_map)

        return tmp_map, cor_dict

    def middle_two_mode(self, tmp_add_inn_sym, tmp_map):
        """
        中间两组模式
        :param tmp_add_inn_sym:
        :param tmp_map:
        :return:
        """
        panel_y_max = self.parm.profile_ymax
        panel_x_max = self.parm.profile_xmax
        # rout_y = self.parm.rout_y
        lamination = self.parm.lamination
        yh_num = len(lamination)
        gm_array = self.parm.gm_array
        # ===  cut_y 待转化为次外层的干膜尺寸，parameter.json 中是否有这个
        # cut_y = (panel_y_max - rout_y) * 0.5
        cut_y = min([i.gm_starty for i in gm_array if i.lamin_num != yh_num])

        rect_length = 2540 * yh_num + 200 * (yh_num - 1)
        # rect_width = 2540
        add_mid_sym = 'rect%sx%s' % ((5080 * yh_num), 5080)

        # === 2021.06.28 X方向坐标和已经添加的标靶相同 ===
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(tmp_add_inn_sym, 'yes')
        self.GEN.FILTER_RESET()
        self.GEN.FILTER_SET_TYP('pad')
        self.GEN.FILTER_SET_INCLUDE_SYMS("hdi1-ba*\;hdi1-by*")
        self.GEN.FILTER_SELECT()
        self.GEN.FILTER_RESET()

        feature_line = self.GEN.INFO(
            "-t layer -e %s/%s/%s -d FEATURES -o select, units=mm" % (self.JOB, 'panel', tmp_add_inn_sym))
        SF = SplitFeature()
        features_dict = SF.parseFeatureInfo(feature_line)
        # print  features_dict
        xlist = [features_dict['pads'][l].x for l in range(len(features_dict['pads']))]
        # print  xlist
        vertical_startx = min(xlist)
        vertical_dx = (panel_x_max - 2 * vertical_startx) * 1000
        # === 取这两个坐标的x的最小值及最大值，用于确定使用哪个X坐标 ===
        # === self.rect_length 长度为2.54大小的标靶，此标靶更长所以两倍计算 ===
        vertical_y_limit = panel_y_max - cut_y - 2 - rect_length * 0.5 * 0.001 * 2

        mid_y = panel_y_max * 0.5
        # vertical_x_times = int((sr_x_min - self.cut_x - 2 - 2) / 5.08)
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(tmp_map, 'yes')

        self.GEN.COM("add_pad,attributes=no,x=%s,y=%s,symbol=%s,polarity=positive,angle=90,mirror=no,nx=2,ny=1,dx=%s,"
                     "dy=1,xscale=1,yscale=1" % (vertical_startx, mid_y, add_mid_sym, vertical_dx))
        self.GEN.FILTER_RESET()
        self.GEN.SEL_REF_FEAT(tmp_add_inn_sym, 'touch')
        current_num = int(self.GEN.GET_SELECT_COUNT())
        if current_num == 0:
            self.GEN.COM('sel_clear_feat')
            # self.GEN.SEL_DELETE ()
        cur_y = mid_y
        while current_num != 0:
            self.GEN.COM('sel_clear_feat')
            move_step = rect_length * 0.001
            cur_y = cur_y + move_step
            # === 大于限制的干膜尺寸时跳出循环 ===
            if cur_y > vertical_y_limit:
                msg_dict = {'type': 'critical',
                            'windowTitle': '警告',
                            'content': '压合涨缩（压合偏移）中间标靶，无法自动移动合适位置!'}
                self.msg_array.append(msg_dict)
                break
            self.GEN.COM('sel_transform, mode=anchor, oper=, duplicate=no, x_anchor=0, y_anchor=0, angle=0, '
                         'x_scale=1, y_scale=1, x_offset=0, y_offset=%s' % move_step)
            self.GEN.SEL_REF_FEAT(tmp_add_inn_sym, 'touch')
            current_num = int(self.GEN.GET_SELECT_COUNT())
        if current_num == 0:
            mid_y = cur_y
        self.GEN.COM('sel_clear_feat')
        # self.GEN.SEL_DELETE ()
        return True

    def long7short5_mode(self, tmp_add_inn_sym, tmp_map):
        """
        长七短五模式（非四层板及熔合板）
        :param tmp_add_inn_sym:
        :param tmp_map:
        :return:
        """
        panel_y_max = self.parm.profile_ymax
        panel_x_max = self.parm.profile_xmax
        sr_x_min = self.parm.sr_xmin
        sr_lenth = self.parm.sr_lenth
        sr_y_min = self.parm.sr_ymin
        sr_width = self.parm.sr_width
        # rout_x = self.parm.rout_x
        # rout_y = self.parm.rout_y
        lamination = self.parm.lamination
        gm_array = self.parm.gm_array

        # all_signal_array = self.parm.all_signal_array
        yh_num = len(lamination)
        # === cut_x cut_y 待转化为次外层的干膜尺寸，parameter.json 中是否有这个
        # cut_x = (panel_x_max - rout_x) * 0.5
        # cut_y = (panel_y_max - rout_y) * 0.5
        cut_x = max([i.gm_startx for i in gm_array if i.lamin_num != yh_num])
        cut_y = max([i.gm_starty for i in gm_array if i.lamin_num != yh_num])

        rect_length = 2540 * yh_num + 200 * (yh_num - 1)
        rect_width = 2540
        addmapsym = 'rect%sx%s' % (rect_length, rect_width)

        # === 长边7组原始坐标定义 ===
        step_y = (panel_y_max - 100) / 6
        vertical_ylist = []
        for index in range(0, 7, 1):
            vertical_y = 50 + index * step_y
            vertical_ylist.append(vertical_y)
        # print json.dumps(vertical_ylist)
        # === 短边5组原始坐标定义 ===
        step_x = (panel_x_max - 100) / 4
        horizontal_xlist = []
        for index in range(0, 5, 1):
            horizontal_x = 50 + index * step_x
            horizontal_xlist.append(horizontal_x)
        # === 先确定长7短5 的长边在X方向有几个移动位置 ===
        # === 获取最小捞边，并-4mm认为为最小添加位置 ===

        vertical_x_times = int((sr_x_min - cut_x - 2 - 2) / 2.54)
        # print '$vertical_x_times: %s' % vertical_x_times
        vertical_y_limit = panel_y_max - cut_y - 2 - rect_length * 0.5 * 0.001
        horizontal_x_limit = panel_x_max - cut_x - 2 - rect_length * 0.5 * 0.001
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(tmp_map, 'yes')
        min_touch_time = 1
        min_touch_num = 9999
        for cur_index in range(1, vertical_x_times + 1):
            dx = (sr_lenth + 3.5 + 3.5 + (cur_index - 1) * 2 * 2.54) * 1000
            vertical_startx = sr_x_min - 3.5 - (cur_index - 1) * 2.54
            dy = step_y * 1000
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=%s,polarity=positive,angle=90,mirror=no,nx=2,ny=7,dx=%s,"
                "dy=%s,xscale=1,yscale=1" % (vertical_startx, vertical_ylist[0], addmapsym, dx, dy))
            self.GEN.FILTER_RESET()
            self.GEN.SEL_REF_FEAT(tmp_add_inn_sym, 'touch')
            current_num = int(self.GEN.GET_SELECT_COUNT())
            # print '$cur_index: %s' % cur_index
            # print '$current_num : %s' % current_num
            if current_num < min_touch_num:
                min_touch_num = current_num
                min_touch_time = cur_index
            self.GEN.COM('sel_clear_feat')
            self.GEN.SEL_DELETE()

        dx = (sr_lenth + 3.5 + 3.5 + (min_touch_time - 1) * 2 * 2.54) * 1000
        vertical_startx = sr_x_min - 3.5 - (min_touch_time - 1) * 2.54
        vertical_dx = (sr_lenth + 3.5 + 3.5 + (min_touch_time - 1) * 2 * 2.54) * 1000
        dy = step_y * 1000
        for cur_index in range(0, 7):
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=%s,polarity=positive,angle=90,mirror=no,nx=2,ny=1,dx=%s,"
                "dy=%s,xscale=1,yscale=1" % (vertical_startx, vertical_ylist[cur_index], addmapsym, dx, dy))
            self.GEN.FILTER_RESET()
            self.GEN.SEL_REF_FEAT(tmp_add_inn_sym, 'touch')
            current_num = int(self.GEN.GET_SELECT_COUNT())
            if current_num == 0:
                self.GEN.COM('sel_clear_feat')
                self.GEN.SEL_DELETE()
            cur_y = vertical_ylist[cur_index]
            while current_num != 0:
                self.GEN.COM('sel_clear_feat')
                move_step = rect_length * 0.001
                cur_y = cur_y + move_step
                # === 大于限制的干膜尺寸时跳出循环 ===
                if cur_index == 6:
                    if cur_y > vertical_y_limit:
                        # text = "压合涨缩（压合偏移长7短5）长边第%s组，无法自动移动合适位置!" % int(cur_index + 1)
                        # msg_box = msgBox ()
                        # msg_box.warning (self, '警告', '%s' % text, QtGui.QMessageBox.Ok)
                        msg_dict = {'type': 'critical',
                                    'windowTitle': '警告',
                                    'content': "压合涨缩（压合偏移长7短5）长边第%s组，无法自动移动合适位置!" % int(cur_index + 1)}
                        self.msg_array.append(msg_dict)
                        break
                else:
                    if cur_y + move_step > vertical_ylist[cur_index + 1]:
                        # text = "长边第%s组，无法自动移动合适位置!" % int (cur_index + 1)
                        # msg_box = msgBox ()
                        # msg_box.warning (self, '警告', '%s' % text, QtGui.QMessageBox.Ok)
                        msg_dict = {'type': 'critical',
                                    'windowTitle': '警告',
                                    'content': "压合涨缩（压合偏移长7短5）长边第%s组，无法自动移动合适位置!" % int(cur_index + 1)}
                        self.msg_array.append(msg_dict)
                        break
                self.GEN.COM('sel_transform, mode=anchor, oper=, duplicate=no, x_anchor=0, y_anchor=0, angle=0, '
                             'x_scale=1, y_scale=1, x_offset=0, y_offset=%s' % move_step)
                self.GEN.SEL_REF_FEAT(tmp_add_inn_sym, 'touch')
                current_num = int(self.GEN.GET_SELECT_COUNT())

            if current_num == 0:
                vertical_ylist[cur_index] = cur_y
            self.GEN.COM('sel_clear_feat')
            self.GEN.SEL_DELETE()
        # print vertical_ylist

        # === 短边五组 ===
        horizontal_y_times = int((sr_y_min - cut_y - 2 - 2) / 2.54)
        # print 'horizontal_y_times: %s' % horizontal_y_times
        self.GEN.CLEAR_LAYER()
        self.GEN.AFFECTED_LAYER(tmp_map, 'yes')
        min_touch_time = 1
        min_touch_num = 9999
        for cur_index in range(1, horizontal_y_times + 1):
            dy = (sr_width + 3.5 + 3.5 + (cur_index - 1) * 2 * 2.54) * 1000
            horizontal_starty = sr_y_min - 3.5 - (cur_index - 1) * 2.54
            dx = step_x * 1000
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=%s,polarity=positive,angle=0,mirror=no,nx=5,ny=2,dx=%s,"
                "dy=%s,xscale=1,yscale=1" % (horizontal_xlist[0], horizontal_starty, addmapsym, dx, dy))
            self.GEN.FILTER_RESET()
            self.GEN.SEL_REF_FEAT(tmp_add_inn_sym, 'touch')
            current_num = int(self.GEN.GET_SELECT_COUNT())
            if current_num < min_touch_num:
                min_touch_num = current_num
                min_touch_time = cur_index
            self.GEN.COM('sel_clear_feat')
            self.GEN.SEL_DELETE()

        dy = (sr_width + 3.5 + 3.5 + (min_touch_time - 1) * 2 * 2.54) * 1000
        horizontal_starty = sr_y_min - 3.5 - (min_touch_time - 1) * 2.54
        horizontal_dy = (sr_width + 3.5 + 3.5 + (min_touch_time - 1) * 2 * 2.54) * 1000

        dx = step_x * 1000
        for cur_index in range(0, 5):
            self.GEN.COM(
                "add_pad,attributes=no,x=%s,y=%s,symbol=%s,polarity=positive,angle=0,mirror=no,nx=1,ny=2,dx=%s,"
                "dy=%s,xscale=1,yscale=1" % (horizontal_xlist[cur_index], horizontal_starty, addmapsym, dx, dy))
            self.GEN.FILTER_RESET()
            self.GEN.SEL_REF_FEAT(tmp_add_inn_sym, 'touch')
            current_num = int(self.GEN.GET_SELECT_COUNT())
            if current_num == 0:
                self.GEN.COM('sel_clear_feat')
                self.GEN.SEL_DELETE()
            cur_x = horizontal_xlist[cur_index]
            while current_num != 0:
                self.GEN.COM('sel_clear_feat')
                move_step = rect_length * 0.001
                cur_x = cur_x + move_step
                # === 大于限制的干膜尺寸时跳出循环 ===
                if cur_index == 4:
                    if cur_x + move_step > horizontal_x_limit:
                        # text = "短边第%s组，无法自动移动合适位置!" % int(cur_index + 1)
                        # msg_box = msgBox ()
                        # msg_box.warning (self, '警告', '%s' % text, QtGui.QMessageBox.Ok)
                        msg_dict = {'type': 'critical',
                                    'windowTitle': '警告',
                                    'content': "压合涨缩（压合偏移长7短5）短边第%s组，无法自动移动合适位置!" % int(cur_index + 1)}
                        self.msg_array.append(msg_dict)
                        break
                else:
                    if cur_x + move_step > horizontal_xlist[cur_index + 1]:
                        # text = "短边第%s组，无法自动移动合适位置!" % int(cur_index + 1)
                        # msg_box = msgBox ()
                        # msg_box.warning (self, '警告', '%s' % text, QtGui.QMessageBox.Ok)
                        msg_dict = {'type': 'critical',
                                    'windowTitle': '警告',
                                    'content': "压合涨缩（压合偏移长7短5）短边第%s组，无法自动移动合适位置!" % int(cur_index + 1)}
                        self.msg_array.append(msg_dict)
                        break
                self.GEN.COM('sel_transform, mode=anchor, oper=, duplicate=no, x_anchor=0, y_anchor=0, angle=0, '
                             'x_scale=1, y_scale=1, x_offset=%s, y_offset=0' % move_step)
                self.GEN.SEL_REF_FEAT(tmp_add_inn_sym, 'touch')
                current_num = int(self.GEN.GET_SELECT_COUNT())

            if current_num == 0:
                horizontal_xlist[cur_index] = cur_x
            self.GEN.COM('sel_clear_feat')
            self.GEN.SEL_DELETE()
        # print horizontal_xlist
        # ===以下语句用于查看map用
        for add_verY in vertical_ylist:
            self.GEN.COM("add_pad,attributes=no,x=%s,y=%s,symbol=%s,polarity=positive,angle=90,mirror=no,nx=2,ny=1,"
                         "dx=%s,dy=0,xscale=1,yscale=1" % (vertical_startx, add_verY, addmapsym, vertical_dx))

        for add_verX in horizontal_xlist:
            self.GEN.COM("add_pad,attributes=no,x=%s,y=%s,symbol=%s,polarity=positive,angle=0,mirror=no,nx=1,ny=2,"
                         "dx=0,dy=%s,xscale=1,yscale=1" % (add_verX, horizontal_starty, addmapsym, horizontal_dy))
        cor_dict = dict(addmapsym=addmapsym, vertical_startx=vertical_startx, vertical_dx=vertical_dx,
                        vertical_ylist=vertical_ylist, horizontal_starty=horizontal_starty,
                        horizontal_dy=horizontal_dy, horizontal_xlist=horizontal_xlist)

        return cor_dict


if __name__ == '__main__':
    app = QtGui.QApplication(sys.argv)
    myapp = MainWindow(debug=False)

    # --修改尺寸，并以桌面居中形式弹出
    myapp.resize(828, 860)
    # 先将窗口放到屏幕外，可避免移动窗口时的闪烁现象。
    myapp.move(myapp.width() * -2, 0)
    myapp.show()

    desktop = QtGui.QApplication.desktop()
    x = (desktop.width() - myapp.frameSize().width()) // 2
    y = (desktop.height() - myapp.frameSize().height()) // 2

    # --从屏幕外移回
    myapp.move(x, y)

    app.exec_()
    sys.exit(0)
